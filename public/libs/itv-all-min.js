(function(window, undefined) {

var it = {};
window.it = it;
it.version = "v1.0.0";
var $Util = it.Util = {};
$Util._debug = true;
$Util.dropImg = new Image();
$Util.dropImg.src = "data:image/png;base64,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";
$Util.dropImg.client = {width:318,height:442,size:50,lineWidth:5,color:'#FFFFFF',startX:100,startY:300,withUnit:true}
$Util._blue = new Image();
$Util._blue.src = "data:image/png;base64,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";
$Util._green = new Image();
$Util._green.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAADICAYAAAAz4qk+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAJdxJREFUeNrsXQmQXVWZPvfe93pPJ2myQAIhYQlESEIwQEDixigU4FIlI+KC5UzpFER0hlJ0HEMpamkox4oKosMoUjEhhLAoQSmQyUAIEAfIQnZM70t6Se/91rvM+c89/7nnnve605308pbz33p1396v7/3u93//cs4xPM8j2nx7tO7Rni8u+uJMfSQCM/UhCKzf6Z/xu7rf1eojEVhEH4LA4m6ceMRbpI+EZpCs5nouSXgJfSA0QIY3z/XIb2t/m9JHQgMkO0DoFvfiUX0kNECGtYSbIM80PnOHPhIaIEGIW/9oG953PId0pDt+pY+KBkgQwTjxucLNeB5JES1DNEAkS3tpQ36cdJOQOGvUANHGLOWFGcP2bADJORog2gQgQtEMdTNJL0mebXz2dg2QIrdNdZu2Dccq7en232uAFLkNuoM3ZitaAqukSVibaIAUo3shdlYQAGioeCW/r/v9gAaIFqjDRTck5aaqNECK1DbUbXgFQDCSeIXXH6t7bKcGSBFa3I2vhirucAZuBkBCdco1GiDFqT/IybrqgEHgfU81PHW3BkgR2ZaGLT8cyb2gQW0GWKTb7v5PDZAisn67/zujAQi0AABAHLo93/z8LRogRRTeAjuMxpiboSBpS7Zt0QApAttct/lVOOmj7eoHIYuJsxeaX1iqAVLgNuAOvG807kUNeeHWnGrerQFSwAYMAFGJWqAbLUDozSoWFilKgDQnm3cDe4yU/xhWrNINdEtLquVtDZACNaojrLGyhxry0lukGFik6ACyoW5DO7qKUwUIbPD5YmCRogNIwk3MgZM7VveiahEOkoJnkaICyMb6jW+dDnuEWITfKIvs1gApEIs78csx4XU6hplVHglZhZxdLRqAbGrYtA9PKpzg0zWmRDiLtCZbt2iA5LnF7NhSGr2cNnuggYZhEQ1hesTY1rTt5xogeWp/qPtDK+YvTkecjsQi7an2r2mA5KG9cfyNc+Nu/KzxEKfDiVXOImRr49ZXCu34FfwEMofjh49icmu0ldtTYRGXbn1232rNIHlkEF2k3XQJ1l3GQ5xm0yKs0stdGHVn3RogeWItyZYt6Fomgj0w5JW1SNJNziyk5FnBAuSJhif+AtHFRLKHrEVYVEN8PVJIybOCBAgI0367/wZkjolij2wswsNf69nGZ3+tAZKjdih26Chqgolmj2wsAltHuuNfNEBy0OiVey8FRQlmTSeaPYbTIhDVbKrf1KUBkmNGr9zvy8W0yWAPNS+Ct7gTP+Ol1pdu0ADJEdtQt2EQheJkaI9sLOJKG/yWpkTTnzVAcsS10BCzUs5uTiZ7ZGMR3glvPNn45AsaIFMctXTand/HTq/xrrmcCos40tZn930EfqMGyBQZpNNFQoxvU8EeGRGNtD8cO3xMA2QK7Ommp7fZrl2iCsSpNIxoBJP4v8l6pvGZpzVAJtEgpd2d7r5JkHkOgAMNmQNDXvh93Xb3J/PN1eQ1QFqSLftCzMGv2lwwEdGoriaeX64mbwGysX7jCTlbmkvsIbOIHPKyvZtfriYvAUJD2t8knESNzBpTLUxH1CIyi3BXky8V37wDCBxYGtJ+RQDDc3KSPUJaRAIx9o+0plp3a4BMgLUmW/eKZFiOupasrobfJEFtPdnw5H4NkPHUHXUb+3HSF4wOcMtpgMibBJQ+p++SXK/V5E1PKgi7hJuYJmco84E90OB3GrAZBvvthufvG+ONf6EvG5pBTkd3tLywBoRdqJzu5aYwHU3YK0c3vC2gVwPkFA0SS82J5gdkYMiCL58sJFglkFNmnP5c43O/0AA5BYMahjig4dR13oXnjEVUBuEhcIfdcVcuhr45rUE2121uA7WvXnWw5YtrGU6wogYBTQIb/G9tqbY99C2WZpBR2LNNzz4e82JnhhJNEoPks4UyrBLoadhubmnY0qgBchLb3rr9nzrTnZ9WG4Gnss9jQsJexdXANugMnvN80/PrcuW3GqOdJ3QyRenBoYP1/IoichNQIbCHOPB0swyLsI3uI0aEXq0m28PjJRVLFq46c1WDZhDFjsSOHAsVt+TIpUDAERKskquRO+PpcajVLkaxx+of64YZe0JlcomCC83wfwMWFwVHfh/0yOMNjzdpgHD7Y+MfX4q78ZlClHIGka+yQjQ54Sf+b/4/DzlDZ091fiQnAAKZ0hP2iQ/LojSUL/AKExxZcyOKcIX8yFTWa6Y8D4KZ0oyClnQ/X3MeYwIJz424huvXbDy/bgN7PrbGLEoGORw7XKf2ShSDaxlOsIbEqyfyPsbmus0nig4gm+o39cM/j0IN8x3F4FpOmhtR9jEvVrOtadu2ogHIM43P7IDyvXyloDspFteSTbDKUY16PDrTnTdBErHgAfLnxj9/s9vuvjbU+FOEruWkriYLqzTEG/57ModOTDpAoGLZbrffn83nyldOsVo2UMjHCGZNOhY7dqRgAdKaat2bAQhS3K5lNK5G3pIkWUpd9NsFBxAqSgdQlKpJoWJ2LafianrsnhWTUdSbNIBAppSK0ir5Ssi4QjwNDjU3orKJfMzaUm33TLQemRSAgPKmovTDw2UL8YopdteiAiQbKNTjdzR+9FheAwQQTpX3b4fzqzKFassUrHh8PL6pxwyKm1vrt9bmLUAA4RmFNy8zY6hteMGaLdKDPT7f7/Yvmig9MqEAAWSL8n0WwaVdywgnxvBPDdRjoJEIHkONJpurAbBMlB6ZMIAAogfcgUXZUscqXWoLG3SURY0o6y4rNUtJxIywoVVRM0rKrDL2ekbdZoL0yIS0HAKSDw0dqg8V4aShC2qIqy0ABtyALeC8wH0AAbYkssf0eQAMVHlTboodQ3g/tC7Cfro1/dinzv3UBTnNIO/G3z02XEZQFVrapKuV96mCIVOUmCV+vyp3OfgYXE9lpJKUW+UQ8ohj3O/0n0+jxn/PWQZ5uuHpgz1OzxKVJdSay2RPcpsP4AB3wtiAMwkYuBVkF3gPA4oXsA2OqRlID/iv821J5fg0PY8rg0C+o9fpXSKLJ1mIqlVKbQE4kCEQIMAQwBYIEmSNCN1KrVIGJtZkRPz3TY9OZ6+z4254pDZRezCnXIyc71DFk+paNDgyIxYGDDNgDtQcOByCAcEoYfoD31tulpPySDk71gCSmmgNew0eJ9xExXj0j4wbQBoSDW+6RiYoVNZAVtGmMIh0KphQ5aGtAA9nFSZa+VgaAAVEO8AeFZEKFunMiM7w30ePc2eq86bXj79+7ZQD5MWWF38Vc2OzVBCorkYL0+zswXpP6Q1PPDwHTKEOpgIwACiAPeBY4rhedEEzSmYwRpkWnSZczbHYse1TChDedHyHmvgKsQgJAKNNPQEBAIT7MAIAsBwIuBwzEghVvoEOKbFK2HvhdQBQhVVBqiPVLMKB450iqci25m2vTBlA6uP1BwCpMjuEWEMRqtoyDY4Ry5LCBeQR4W7geQQQZlUZEChjwA3dT5lZxpgFL0S4Xx2tDlxNsnP1qbqa0wIIuJa4F68crk6gM6YnT4xxESKmp4L7cLyYMOWuB5kGNxSxmDdB4IAOmRaZxo41sMucsjk+SOgFXBer+59JBQi4lpZEyx1yAiwDFApgtCnMQTdZgBp8qjLMcaAmGe6GdRrUJ3AfmGVmyUx/HLNHhItKkmQULuhJA0hrsnUHRC1ytCJHLXgAdFg7cvSiRjLCnXBGEXsUslyHyJ9HzcIELGelWaWzSE1pDZldOpuBBi5k0IpjLeidEkAgIdbn9J2TkQiTxalmj1EnyOD4YaWWQ0JoEMYykmtB1kFgoBaBPQpdEKjwPhCsmJ1lGoW6GriwJxwgTcmmh9VGH1WI6qTY2AQq0xFcV4RYA9lCYg8WBvP6jAwYNQ0PBrpkfvl8SJyxvwUX9lgE65gBAtk5mJogI30uZ0x1UmxsTMKjDRkMMsug1pAnncHXAChwY+0BlD0g7IX3YPIMa14Q1eCFPBbBOiaAsKW/Up03qVGKCgatPUbnXuQohU2wKxU0MXJRxaucXYXn2aQzfGIdBBm8D+o1EP6CFgHRenbF2WwPpwQE62grvmMa3U/91wss56HkOLIBZST2GLQHWfWxJ9VD4nbc72vgeiW4eiQhZmTIfwFE+Qn8PDbaQGYRsopnlJ6RkxGM/JsRJLix42d4ITDJnxW9IyRwN6hJ5Ao9sgvmSWaWzmTHnUag99GXfzxuAAG/Rf3X4tGwB+4TToK0xdtIT5ICwY2Lg2Ew9OPJp/TJilSRQNUbJEOpn/RAw14CTtJLkePJdtKWaCPeABd8vLkGxNvsstlkbvlcETVMZRSDgBD/PtcbqC2wPUL9rZhtVS9EAAlzP1aE2LYtzhOk6PFvpY105IXmFzZ/9OyPfmZcANKSbHkmK1NIG4ChcagRZsbxlTmjQv+KiMCPloSXKHFjkih0lUjUO6qrkUhXjQJaTxLQ/DkAT1OsiTTEGhlowKoiVeSs8rNYcmkqkmWsVO+5gjXkmpWhbFjIkzvQZMaQG4/g/wL2iDtx1lzkuI4Qt22ptk/Tt4wIkFE1DAF7HI4d3qGOZxl0Bsn+vv2MskKAQB+J4ooDA/0mYeBAEITj/dCVJflfWdCRECDCdC2zSQBmnrRjryv9Kfw1JubY/CT++0HgLaxaSGpKaiYMHOgasO8UXIGcCIPn0W3I9Rq5FYCl3Y2oSL9DSwCGvJi+T9ELAtgcQFI7WMuePx4/zv72gtIFG66bf93tp8UgMnt0pbrInp49DBxCMJnwY6PhDmwEBLoTCTRZk0AY/4dCOzWhNIwYCYEEARJmO3ZVekoTkwQIV4DIv5/2bHKk/4jIUUDCadG0RePukjD/oboQFKDoQuQLTGYRuS0Am4pkRlHdz5zSOaR+qF58b3uyHRjk1AEC7NEUbzrjrd63SG+6V/yAKA+n8LFQ1iqLEIk9BChM7mICQIQYBEFikFHpkNCBkHRICBgcNK4XsIoMChGuuw57j+s5glng9ROpE6Sjq5N9M0QDi6sXnzZY4LuxERmjGHQPMisKN0TCxwpBhP8rggx+L0ugEb9tAHQIuBpMtgEzMqE61EKShh/RfGjeh358Si7mttdvsylbWFHDz8ThiVbBYRimAhSZQYwQaERSxxjdyR/vxJTQKAgO4oZB4YbB4eGUnC7vyHdhYl+XgQWuyAurLzxlF4MuRHYZ+Dw2KLP8Br3PSvw0fMXcB7ooaHCG41hpVQptwt7PGYbpLidJYk6MDNgDLILsT/eTvlQf6bf7SbVVfeKWc2+ZNWYGeejoQ7fE7Li1rHwFmVUymwzR8PRd+wgoYO5a4ITz7J4ZUF42LZJNT0xVUkoNnVXAuF7AIgAKMZmvi/PGR8TzjFk6O9jJunj6xSxBNeZQV3IDvpYLUvCYVmDsQp+3KTgxeyUWKOLMATNSY2pddjNMDFMZUOKVMKHKut8pQOAYwHcPOANngKe4+syrXx0TQF7uennzh6qvI6vPvJaFhk1DzSR2Ik5ajWafCs1MFhGVyRwBxFiSVvBzIUvp0cOCgHFcRwINW9aUs0n4MewP9B1kz4NeuWj6RSf9u3LUgloELjA40WKWQ6WgF3I10usYmcjvMQV70/PiWSIbCwa5IXRHQ/YQTG/1AH36slED5OGjDy+9uOQ91q3n30Jmlc1iP2ZGWTV5Z2A/6XTbfXFkhkGhojbfs5wMMKYlmCVwMz444GpGkLgSUHrSPWRn506WyVxes3xYrYKaC4eI4OAn+TgiaJiEMryMSE8FD+oYHFAVRI4klN3GiAgYZ5Bu9DcvG1OqnSr4Fz9x9ifIrPJZ4o9UR6ZR3+bn/EGkwo3l/k2rYMAx3IlkFE3/19JIKb2VkRK6L4uUs8dl9HFptIy/FryeJjbZ1fU38nrn6+wqzcogSpQhi2sFAZmhvMQmGJllc+kofEGXgF6RvwNZhwLR2NG2419HzSBnmLPnXlRzYajbGr427aaZ7rAsK29cyLiDhRfMPBNOStQXrcAg9MJBlxOBPX3e5q/t7dnHjtaymctYOV4FCboa+Kx6sYVci2GExtEwXUJdUoTqIsMM9IicmVWFMRTuMMF2InlCvLcz1flt+pb1JwXI+kPrf3Hl7CspQ0RDz9v0Hz1BukO0VexVWAYWyi5CjzCAcMC4NNKQQAJ7FSgomFmBziChFajYPddgFyO6IdMz/ZWq6PNw7cJ3AqOrjCK7fFmLwAWO7gUSbNAKAPqyJd4CEc7cUbmYd3oO3LmEKvIwe3jk2FAt6TW6mfbQphxIlhuK+i7GCrsb/1YqbpBY3NOzl7x54k2S9tJ+czIXmXDCsUkIL8JsM1Bni4jg/cAm8J02B+ZoL2TmZgyX7GzbeetJAQLKoiJaEXoOkLf7xF4R1mobnlWgSFYiwDE8UGC5pNc6X6PRzwF2YuUEGj7OplFQvGJbAIpS+Ey2oSX4Gaz8AnvA+yB5Bp+pilb5rQDUOlIdPx4RIN/Z953t5ZEKCohUSEn/faCWHLEPhcrO2ka+IpmwVYBSooAFHkPialfnLlYfGS5PkjEgjQNBXqJeHbCWbfYmxnTUtUD3uxiJJ2Vvh9yhBSMC5MjAkfcDOBoHmxlr2I5NWmPHyYstfyUxI17Q0cqEVWwVoJREgmgI3JFpgeiPkPpYA9nds1vM+4EnniXHlMpuCDgSkOTOM6zTYNQiaxGs3eA4GywMUvdkyY3NGSI14SbMfqOf7Ot+h/SnBhgKD/YdIkeNowx52k4PKKDfLCdCbMMWJwqiHXZiPYMVCd/ufpssrFhIFlQtCLkdsUyIVM5XazuhDjPOJtneq7ovHPPLFg5wY1+nT92dAZDvvfO9R+EHDwBABvaRxmQTSXoJ0ml1MAGm2WN8XA9oFDaS34UbFZNO2q/Ewsn3/PfQkJP09vSyaAfpX7QxGDz17nGg8OdYpMm1C5T3gRXAR4jGI0zjc2ZBVwXuBlgKPEZHsoP0pfs+mRUgRwePfsbgiZY20kK6nA4/IcYG5Vhaf4yzmMWLzuLd6BDCYuziX80eOdB7gCyoWEDOqjgrw62A6xC1GdcXDFG6hWo7fPVQrJMJkFJAQnEP3gsaSHZVQ06gQ0KU0G/3l5hSt5ch1Vg0OCbO7UQjflYatQgB0Fj+hHXANq2JNnKw96AAltyRp7J6SKzycTYADLlJSnwPn1EA9QiOsUmTtJUBEKi9+IkaUwGHX6rX7mVi3Q5kQYFRWFdYxG8whkNucSEJybH9vfvJYHrQz3F4thCxjBmMMDuhyAW3MZax0SiAMe0uznptvPaXRqg9UB6PoRlkcpJt9Jhbfn8HsAogxDW9UNUcusEgPa6GuvgY7gMoMBKCDe6LVgYe+gZewmCZVBz4jRET/czlIYC0JlpXhXpHpX5SzR6TYw53CbAeBusxtaKsOGox10P3MH8IBUtnqos0x5r9flN68kXmlDMGRjPYKYdaRHY/cuJMntMFWhWYDnGHloUA0p3uLjVJMIIrYBPNHpNlPgPY3GVAAY8wTcLK8lYpBY7jNy3TW9JNkoahhtDQCDlRJnIodC+646ShsiILK3kKJAb4jpgTuygEkGDMSgAK+aZtkliEn1wRqUBIyyMRcDUgEVCcAg/UD9aLky0iG88OVYChq92VenBPNuqRpe5d1xQAgdbCEDBIMB2BnLnTNvGGJ87myS5ILzDxylxMlLEKXxuUuZaklyR1g3XMtagnHkNcmTHUiAdckxiVx0fgweMUSZUIgDTHm28hasc07zjX+mPyAcIqvDwjCqPyASyugSrB8ceD8NYAxiT0PgwEg6YkpkcoKGAMDCTLwBWxJJjnaxOmWSSdEghkM9QoHegUwip4NxjSH5VDXG1T4WbCM1SzUNXzgWGxbj6/q8+PbkzeuOySllgLA4nscnCPgjYjD2MELZWsiRk6cnmLJJT+GUD60n0V6vA+Hz1af0w1n8juwuHswYQm7A2fU4Ad/GkvCasIw/AGuWdWLvYhw8ggVHtMRK8scc9iAKE0FhWDqRUXowEyNQZXu8NrJ2kmMj12wTo8QcYamHmCjc0gZOHwyxLSnexmrgU+C24GgAWPERRZWct12NgZ+Ltyk7UpBIwSsahsom3ytQjTIyzpBVc9FaSY8OIbgIPwMUk2l65MuFIwwCB6xiTEZxAAB4IEvhNvLIkmTaanak4zlO4NOESDIwcMTywYgAN7VfGihs3vRyUiNCac+cHdwNBKOSUvIhf+HOZO1Agq+JvJT2J5T7oZ4cfapi5xRvzhnZi8Qh2SxnZEnvPAWpn/Hif0eWASjF4w05rNncENGAYLd2AxNzbDlNkjwErAI9qmmEWkjjL/yndE+AsnFPY4CQ9KBJz52uOnrzXeyhgHNAZbuZvuMdRlApc3FbFZiJSZoUw1g6YCRtvUaxFMeEFuw2OFNh84OG0gTtjjshwKr/TSLUUBBK/D52AMsew+UIsgIBwOPD+kDoRs5GeHfvZAmC00MHIxL4ILGcIVb3n+6H8AAOGLDgGTsFYB+hhaGP0xxv7z0DLQlezy53CPVBPXDKq5aiUYcy9ZGYSE6USHuDkmWFGsOpLIlBuYGQtIuRKMTrBaC4k0+BxOGiiLYBWQwwKEzwqleSQHBSueOH/8C7gDW4hLvKpxxgCWRDNcVrPx0+r+eYWUPLIFfh+wEoTEkDOR+0yGZRCtP3LX1fghq+9qfNeSxPI8BUqCuRQADc5zBuABwMDzAJYY1SPtiXbGHgxcPDkmz9mGBb4qq6ouY9iDmONLW24yCT2BMKUodIHhlBHgdkBfQEKtxPQbgeA9TIdQcMRBh9Dn0naKVWxhalBYmYpNNqNwhFwRpu992bx7yd1fJSogPKIhkstRDcwwaQ8yN+PnNlL+nCU82sHlaFGnQNc8G/jtD4xiugRmO0T3gkwC0Y46fNNUs2ghkHgaJrkKEv/k2uwRSFBWe+ECwVaypX7DkZ/zSPFUPLgcyI/IghRCXACKbBH5D/p7Pcd6voCE5UVMXLrdYo/Foog0tIUZjvwp+my+pq7HBma57Pwa5HjiOGuQhoeYOGMzAvDolbqYpyMhtvAyUaotx8NfnmofoiIV9EUpNPzQjQ2hhOf4yt2O6zKBCRVhGG8NpzdKQbSvdx9ZUr2EuRkAFg6yAoOVuyMYtYRGkHv+nKLa8gMgnusJ5mCdY6yGY7CUBQDDnzLTF7Ou688oDcM2YzaEtnHBGkPpYJos+hlPaBD2QMxbRTJmKNaWB+EvPckwByqAAFgCekjSfCiEGBpB0jSqcbkwTYtU/PaO7WxazFCCzDDTAiCVkcpEiD2UcEdbfiTSPC5WASiQ72CFPM+v5qRY3sTg89VDQc8BFJCedC8MeWFRkZwDm2ZOaxQAmVUyq8GTRarnjao9XltuGkQ3MNQBGGHAGWRgAQELuZFBd4gMuAMUPCk2Qg9mWgaW2dW9S3yeT37TJACyoHzBS2KmYWkcp8cX+tWWnwk1YBAWulJWAcCgZoFMbJ/dR2JenD0Hbgnmbpcz6NVW9Z8EQCBZ5kmrVeLyGcBGejn1/Hc9qEMgqvEnuUuJVD0biGX6K3bs798fCnFDiTLiSctlSJPcaysssPgkIa/QgUubGaRuqE5EMBDihgBSYVXYATi8UPFGW2GZP+AKV6viY3NN3m9CXVKlWdkhohm8c27FubuChZHldVRcLVQLzHyXYoSAggPm9vbthSru/2YAZHHF4js8ZdUlwSY6H1JYDMLGXVvSvO6mcDPN8WaYJ+SBDIB8efGX3wmtviRA4mo3U4CW1SvwmYnkdWNCzQA10ZohTwKGWH5du5nCAoeyTp98ziutSjvkjuQHl0679Kcyg+BiOp7najdTYDkSN7TCViAnlkxbsilEKuqJv3nHzV4Epj7ia8HgmjAwZxaM4tKW/5Z20vSWIil6C99PkedWP2cMyyCqm1Hn/NZuprjcS1aAXFp96RpXBogbvmnLf/fiiPMbjImB28rpK3+UoVuzaYuPv/pxl8bKRolVypceiwp3oy4ypC3f3IvsWgL3AtOBb1u9zTgpg7CcSOXiA2KklYIyHfLmuzh1Q8u/4si6eWXzOrJ9JitAfrrip0v9lRzRtThiZUftZvLX8JzK5xLP7xXTr/iHUQMEbH7Z/A5HQpjMKDrkzV/2yHY+qTh1IFE6JoAAopA5HL6CIwIm23hObTkOEMkTqBf+e2e895+H+5wxEhvcvuv2WJ/dVx6VciKyYNWDu/OHPVCQqjkQyzO9p659aliiGHES1NUzV1/lqCwiPdaWT9ojG3s4ZFXNqi+N9FnjZHpizZtrapuSzYuAOeZYc0mVNY30WN189t8SPdFuXrCHzxaYLUUWiRpRd+s1W62RPn/Ss/vgygfPC5jDJbPNOWSJeQlfLNjW2dUcNjZniLSosxzFAItcN+u6W0/2HaO6/FdUr3gKvrTX7WaDcM6rWEiuLV3NVuLWYW9uC9OQRJBmPJwdnT10x+I7to4LQH64/IefilA5A93RvekeUhWdRlae8V5yZcVVYjZfbbnnWnD1bdsLa0dglUeueqRqNN8zagFx45wbl8MXt6SayUCqn8ytnEM+t/BWTmHa1eSea5GCCsdm7IHPgUcY7XeNGiCQSLmg8oI9HW47aR5qYUIHRob/4j3rff/m6Kgml6IWW9YeXsAcpUapAx5h3AECtv7y9SsihuUdGTpM6vsbGI2VRcrI3QvuFj9I29SDA1kdAwkYzY/u5vrZ168Yy/eNOUa9cfaNy+udWnKg9yANm/zBNxdOP59cVb5K65Ec0B0IDFsAhM9rxl3LcCn1cQMI/IFVM1at39X9OmnuaxLrxX/+vM+Que5c+qPSulYzRbpDAMOR2IODZEZkRnwsruWUAQK2dunaf7NKzda/Ht8u5u+EiUq+cfHdpNyp8EGiRevkggOEqCOzR1rsYQzthlUbKk7lu085DfrrK349/5W+7e6xnnqxGE1VSSW558JvEMuJsB+sQTJJusNxQm6FgcMJQPKxOR9bdqrffVp58k3XbLIefve/WAoXbXb5LPK1RXcR0zE0SCbB4BinGSDSYi9EKd1/oOYD68aqO8YNIGAX1yxe9kTtU0Kcgh45r2oh+dL8LxGYo0SDZGLB4bNEOqQ9UH9cMu2Sbfdccs+3T+dvnDZAAJ0Jb2jZ0Z6/C1cDBbzlM5eS2+Z8VoNkgpkjzd0J5KUAKLg/v+L82nWXrfvY6f6dcSnFAkiebHnifX3JfvEcrMi4as4V5NOzb6UgMRj16ehmfARpWnEnAhycSRaULWhaf/n688fj7xnjedJ+9M6PrvnqhXftnF5WHUrcvNHxN7KlYwtJWzYbfKVbBE4RHB4PZR0fCGlJjKYdBMc5TQ+ufHDBeP1NY7yvagDJXYvv2lldGgbJ2117yZbjj5NBc0is+apt9OYX3yQBiq5FAgkwx3iCY0IAAvbw0YeX3nLuP+6bWTojBJJ3B+rIpvqNpMPsIBEroodyjjaMZTUVWYhm3gfNMV5uZcIBgiC5ed7H982tmi1WFAARe3ywnWyue4IcIYcoQPwVpHVv6/B6I8hxpKVMaTrEIpdUX7Jx3fJ1n5+I32BMtHB8tfUN5+ozrzDRpcA/PZgcJH9sfI68HN8uQKJdTjaXomZHZfZIM2Z5f837151uKDulAAH75tvfPLz20nsvgkwrsgn4zj1d+8jGtsdI3IwxkGg2CbMG6wBT6ip4g4Utb55z8/LTSYLlDEDA7j9w/08uq778Wx+c/35Wt4FpkMDldMd7yZa6rWS3/RYHSZTNoVWMq17JTT6iE8xRq7M2THw88MiVj1RPxm8yJjs38dnXPuv8x+K15gUzziPRSJQxymB6iLzR/jfy7Ik/kYSRIJZlsZUai8XtiOEIHCC2a2fcB9cC+6tmXvXQ2kvX3jlZv82YiuTVd/d+9y+dgydu+OL5t5PLZl1GWcMiPZRJavvqyGtdb5BD3gEKDh8gbO21AgUKzuAkGoodOwMoCJBys8z9yKyPXDbRLiUnAIJRzksnXtpd5Uy3rj/renLhtAvYVdKZ6CZNsUayJ7mHpMxkCCiF4HrYvG8uHxcbYo5geGsAFB8cl1df/of7lt/3han4vcZUp79Bm+zo2fGtKqOaXFF1JZlbNpcti9Vj95Lj9nHSZXSEmMTkQMm3bKyYjIeNbPM7vwR7hPpGg8fzyub1/Wblb2ZM5e82cqU+8vXdXz92bPDYeSBUF0UuYCtEwwT0fXQbMPqzggQX0cnVyEdMBug5AhwYvgaTBGYCg/7vzgdrPrhist1JTgMEbc2ba9ob4g1zAAilZhkpMUpI2kxz0crnFjet0FzjCBaDTys9VW5ITF/u8nnd3Mxpnny34QpgiOfoYxrDeVfXXL3mnvfc81CunA8jVyusa/5vTUdDomG2KekPGNVncpAAOMJAwef9mYODWYQnDjCeMqe9x+f/8pQZmRAILmcSHDyNbgYYY3n18rtyCRg5DxC0tfvW7tzTv+camEAa1n81OSgsoUVUkJh8DnKTA8WfeBqBgqBh/zwCxxiWEkLMINwG8RcIDBY9cDNmqHbVieJcZQIXCpr55fMHV1avvCYXXEneAkSI2YP337G3f+8v+9J9lgwSONmBFjEzGITtJWDgRgRgRmKIACBEYosQaygM4kpTS2bM6kNBETWj3tKqpRunKiopWIDI9oP9P9iwr3/f5+JO3GBgIf5yFgwQJJNFAAOGEWYRmUGGE7kIhkyXwucYJSSTPXClDHArxN+Da1w8bfHR+5fff1G+HWsj37u81h1Y96sDgwe+0pPusQgHArKGKYGChcUGCdjEh82wAAmOixcGh7qmn8weHDxgVFd4F1ddvHHtpWu/kM/H1yi0NsD73rnv5dpY7fsAMEDtyBxmyK0YGfpDFbJeIECkNfwkBiHBrMXAEDNLZtqLyhe9du/Sez9QSMfTKIY+0Z8f/vlPmuPNt3Wlu84esAdMWL8Nr/6APYxMdcpBgDqn1Cj1qqPV9tzSucfmlc37yZ2L73y00I/d/wswAC495kQgiJDBAAAAAElFTkSuQmCC";
$Util._yellow = new Image();
$Util._yellow.src = "data:image/png;base64,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";
$Util._red = new Image();
$Util._red.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAADMCAYAAACoc+soAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAKY9JREFUeNrsfQuQHMd5XvfM7O7d4Q44vI8EQIAvgKIoBpRsiyYpKWEcqVQxLcuOEseOaIemoyjlSpzQIiNbDHiAKIs0DyLtxFVKiork6BlaVpUcuuTIisVQpViiKFM0LQkkxIcAEIcXD7jXPmamO/3//f8zPXt7h8PhHrt73VV7+97bnf7m+7//0X9LrbXww4/ZRuAPgTNGhv/YHwQPkLnGe/0h8ACZjT1u9wfBA2SusU9XpwAoE/5QeIC0HgYgOk37/YHwAGk1dspaXYjpaWCRt/vD4QEy81jEsRCNmtBK/bk/HB4ghaG1luavkLUq3An9EfEAmTmUEiJuCFGb9jERD5CmMXEWmINAEoNY/Rf+oHiAOOzhpByqxsykiTQsMugB4geYk6+KJMnuyobxZhoNo0jEUQ8QP2C8RaRpfi81YEmMR6PSNR4gfoAHU5EACHeAmYkTYJdPe4B470UUGCQzM9MgVn/ZA2R164+dAmIfABJ3gJlJQbhqEKtv8ABZveMJ0hszn0EzE0Nk9bseIKtXf+wUSdryOWtmanAz8gBZrcNoD2lB0OK5xMZHgEUO7j/iAbL69MdBkcYIgNmGxKCZeT5JtnuArDbzotS/FfVaa/3BA9gFAKQVAOrLq+0YRWJ1jxBNSLMH02SCrEdjXiPT2zyDrB7zci8yQ6123peimalPC23f93seIKvDvNwnkob1VM43oAQA0JEkEDi7xwNkdfi3ASbo0uT8rwUT1GhYsWoIZTVVwK9OgIwMf9cm5Bq2BmQeQ1anDUhiyyIq/aQHSDeTR5reAPoDi5TnOyDaqolNNLLIL3ovpjvZ43acZJhw0BYXMGTNCNVImqMWmjvysdVwgq06BjHi9JMIEJXM7d62GhAzgQSecY2xyHkVsEiwythjp4CJbVSFnK5e+PshoAbCFoJntn71MQ+Q7mKP53GCMb/SWNBnSFieCUEzI3KJRX7NA6R72KMsVGy9lws1L25MBDUMucha/3cPkO5gj0PWPMQLMy8ui9SrlJ/R8LkAvo96gHQ+e1Qw4abFgs1LNnD1naAcTXdHV4NVwh7P42QacYkBr4v+QG1rSIhF8KGD+7/mAdKZ7HEzag/0OsBVrS7O58LyTPg8dJfRu7nVA6QTh1JPIjggKRdfhDhtHlwGAOF3/EyjR0aGj3mAdBZ77ENXFPMuanHMiytWpycLLCLT9FLUOx4gHcMe99mzvJ6vllvMkVClGbGItl7NYQ+QThCmHzvwLPaAhUuS2gDXEgw5PUHh99RetI66KXjWnQABmo/jN9i4R92C5GJd29kG1IkwixAgjdv7CQ+Q9jYtL9INyx7TS9u4EANnwCIYF8ECaGnc3ic9QNqTPT6qsVoszpNqjcbS/k/I8kpByycsi8gkuaUbBGvQZeAYxKgmpvMhNqGXnD2s4NGUxNN5dNUK1uc9QNrLtBy31zFpg2Vgj1YsgtFVLAcoG9D+pgdI+5iWHptlVZjSXxb2aMkiFESzIPnDTj6ssiu2A4FeYkqNYWYVJgaa4cKa2/GxZT6aUujBjfZ2b6+5b86/KBIiDE/Iu/YNeQZZqZiHUqc0nrVxZlKWlT2aWSTLGCt0gWWabjUgfo8HyEqA42P7v4zBKWXNCpgYGdvlCSsyQIsAQhL6PilEWLGD0Rc8QJbftFwv4+Q2e8pCMKxub06v4IYNGYsocnuVDZ5pLfXB4b/zAFle0/IMaiiIeWCuBeo0qouXsb0YFtGayhLTvHtAqq41oH6nB8hygOPg/uMGCBInAFij3rAsssgZ2wXr1eqkvcG9RzBXoyAM/7gHyNKblvtkkgxh3AEonPItmH5vF6/MiGWJ2sOG+5HVJHxhY2oeuu+wB8jSgWOnOQv35aYltfkWTuu305hmFqGgHS/f1PrKTvFqOg4gRne8hEeZTUuD8h88Ge00YP1v6qzDAZZT1vU1v+N/dkIv+I4CiB4ZHjXAkFziZ0sIzUGH6zRtzy+NZo/MjE6hM0BeFiDFjzxAFs+0/D4GnMCOK6ceFDTI9FT7fm+I6HIlG7MdgVkm6Qbzu/a382HvjFC7cQ2N7vjzLEsLA9pCQR0onKHLlZBb8FGWQq9bb8/HSsmG3wO4SPOUeSwIdom79r3iGWRh4Bg0dGzBwVlS7EyIIez2BwfaRt7qLLFuLyYTFWmqtK3rWIP2P7Z6VLO+gAOcWK8Fx1QHbXFrACLBL3czvfQ7jHCN9MH9T3iAXCg4Dg5/25xplWyrMEV2HBJgEM5e6YjpBQvWKZvhjSFflFj9lKJHAxVob21H17d9ATIyfI85eD9pFb9CD8AW46QgnCgp1mHDeFuS2END5pm3QQsCrEATbej6Bm0KjuvNEftopjuAMRKVh62nOnj3dPjumtpHxFQRjybULp0Ak+oBcj5RqtJnUHfgWWVbRenY5loktoFKOxcgYE5AWIO7njI4KE8DKsWYVP2xA1/xAJlNdyh1Qiu7yTGCA6Ol9kzD1EubJOMuahgXXbLpBFZUIvPQ0OgkyTvaJevbVgDRI8N/a0BQzkQp2W3BbDI1Kbpj6Dy4p1S+XCJV2WOY9W0DPdI+ABkZ3m/o9TrNwMBSPWU3FtQUTl/stbVtIlht0pHKE/NKOEMyatQDxILjLeasuTcDh7Kg0A3SHXjGTYuuG5PAiJKWbtp+8GhktA2kSS0qK92YJmgDcAwaYDyhOQGHZ5W0B4yKbMTUlH2u24Z2WlLgxkb1fHv4QKLrK1V6qzlGd6xagEBFOvYu1WyDtaVe1B1Eud1kWppHvWpLAKw4zV1e8tS03c/m0ZXSIysKED2y/2UJFelZwtBWguvY7kIp4eHqlOj6AYlHSVMRZ0VFtGdeyss4T68qgOiHP/zHUiU7cUkABYmgQEIwY2hyabXufoCY3ys56QjHgSvjACBBYEW61qEeOXB4dQDE+Pgyjt8L9InpbnbvcEW+PThoZuKGWDXDMGVmalIyrZqOCZQLAKOq5Er1yP0PLufXWv56EEzfqzGdqlyQgdaAaqtaAz0YNC0T51YHe7ijVBa6t8+yRhAK0dNjI658HybM3n+ruGvfk13JIMaWntGUY8EfS81tre5IVpdpaRUb0YrcXDI1vOmisuIVT+g0fWK5ROuyAgRqSiU0d9Hk/oNSB5Dg3i02QCThQKwm09I8uCSAlkxIrmHNamJolZ4Uh7sKIOqRD/8XY2O3YiBIimyvONQaiY0oIqNMTYlVPaCGFXbiBJCAB8P9Rji5x/GTVG3EdcldoUFspPT/Zl0HKVJoI4h1ykVI3NFJ1OvCDwOGgbVCh4E1uVFJiErFPhWGy6pHlh4gYCvT9DX4NZqjpJjCFzZymFCuBcAyfs5jg4cBhe5bgxFVIQ0gKmUDDtpBDoqeedoMSGQYrjcgOduRJsYI0lEGogTkp47WoAQVjq7J1C5ibCSriaFqOi6gipPc+7PZmyVrAb6kANEH938DtuFgrwUZBNe1mNsJeS1gWrATcupB0UKwossvqFMABtOk1XBwgVJFOH5a9+mPHfhqZwFkZPgOI0pvlkSDnFvJGsslpDtwRX7Vg6EwK0EmRvE4gQYBU8MVdlwdr6yW09A0J0l+xhzzn+0MDcI9w7LP1nnHH15krWwFlQSvZTW7tYXZIBAAIEqlXJT2g2AN6bkwj43A61mXBLYIb7H1yJLsmwuFLjLzVES2XQbb1gwcSeLB0QyQcsWKULikTp6qVLZggeMFEdawhOt+ITyvyWyjxpPyiHnTQNuaGKM7vm4MRwVsI1IlfHlJ7i16LSmtctfdUV+6mOCIaFkmMgeBBAADk88MsmYAH5PAMIMbhQaw4PsDu39emvbrhw98rj1NDNhApf4MI6RsMxMrTIEtNJoWqvkAHeIB4nB5ZFkC22aaS6XHHr+Q8jDwWH8/sYWyzwOgwLuBfYCnqtgsT2LeBk7KxYmPLB5ASHegt5IJLCp+gUuDt0LXtjr93DnRlVViC+LxkPupCgGxD7gGsKDmoMchsmqu9Zo19vUABDi+a/rtcR03smNq2jYxQjkilWGdjRerRxbNxGBuAMGhqaSfgAHfOHarwiR5LR4c+SxIeymXM3OBACg7wTEwKeZxGZUtQABAJTJJcDKuHRRi0yY8vtqG5gPDNt9sCw0CNQpGU2zEKeflhHlnv3zZAlKWar9WUSutPdgbQVMSOs8FuTZhjwbMC+gOAEgPmRno7jyw1raU2GhBAiepTNPXXazre/Emhl1aW5JNlWHC+uvwAyG3kuTbh0qImHZzjemFDjQnZpLLPfY2swZoDGQNAk9IZgWue/uM2xvZ+wAUeI/mvXGmhD77mpCQtpAZGy3Y9Q0W4Qw4Zhcek7aQpD/go3n7cn4pAMODo8geLEDZpKAeKeXilFkFvZpSZqYlsAf0gwcQwRIJMD19BjiVCno8kMehBSNCB/KpFTExWP6mVF/WDIXbPnKdKSXibMWYua7VPChm82AExYsC0h8cUmfmYLYBt5c9RGSWAE2NhsfhDcYN1pdsN3pki/UebaOdqxZqahYOEGNagnr9AwwOyZ4LCqSQkksUXi80TvGjYF4AHBQ4zOIfaFaISRgwUZSXH2KtCNXzliAmUjYMEgkJHo6iZKgxQ3Jom2GP0FbspemXlxUg5uu9xIt7sKhWcPg3sF+SW1BTfdCqWL5woeaF9Z878XwS8fNcj8pmBkwK3rYCFkEiSMia18mNW4XcsBGr9XQpsmYLWCSQ0jD+V5cHICPD/8pM/iAiX1rFbMPCsik1TS4c3/fDOcN07qUwB4dB7sUweDJwhIVioUy3QCERusc6F7xG4MotQ0KCd7Nth9CgVRQGJyGht2tpAWKXSn5cUgGtxH6f2nYAsutJLWVqu3wQ79d8xLS1e8uzEORMwZ4KX4fBTJcYPJcgyLWeJIHL+Rp6LTCIrPSiedL0dvPnuSUFiIqixxAcwBiSFhtjxNQqcmz0kib5GZAknj1mYxDWIULnQlTIosmRTeDJ8luSzLnKQRGRp9O/Fm/LdRvMJ5uTNrSeju2umK4xJ/kvLQ1ADD0hTbHpgJ/DgTGI8vG6UooOWvbwtR5z0AiZ4dBp9i9yQGTtqUQODJdhpOMFcW6GXecNm2hdTSD0ZcaqrN9gMalw4+fPLBWDfM9qJ42TD+DA1tIolLRlj8RhD++5zHHkw3yCOSXBk48bFCRFs8JsUxCsldzrYRBh0i/KA5PGk4F8jQQADQ1xhXyQPnL//YsbSeVMLbIG76JEQhRX5EMfMacIGb7sxHhLgKS1mlD1ukir5ppMEH5vPlBNJ9ksbtQMysbyOyziDdDtC3sqIjQCLeAcR7u5uJyUgzOfNUSJioV6+uh2OS8g4qhpqUT5mJIFSE+vTfJF5OVoYhU49hDJhrU2EFl9+bAQJ09QhBWBd94I67wLhsz//KIkVtA8OzqfKWQPtzDIfLl0alIkU1Mina5iG4MMABxylbboEISYdB5rFnNyNnw0gTur39S2Q0BsvlM8PkGPseMgDXB6RNjXKyKIG6zUgGMVlUhniDy5Sea6yDasS2QL91jmy0hc74Y9JN79ivXJpduFePWIFbFh8CnzinddPEBGhn9bqrRcCOg4kwPsAUyQnhwV8Wuv4eRId4LhEsmCcpeBLABCuqq+FVDEeYjFAasFA4X+tc7v02uQvQyLNc68lrmbYW+PKK1bu3xs08zcnKxjsQpmhiOsrplxwcF5Gq4j4cAaHwR4rK/fOg/QfpMzv+Y1mMxL0p/DXNocLDIvgBhR86AFufOjzA9Ix8ZEfOTHQk3ndQhwIwiDDAxSyqbbIv+xzA6BLLpyGUbOD5QMEJwspIMoGS9UnyIJKLR00YKFbsN1as609EQtmwBgmdLguqUFjOvdYVAxyrUEC1HWI+zKZvmbvEYkE7B8ALjoyMkSy81DaIr0jw5lRVwaquKj6AHz7vctGCAgZgJbZIBfIHn1mAHFEVukQpMfRA4giAYLYGi+nzGIc99lEFeHyLl4QzeZlwwtLZlEE0i4XkW7t1XxOm0YljlxIqv1LK1fJ6L+/sWmEasTyk5I3fVm4LuVuWCI0hWZx0NMASGGIM71DAvgwjHSuYbZtlOIc2eFnpy0a5Majd8QFwOQoF7/YGqETePFw3a5Atk9GdkvzYCYCY4cENlrmoHBLBFIZ/6lY2Hk3EK1JVY0kYDOw/wuGFiPKJ2xCgf80AVsBRhzaYydFY3X7E7eYIpK69YtkpvLUWha3gCTmFJcCTO1eqZZIY2XmZMgLJ5YDCh8PMo6RTKz6m2XCXHqhNCnT2IIHiSEMTMPXThAzBunn/w6GgJlvniINk5nAJCOeJItAFF4bAajzE9rXMix5hvZZ7d6upk5XHNDoGl5DZ4WTRYI3/jcOJ7F5Y3rRdTXt3AGcdkypc4GUR8tMFNFrZKdeE5BOJtzDpY5kdTsNf0DFmyTRoesXWd/C5gZqM2pVeGU+oh51UMX7ObW3/fPVWNySjZed73xpdeI4PSo6Hvh+7SqiybdAYfk4I3MnyvokDaOamruC9bMIhjrUfnjyj6ePUZrVECrVLZuscdgvoOr2HmpAzSP4aIhiHFw5Vi52RUmVxfuY2FRxZop+By4wGNlEq4cbY2pSBxAMjEu9JGXhQAGOXMKC6FlGN5gWOSZ+TPIyPDPNsYnZO2294ieN+w1H6JE/NxzIjl9XJQmz2VgyEARyJnM0kF5kYx1Ql6lYReUW/YIWrBJkIEHbkP2tHrULpEtb1g/P72SneWimL1lF1UpR6RC0pPWzXCYXVJRFq55DvI2EQVXWbeMG0EyTxsG0XQiG5cXwhhXzhsg8bFjn6+//efE4D/+eREQhU7GqVDf+brRJVOzsEgHgeI85gp/j0GLDAksqggOBAs2eLHg0SEwij1bUa8YFzpc0ycqWEg8h6vrMjiH1qUTXCyVc0DgxDSKyT5O3Ln5GwaaYI8nsBn1vjX5/wUNA0VFUB98ctR87/iKVi5vMFvOZSKqrBm47d0igDOBFHZ500aqYrIiNTAXuJZB0D3gaHmi2+hsUDK/2XgVcJF0W+KFHofHSvC8OSbmGmIt0z8+ImrHR4VulbDM9v2l0kx3BT8Lp+bt3XVTHEUGeVE4Fognecsq6QTYst5nwcyIrswchTvnlYsxP+zT6U23iHBdUxssJUUIjV8h0BJ2NyjmNEcIlghBAGBAUJSiHDDO4wAkNj/VV4+3AIougsLdyGAmrRVFaqa+6T0IuMQ+xp8pHXaJSKcAWGCFHjAKtd9AsxoEvzMvgEwfPXbz2je/pSi4gDpPnxCVibO5q7rac7EBijsLhAwoxCwuSJBRbPyCgVIwMywm+T6f1ULmk8+tuvg6JvaBa9YomTZxEn/NAwQsAKS3V0gAyCU7hNh6iRXgSbK+uTle0MK8/Epj/UYRrF07U+m/8Jx9h/QAmXFyA6uWrGlxQSIzs5MDBTLgYHrqp09TL9SkyBxsJrLywybd0ophsiZ3XNmn8pYbkrK8HInNwvQUhUXhm/2fX54TIPHo6B/ozVttIMx93Pj9pe8/48ExH1YBfdakVzKg0AXuo0Y5ckQksJOFm/p3uxpixDrIs7+cn9FqZtie1x816sWyi2Yzhet+m1wbaYubVRB+cE4vJn7x8AZx2RVYQSj5u5h/XP1//0esffVlu8rcj3lqFevyQzM68Hh0QGWY8JiCXIhETdI4dUrEZ8dFZcd2EVCRTyFrCxMfSGdJZoXqSZwoNJqUyJqcUrnoSuumehMAD+hLYD1aO4NAPHHcOFCN7bMziDEv2qAamro0xk5htE03amLymadE5Rv/u1hH6ccFilqHUTLzE6EnaOOJStRHR0Ud9An3RtXUUFY5Hgr3lnXjG5zW5+fc0oEZgQ2nMp5vA+CMHsnSGyPDe1syiDEvD2O9xIlXDWM8KepbjHgZPytK33lSlM+MzjA7fiyQUZou2AyGllcqYOsjR0VlaEgEUK/CJp2rxAAEbhknswzmbQhYwAYc83D7tAgx55p5TdVsKgzfzxneIkB+/PIm+LzKq68I8dQ3zT/pFaWx06Jy7pQ1LV5/LA5Q4ESjFf0gbnENi7HndqWAuZ1K4zGeFkG1Jspbt4isct31TAqusZoZeMOt4HW+2JsLifg14PKmtIs5drq226KR1/xuMQMghla0MS2IcvOG3pcPISgkpPLxB/m5XVwxG1hwkC6BQISOArsQCu5XSmZuU1E7eUpUtm7NtwvhupACg8jck+G1z9yAxvV8stpVqnvtH6AYiLK1xQDU40fBlG2aoUGSWvVBKdwCn7zETXLyzY/FBwrrE9QjAZqgAJYsqCSzDI2xMZFkTYZ1PuHc6ZCBge1EVb6TpkrzOEpz9DRbi0MucGSTgnaDBS05HpIBRB09+rY8HS9yYASyWIfgxxKZHXuspWEOm4eTdht6mCEz0enEBHo7WZCMTQyDIAvBq2LQjF1bjq24ArfJA2aGopt7iwxy8kTZLQ0s1m/4OVzyAb1OzdkcGFMDZj2AjgiY55KUg5NYGF4/ccI2+IcVBNzzjSOsWSyE0vvg2cCqxoazWSJuFOls6gymCxaAY4R1DTY7Rh8oDO7MAQL6o153gNEEDs8eyzNg0mHxBswKgiTFjZYkUD8mRwPUhfG5c0I14lx3sKlh8QotvmC5A4CEPR/lJPI4R8NuLkwvVrMZ07Z5iyUiKX/KZZBfkFyf12xihNcfyzay7smprReFZZOYeEuy5KgNaymjScbxkrMC7b3L5QDaAQwzS/PgivgsiBbZPiPwf+JkZwaQ+PSpXxfNdaR8O/AmZjm1iBWYvJdOil5lAEBJYzNpxDDwXBTiUhNgk0LeRTFj6CKz8EmOIfh835nCmhp3SYtW5Qwg6ckTQ5yskbwUweuP5R8c5MJJiXMGwKnQdsUgsImyXoskHRHD+h5mEa1n1nxAqSGL22Zlyp2w62SWwhJZjSCPpKqJ8aBQQV4wKR4hyzp4dSJ3po4owEWCFWNSIdodBAnWl5jXAEhKW7bkk506/eFAgIJg5fIB3vIMi4rI7Y2o7pWsBohVOTK8K8B+H9WaU2bXpEE8PlbEo8mzuXEe10gaQjZq2T4xguNW1OoLVjWix9Jo5NokddpvqNSpUFNNwTaRbzGCGMKI7S7gkb0S/6GzD0mLhU5+LKdYpTOfm8Rk2VwKQ6QxgUTR+UweCoAEhCuXMcZkVrBnS5qbGOmIYgATezOwYBxW4TkWCm7uyt/UtKLNg2NltYhyciyNRhYxtTpRWe/GsAo8B2KWBWcyQQvW3Q5GLGTR03Gq0Lg0INvxPMW4iLY1sLsClabvzr0Xhz38WHktwoGspqQclGDg4usopM4I5jYsmMeUf4z6IT512rIKJO2g/Sg0EeQ+tRyGh88Gk1Sr5b1cZOiK3L8fpBMTu13e8R5MO4GERCREQ7lajJc1ACDM5FomseF2nLI0n/j45Ek7+ZyjYebgRj9cKc/tShN7X/MaYDQxtdpm18X1HkybilUACUwsXDsCE2MloE/A1GBSOLWgEfY1KWsSZJdk7j75ARUeKZv2V6XKtYFBW7+fiTYecSMXl3BNO5XrKm3lBlHX0LrAkjwWBA08bp5XBhAKlls2R1c5A+xqnWBmQVikqtPRDKbIknZ+ftpCsHLrBwAF16TSLqISQVPFllsYY4VJh9aXOl/xqKpVXOIg4X0hg05kpirvGJAWq88AILo6HRQ9Fz8n7Wdq4nyDIU6+RVSgDGd9Yus6ZEDawZgJzbtRQb7FCNVkalJE23bYrcx4YTe3nzAso1nA8robx81tOaRHS3t5NKxFGqQlqEAI3VHFBUMNG35nc8NrYmi/YujzkgGO2SbNyw0ti6iCxon80e8gFoHYBqzwD6LcJEB/DwDGuvVOUC3Ac9+294qtl2xELJik9PQpEa5fD52BqAkvcQSIUy4P0HkHI19p2kmDhaW7sIpbkk6cIzeW3F9af8MVZrgtCPQlA0Bx+B48mslJbANhI67kNVH7iyCuf98zSKcJVkjjT0/Y7oWQZINJjsAklNCzkdRARprbGpZT4E4QZesel3vM3Ae4kq+0bbvdJJFZI6HgGSzOh4VeGCMJaoHs70/9ke+w4Bmc5eC6cgrfWc6gOfcCbi7ERiAcD1lhbKpbwwyxNmBJRl+14HB1Duds8hjYV4Kg3JO06kKj/a6Ubc4kqRWsMMC8QDdl267a9h+jSKmkGlVcNkHvgT2M1dhrAlZRZjkYeD/Ug5iLxuAbqo+zgejrPV3857Pe8aPdxvRU3oQGBsRJ4DEwJ057UckhewAMskWCc5sc+bF9fUxtNMnNRa1C+Z9IRKVJbqU5szuxD5a1/cCuiCVbXBTTyn2YwimKnkKDOxgQD4FcS1imJjYBmqPUgCYcHDRAmbQMAqIWXmtd3WeC0uDgEwW20J41Omo0qHodzEVATe3qtTyPQ9VlkOkFc6NrUzbrC9fm+eSVF2mJRJ1MlsxNzF37zoKh+TwzRgYT7U1Mx7EImIfJcWtmKF+T5VowAZciy9hsr73GfE6qRPrSS6RhSJ6Cd6NsqhcAchZbIXLHAKd/ucdHhwlXmnwUrWBiqtP5iZ5a3SFRf1CJALjLJ0dFg/u3a9pFDMxLuXzKapC79j0jn3wCV5XLQktGf8w7mlEALBXycKgYGRdQQDAM2nbCwqvYsAhoj2pVpOfOUtNCu0ZGB+EhSQwiZF+fZpE6g0X86Dwm4XgJMAi4t7VqpjEgJiJrVPVenbT1rYEUjb97zvZypwY0Qdx4mE2MiLZfdra4aIZvepB0RWCNV/6jVmlk1fFoMTgkD5okTdweI89kAAk3bvjLmfojd3X96BawqOJS2sDdkMFg6NAhLCPBWMdd+17OABJEpT/KzUvR1HiEdNmQTcCgFh+wki4dO0P73ZXG+OU2m3vXvq/DCnJdYA4HJH50GUhcYOQMguvuINQeRX9RBAiAZusljWYTo51dmvzoJny4wChuCtV4/pAIGo0HZgAk3HX5Zws6RDWxiR/d5OrMkoyVhkFqwt03JgdIFD2Cb1E5SLTSXod0pSfsyAfeFInuh+jR5iOvKDOoCddv0M3A4F2XvJnpKgLJ5rbZISlv2/abrQFiRmnPNd+aCQxHi/jRHeBQLgk4ssK213x8VoCEPb3v92am282Lyh2RbEs1ezvasXNi7h2nwMxs3qy0VkUG4U38PEg6fyhnY8Zm83LZzvc3v3xGVXu059qHsw9xTY3yZqYL6MMJXfDJT2TQ2wsE8ZnzAySKDsAqrszVbaIhPzoYH+7Jroryofz667/V6j0z18UYG1TZe8MLzfvDFkyNHx0tTrM5ZZAIKaKBgV+aH0BArPYPvD3bp6SFqfGju8Rp6erd45ycmxdA4MWlq/eM8Ydo3MxGZR+qPUg6jz1SO4/a2VmcT/7Stu3vmu2tsy69LG3b9kbNqlc3s4g3Mx3LHgCSDChKRNu2J5CsvWCAAIuUr77GskjaikU8SDqOPVIXKPaEr+y+5t1zvX3OxdvAIrDKm0VNdfOlorp+C4HFh987w3NRRVGa0glvHitffkXDEMH/WjBAkEXe+BN/w6JGGfc33nW1mL78dfk/9qOt3VqX8bUbtgAC2HXFnvN9xnnbPxj351aJ+4hoEYxPCL1mrUhuuFFUd+7ObJkfbTqUKpoXh03K17z+zGyeywUBBOIipTf9xEH4Z+XTo1ghHW4ZEvKf/Gq+XafHSJuaFt3SvEBX5dLQ0FXz+Zx5NZCJ7jlwV+mq3Q2dpCI4dlTAde/lVwn5yGe9qWlPtyVnjSbmwBP9zTcdbE7KXRRAULDuuGwPIK/80gsiOXYEm72H69YJcf/Hsy/hR3t4LexEZO5smnuipcuvjOGEn+/Hzb8FlbFXlRtvejSYnhLB4UOidso2RIuGjGez5+/ZL+WTee1hWog5BIcm+L45qUu7Lt99IZ93QT3KwrsP3Fm+9rrxyveeErUf/gBNDSzTW/Mf9omkZ8Dc93qkXcBRjIKTabnploPzEaYLBggyxtahnVGlotW3vykUrA6HDzHub+kjfwQb4dk+336sjEvr6o4mDVLafc25CzEtCwYIiJueG970tr6nviHOPf1UFnYP164TyQcfyunMj2UVpSJtcmkdcASD63Vp2/ZdC/nohbXBvGvfk5Wbb3lU/slnRAo9KWDIQPQYz2b6zrs9SJbbY0ns8VZJOgMgsAddz943vm2+XsviAIT0yMCmDd8a+9JjuVkxemTgxlvE+Ltu9yBZAXe2WZRC3qXnxpvvhhN6of/iohrpRvc9dOPgD549VXvxcL47YxiK9e/8eTHxj37Rg2Q5wEHsoYk9MhYxj1fe/NP/I7hn/+9fzL+Ri1FnGn/gfZPBhx5cg3ER/v6Nujj7hU+Jgb/6st3OM/RNnZcaHPljqSjvfdMr0Ycf3nWx/2pRZq00dOn2xv0fVKqWb1YDHX/X/dP3isl/8K7sB/ixiJpjLnBct/fUYoBj0RgEx8jw4OT41GtrfveAxHbQNFStKs598XNi4C+/SEwS+k0kLsqVTdFbAVNS0BsuOD76h1sW63/KRV3KACBpqNNrPvCfQtxwj39Y3Zibx78kBh7/LO73KqPAN2C9YHA4rOGIUgsUvSTgWHyA0Kjt/8BY+e4PDwY9FQckDTH2xFdF359+UkSxbRgvA69Lzo+Mpghps1lhQXrDm0aNWblksf+9XKrFUMnv/taJ4Hc+siVY05f/VvPDJv72uyL87H8VlTPHc5B4MpnVpGRlnq0ipIl1ZcFbiT70wO1L8R3kUq6WUw/c+/nkvf/6n5WHLsn2YoUfWx89Lmqf/rjo/8HTFiAIFI+SAjjYjMwIoadO8i0SlZ+++Q/Cew78u6X6HnLJl1OODN8x3rv20f7f+DciKDnitTotxh7/U7H28c/b5jaeTXLWKCTdnIJx5xKsG9SQ8riYIFh7AMSCZGf8o8Mvqrv3BeUdl1tPhkxO9aVDQj/6n0XlxCvEJnJ1apMmrZExh5opTEu7r6mXtm0fWmj4vP0AQiO977efnzx77uq+/3hARJs3W6CYA9A4c1pMfuXPrCsMPbNC3sVRrh5gqCZzonSRNWiHhp6b3/ql4J79v7BcX08u+4r9keH31P7m6S9M77lO9t3+66I8tB0PUu3EcVH94bOi/Fd/IXqOv0QmR3YvUAgYWZW5C4om9gA3NrzkUl255nV7DWs8u5xfU65IS4eR4cF0YuL79e8+dUntuhuE/ofvEOXNW4WasltlBS/+QPQ/+208il0HFF1cQJ1pDBcojomBKrCem275WnDPgZ9Zia8rV7Tnx8jwOxsvHHo8OXpE1nfsEunenxRi7YAQ4+eEPHNS9L5yWJRgRwJq1YjaxG3b2Inik5eypk3rVAogscApX70nKW3ffpVhjVdW6nvLtmgKMzL8ieq3/vpfwv4lqrdXNK68RuhySQRTk6J8+rgowUY3DJIwyJrACuoQ3K6eTwYGhy0YHM2tGBgYAKJgy5Duef11dxpgfGKlf4Nsp65B+oF7v1d7+jvX40Y3ZvJVpc8wrBYB7AULpiZr/FpkkhwsK8wsTuPhvK9KvkYlbw7ouK8IGPuYHFgnen7qxk/Jf/+hX2uXOZFt11bK6BOdJH9tgLJH0+5JMiQgsB6Rs4AkazEt8tt2o5QlEZnYkJb7fDltFQpgcLoicJ+3wn1zTYzxScMYd7QbC8p27jumHrj3a43nf3hremI0azifgcIFBzGLCxR7jT+RmEVk7aZpdx3CjZwLAc4WbW7DN9o21uk3Wuxxr2dtApiBw/zf8q5durTrirYwJR0JEIdV7khGj/+3xvOHAtz/RM5iXlzAECCawSFdEzQfc+Qcn+YNDloBY1YGoYYtsq9flK99/ZlwYODW5XZZuxcgjvkxfz/X+NEL70iOHpW8x5plFlEETgEYkojDeSw7AkLIFixSOC7ubUVdzlvszqXJ1Mzod9/TK8rXXBtH69f/igHFY53kfcmObW1pwfIn8bGjt8avvCyh5kS6rBHkQLDxk1yLSNfUzGZl3J0/3Q0NMu0hmjZechoOy1AE69aJ0lW7q2F//692Gii6AyAtIrRG3D6SHD82lLz6qlTVqpl3RcCQOVPwjkrzFa8F/eFoDwYOfFJkXPJNm3BLFcMSnzMP/dZy5Ek8QC6eYR40l9uSU6e2qrNjEnZ2hO0udJzY/dqkFnOjBBAgccWgLEXmUhZBf78IN2zU4aZNkwYY0Nf89zpBS3iAXDiAdpm/EL6GLjs7hN1ElAesBjtpLk+by1e6hQ0WMv6/AAMA0f6cCT1/KGUAAAAASUVORK5CYII=";
$Util._imgMaps = {};

$Util.registerImg = function(id,src,client){
	var image = new Image();
	image.src = src;
	image.client = {};
	if(client){
		for(var pro in client){
			image.client[pro] = client[pro];
		}
	}
	$Util._imgMaps[id] = image;
}

// $Util.canvas = document.createElement('canvas');
$Util.isDebug = function(){
    return $Util._debug;
}
$Util.checkNotNull = function(object,name) {
    if(object == null){
    	if(name){
    	  throw name + "can\'t be null";	
    	}else{
    		return false;
    	}
    }
    return true;
}

$Util.translateJson = function (json) {
    if (typeof json === 'string') {
        try {
            json = JSON.parse(json);
        } catch (e) {
        }

    }
    return json;
}

$Util.clone = function(obj) {
    var o;
    if (typeof obj == "object") {
        if (obj === null) {
            o = null;
        } else {
            if (obj instanceof Array) {
                o = [];
                for (var i = 0, len = obj.length; i < len; i++) {
                    o.push($Util.clone(obj[i]));
                }
            } else {
                o = {};
                for (var j in obj) {
                    if(typeof(o[j]) == 'function' || j == '_alarmState'){
                        continue;
                    }
                    o[j] = $Util.clone(obj[j]);
                }
            }
        }
    } else {
        o = obj;
    }
    return o;
};

$Util.getComputedStyle = function(element){
   return element.currentStyle? element.currentStyle : window.getComputedStyle(element, null);
};

$Util.updateEmptyBillboardContent = function (billboard, content, args) {

    var args = this.ext({
        contentX: 0,
        contentY: 0,
        contentWidth: billboard.args.width,
        contentHeight: billboard.args.height - billboard.args.arrowHeight
    }, args);
    args = this.ext(billboard.args, args);
    var bg = this.getBillboardContent(args);
    var ct = bg.getContext('2d');
    ct.drawImage(content, args.contentX, args.contentY, args.contentWidth, args.contentHeight);
    billboard.s({
        'm.texture.image': bg
    });
}

$Util.updateTextBillboardText = function (billboard, text, bgColor) {
    text = text || '';
    var content = it.Util.getTextBillboardContent(text, bgColor);
    this.updateTextBillboardContent(billboard, content)
}

$Util.updateTextBillboardContent = function (billboard, content) {

    billboard.s({
        'm.texture.image': content
    });
    billboard.contentWidth = content.width;
    billboard.contentHeight = content.height;
    billboard.setScale(content.width / 2, content.height / 2, 1);
}

$Util.updateTitleBillboardContent = function (billboard, content) {
    var width = billboard.contentWidth;
    var height = billboard.contentHeight;
    var title = billboard.title;
    var canvas = it.Util.getTitleBillboardContent(title, content, width, height, billboard.content);
    billboard.s({
        'm.texture.image': canvas
    });
}

$Util.createEmptyBillboardForNode = function (node, args) {
    var board = this.createEmptyBillboard(args)
    var bb = node.getBoundingBox();
    board.setParent(node);
    board.p(0, bb.max.y, 0);
    return board;
};

$Util.createEmptyBillboard = function (args) {
    args = it.Util.ext({
        width: 256,
        height: 128,
        radius: 16,
        arrowWidth: 16,
        arrowHeight: 16,
        bgColor: '#5B85B5',
    }, args);
    var c = this.getBillboardContent(args);
    var board = new mono.Billboard();
    board.s({
        'm.texture.image': c,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
    });
    board.args = args;
    board.setScale(args.width, args.height, 1);
    board.setSelectable(false);
    board.contentWidth = args.width;
    board.contentHeight = args.height;
    board.isEmptyBillboard = true;
    return board;
};

$Util.createTitleBillboardForNode = function (node, args) {
    var board = this.createTitleBillboard(args);
    var bb = node.getBoundingBox();
    board.setParent(node);
    board.p(0, bb.max.y, 0);
    return board;
};

$Util.getTitleBillboardContent = function (title, content, width, height, contentBackground) {

    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.save();
    context.drawImage(title, Math.max(0, (canvas.width - title.width) / 2), 0, title.width, title.height);
    context.translate(0, title.height);
    if (contentBackground) {
        context.drawImage(contentBackground, Math.max(0, (canvas.width - contentBackground.width) / 2), 0, contentBackground.width, contentBackground.height, 0, 0, width, height - title.height);
    }
    context.drawImage(content, Math.max(0, (canvas.width - content.width) / 2), 0, content.width, content.height, 0, 0, width, height);

    return canvas;
}

$Util.createTitleBillboard = function (args) {
    args = it.Util.ext({
        title: '',
        titleColor: '#FFFFFF',
        titleFont: '24px LEDFont,sans-serif',
        titleBgColor: '#4a74a4',
        titleWidth: 256,
        titleHeight: 32,
        titleRadius: 16,
        width: 256,
        height: 128,
        radius: 0,
        arrowWidth: 0,
        arrowHeight: 0,
        bgColor: '#5B85B5',
    }, args);
    var title = this.getBillboardTitle(args);
    var content = this.getBillboardContent(args);
    var width = Math.max(title.width, content.width);
    var height = title.height + content.height;
    var canvas = it.Util.getTitleBillboardContent(title, content, width, height);
    var board = new mono.Billboard();
    board.title = title;
    board.content = content;
    board.s({
        'm.texture.image': canvas,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
    });
    board.args = args;
    board.setScale(canvas.width, canvas.height, 1);
    board.setSelectable(false);
    board.contentWidth = width;
    board.contentHeight = height;
    board.isTitleBillboard = true;
    return board;
};

$Util.createTextBillboard = function (text, gbColor) { // headerChart
    var c = this.getTextBillboardContent(text, gbColor);
    var board = new mono.Billboard();
    board.s({
        'm.texture.image': c,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
        'm.texture.wrapS':TGL.ClampToEdgeWrapping,
        'm.texture.wrapT':TGL.ClampToEdgeWrapping
    });
    board.setScale(c.width/2, c.height/2, 1);
    board.setSelectable(false);
    board.contentWidth = c.width;
    board.contentHeight = c.height;
    board.isTextBillboard = true;
    return board;
};

$Util.createTextBillboardForNode = function (node, text, gbColor) {
    text = text || '';
    var board = this.createTextBillboard(text, gbColor);
    var bb = node.getBoundingBox();
    board.setParent(node);
    board.p(0, bb.max.y, 0);
    return board;
};

$Util.createSpecailTextBillboard = function (text, gbColor,isHumOrTemp,canvas) { // headerChart
    var c = null;
    if (isHumOrTemp) {
    	c = this.getHumOrTempCanvas(text, null, null, gbColor,canvas);
    }else{
    	c = this.getSpecialTextBillboard(text, null, null, gbColor,canvas);
    }
    var board = new mono.Billboard();
    board.s({
        'm.texture.image': c,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
    });
    board.setScale(c.width / 2, c.height / 2, 1);
    board.setSelectable(false);
    board.contentWidth = c.width;
    board.contentHeight = c.height;
    board.isTextBillboard = true;
    board.invalidateTexture();
    return board;
};

$Util.getImageById = function(id,value) {
	if (!id) {
		return this.dropImg;
	}
	if (this._imgMaps 
	    && this._imgMaps[id]) {
		return this._imgMaps[id];
	} else if (this[id]) {
		return this[id];
	} else {
		return this.dropImg;
	}
};

/**
 * /Canvas
 */
$Util.getHumOrTempCanvas = function(text, titleText, endText, bgcolor, canvas) {
	var image = this.getImageById(bgcolor,text);
	var canvas = canvas || document.createElement('canvas');
	if (!image) {
		return canvas;
	}
	if (!image.client) {
		image.client = {width:318,height:442,size:50,lineWidth:5,color:'#FFFFFF',startX:100,startY:300};
	};
	color = image.client['color']||'#888888';
	var width = image.width,
		height = image.height;
	var context = canvas.getContext('2d');
	width = image.client['width']||image.width * 2, height = image.client['height']||image.height * 2;
	canvas.height = height;
    canvas.width = width;
	context.drawImage(image, 0, 0, width, height);
	var x = parseInt(image.client['startX'])||(height - 50);
	var y = parseInt(image.client['startY'])||(height - 50);
	if (text) {
		var csize = parseInt(image.client['size'])||80;
		context.font = csize + 'px "Microsoft Yahei" ';
		context.strokeStyle = color;
		context.fillStyle = color;
		context.textAlign = 'left';
		context.textBaseline = 'middle';
		context.lineWidth = parseInt(image.client['lineWidth'])||8;	
		if (image.client['stroke']) {
			context.strokeText(text, x, y);
		}else{
			context.fillText(text, x, y);
		}
	}
	return canvas;
};

$Util.createHumOrTempCanvas = function(text,unit, bgcolor, canvas){
	var image = it.Util.getImageById(bgcolor, text);
        var canvas = canvas || document.createElement('canvas');
        if (!image) {
            return canvas;
        }
        if (!image.client) {
            image.client = {
                width: 256,
                height: 123,
                size: 50,
                lineWidth: 5,
                color: '#FFFFFF',
                startX: 20,
                startY: 60
            };
        };
        color = image.client['color'] || '#888888';
        var width = image.width,
            height = image.height;
        var context = canvas.getContext('2d');
        width = image.client['width'] || image.width * 2, height = image.client['height'] || image.height * 2;
        canvas.height = height;
        canvas.width = width;
        context.drawImage(image, 0, 0, width, height);
        var x = parseInt(image.client['startX']) || (height - 50);
        var y = parseInt(image.client['startY']) || (height - 50);
        if (text) {
            var csize = parseInt(image.client['size']) || 80;
            var fontFamily = image.client['fontFamily']||'"Microsoft Yahei"';
            // context.font = '80px DigifaceWide';            
            context.font = 'bold '+csize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth = parseInt(image.client['lineWidth']) || 8;
            if (image.client['stroke']) {
                context.strokeStyle = color;
                context.strokeText(text, x, y);
            } else {
                context.fillStyle = color;
                context.fillText(text, x, y);
            }
            if (image.client['withUnit'] && unit) {
                var width = context.measureText(text).width;
                var unitSize = parseInt(csize/2)||5;
                context.font = 'bold '+unitSize + 'px "Microsoft Yahei"';
                if (image.client['stroke']) {
                     context.strokeText(unit, x+width, y);
                }else{
                     context.fillText(unit, x+width, y);
                }
            }

        }
        return canvas;
};

/**
 * billboard
 */
$Util.getSpecialTextBillboard = function(text,titleText,endText,bgcolor,canvas){
    var canvas = canvas || document.createElement('canvas');
    var context = canvas.getContext('2d');
    var width,height;
    // if(isHumOrTemp){
    //   width  = 318;
    //   height = 442;
    // }else{
      width = 512;
      height = 256;
    // }
    var arrowHeight = height / 4;
    var arrowWidth = width / 4;
    canvas.height = height + arrowHeight;
    canvas.width = width;
    
    this.getBillboardContent({
        width: width,
        height: height + arrowHeight,
        radius: width / 16,
        arrowWidth: arrowWidth,
        arrowHeight: arrowHeight,
        bgColor: bgcolor,
        canvas: canvas,
        // isHumOrTemp:isHumOrTemp
    });
    /*
    if(isHumOrTemp){
        text = parseInt(text)+"";
        // text = text+"";
        height= height + arrowHeight;
        var color='#888888';
        var bgImage = this.dropImg;
        if (bgcolor 
        	&& this._imgMaps 
        	&& this._imgMaps[bgcolor]) {
        	color = '#FFFFFF';
            bgImage = this._imgMaps[bgcolor];
            // context.drawImage(this._imgMaps[bgcolor],30,10,288,432);
        }else if (bgcolor && this[bgcolor]) {
            color='#FFFFFF';
            bgImage = this[bgcolor];
        	// context.drawImage(this[bgcolor],30,10,288,432); 
        }else{
            color='#888888';
            bgImage = this.dropImg;
        	// context.drawImage(this.dropImg,30,10,288,432); 
        }
        width = bgImage.width*2,height = bgImage.height*2;
        context.drawImage(bgImage,30,10,width,height); 

        if(text){
            var csize = 80;
            context.font = csize+'px "Microsoft Yahei" ';
            context.strokeStyle=color;
            // context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth=8;
            if(text.length == 2){
                context.strokeText(text, 2*height/10-10, 2*height/3-50);
            }else if(text.length <2){
                context.strokeText(text, 2*height/10+10, 2*height/3-50);
            }else{
                context.strokeText(text, 2*height/10-30, 2*height/3-50);
            }
        }
        if(endText){
            var esize = 50;
            context.font = esize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            context.fillText(endText, width-height/10, height/2+50);
        }
    }else{
    	*/
        var color='white';
        if(titleText){
            var tsize = 50;
            context.font = tsize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(titleText, height/10, height/5);
        }
        if(text){
            var csize = 120;
            context.font = csize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(text, 2*height/10, 2*height/3);
            context.strokeStyle=color;
            context.lineWidth=4;
            context.strokeText(text, 2*height/10, 2*height/3);
        }
        if(endText){
            var esize = 60;
            context.font = esize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            context.fillText(endText, width-height/10, height/2+20);
        }
    // }
    return canvas;
};

$Util.getTextBillboardContent = function (label, bgcolor, args) {

    args = args || {};
    var canvas = document.createElement('canvas');
     var context = canvas.getContext('2d');
     context.font = "120px LEDFont,sans-serif";
     
     var array = [];
     if(label.indexOf("\n")){
         array= label.split("\n");
     }else{
         array= [label]
     }
     var length = 0;
     for(var i = 0;i < array.length;i ++){
        if(i == 0){
           length = context.measureText(array[i]).width;
        }else{
           length = Math.max(context.measureText(array[i]).width,length);
        }
    }

    var size = mono.Utils.getMaxTextSize(array, context.font);
    var c_width = mono.Utils.nextPowerOfTwo(length);
    var oHeight = size.height;
    var arrowHeight = oHeight / 4;
    var arrowWidth = c_width / 4;
    var c_height = mono.Utils.nextPowerOfTwo(oHeight + arrowHeight);
   
    canvas.height = c_height;
    canvas.width = c_width;
    var lineHeight = c_height / array.length;
    var oLineHeight = oHeight / array.length;

    args = it.Util.ext({
        labelColor: 'white',
        width: c_width,
        height: c_height,
        radius: (c_width / 16),
        arrowWidth: arrowWidth,
        arrowHeight: arrowHeight,
        bgColor: bgcolor,
        canvas: canvas
    }, args);
    this.getBillboardContent(args);

    context.fillStyle = args.labelColor;
    context.textBaseline = 'middle';
    context.font = "120px LEDFont,sans-serif";
    for (var i = 0; i < array.length; i++) {
        var text = array[i];
        length = context.measureText(text).width;
        context.fillText(text, (c_width - length) / 2, lineHeight * (i + 0.5));
    }
    return canvas;
};

/**
 * 
 * @param args
 * @returns {*}
 */
$Util.getBillboardTitle = function (args) {
    var width = args.titleWidth = mono.Utils.nextPowerOfTwo(args.titleWidth) || 192;
    var height = args.titleHeight = mono.Utils.nextPowerOfTwo(args.titleHeight) || 64;
    var radius = args.titleRadius || 8;

    var canvas = args.canvas;
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
    }
    var context = canvas.getContext('2d');
    context.globalAlpha = args.globalAlpha || 0.8;
    context.fillStyle = args.titleBgColor || '#5B85B5';
    context.font = args.titleFont || '120px LEDFont,sans-serif';
    var titleSizeWidth = args.titleSizeWidth = context.measureText(args.title).width;
    var titleSizeHeight = args.titleSizeHeight = mono.Utils.getMaxTextSize(args.title, args.titleFont);
    context.beginPath();
    context.moveTo(0, height);
    context.lineTo(0, radius);
    context.arcTo(0, 0, radius, 0, radius);
    context.lineTo(width - radius, 0);
    context.arcTo(width, 0, width, radius, radius);
    context.lineTo(width, height);
    context.closePath();
    context.fill();
    context.textBaseline = 'top';
    context.fillStyle = args.titleColor || '#A5855B';
    context.fillText(args.title, (width - titleSizeWidth) / 2, 2);
    context.restore();
    context.restore();
    return canvas;
}

/**
 * 
 * @param args
 * @returns {*}
 */
$Util.getBillboardContent = function (args) {

    args = it.Util.ext({width: 256, height: 128, radius: 20, arrowWidth: 50, arrowHeight: 30}, args);
    var width = args.width;
    var height = args.height;
    var radius = args.radius;
    var arrowWidth = args.arrowWidth;
    var arrowHeight = args.arrowHeight;

    var canvas = args.canvas;
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
    }
    if(!args.isHumOrTemp){
        var offset = 0;
        if(args.border){
            offset = args.borderWidth/2;
        }
        var context = canvas.getContext('2d');
        context.globalAlpha = args.globalAlpha || 0.8;
        context.fillStyle = args.bgColor || '#5B85B5';
        context.save();
        context.beginPath();
        context.moveTo(radius+offset, offset);
        context.lineTo(width - radius -offset, offset);
        context.arcTo(width-offset, offset, width-offset, radius+offset, radius);
        context.lineTo(width-offset, height - arrowHeight - radius-offset);
        context.arcTo(width-offset, height - arrowHeight-offset, width - radius-offset, height - arrowHeight-offset, radius);
        context.lineTo(width / 2 + arrowWidth / 2, height - arrowHeight-offset);
        context.lineTo(width / 2, height-offset);
        context.lineTo(width / 2 - arrowWidth / 2, height - arrowHeight-offset);
        context.lineTo(radius+offset, height - arrowHeight-offset);
        context.arcTo(offset, height - arrowHeight-offset, offset, height - arrowHeight - radius-offset, radius);
        context.lineTo(offset, radius+offset);
        context.arcTo(offset, offset, radius+offset, offset, radius);
        context.closePath();
        context.fill();
        if(args.border){
            context.strokeStyle = args.borderColor;
            context.lineWidth = args.borderWidth;
            context.stroke();
        }
        context.restore();
    }
    return canvas;
}

/**
 * nodeposition
 * @param node
 * @returns {position}
 */
$Util.getNodeCenterPosition = function (node) {
    if (!node) return null;
    var boundingBox = node.getBoundingBox();
    var offx = (boundingBox.max.x + boundingBox.min.x)/2*node.getScaleX();
    var offy = (boundingBox.max.y + boundingBox.min.y)/2*node.getScaleY();
    var offz = (boundingBox.max.z + boundingBox.min.z)/2*node.getScaleZ();
    var position = node.getWorldPosition();
    position.setX(position.x + offx);
    position.setY(position.y + offy);
    position.setZ(position.z + offz);
    return position;
};

$Util.formatDate = function (date, format) {
    if(!date || !format){
        return null;
    }
    var o = {
        'M+': date.getMonth() + 1,
        'd+': date.getDate(),
        'h+': date.getHours(),
        'm+': date.getMinutes(),
        's+': date.getSeconds(),
        'q+': Math.floor((date.getMonth() + 3) / 3),
        'S': date.getMilliseconds()
    };
    if (/(y+)/.test(format))
        format = format.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
    for (var k in o)
        if (new RegExp('(' + k + ')').test(format))
            format = format.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length)));
    return format;
};

$Util.formateDateTime = function(date) {
	if (!date) {
		return "";
	}
	if (typeof(date) == 'string') {
		var local = new Date(date);
		var utc = local.getTime() + local.getTimezoneOffset() * 60000;
		date = new Date(utc);
	}
	if (date instanceof Date) {
		return it.Util.formatDate(date, 'yyyy-MM-dd hh:mm:ss');
	} else {
		return date;
	}
};

/**
 * target, target
 * @returns {*|{}}
 */
$Util.ext = function () {
    /*
     *target
     *length
     *deep
     */
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // targetBooleantargetdeep
    // deeptrue
    // target
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};

        // i2
        i = 2;
    }

    // targettarget
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
        target = {};
    }

    // jQuerytargetjQuery
    if (length === i) {
        target = this;

        // i1
        --i;
    }

    // target

    for (; i < length; i++) {
        // ideeptarget
        if ((options = arguments[i]) != null) {
            // i
            for (name in options) {
                // src
                src = target[name];
                // 
                copy = options[name];

                // targetcopysrccopy
                if (target === copy) {
                    continue;
                }

                // 
                // copy
                if (deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) )) {
                    // 
                    if (copyIsArray) {
                        // copyIsArrayfalse
                        copyIsArray = false;
                        // src
                        clone = src && jQuery.isArray(src) ? src : [];
                    } else {
                        // src
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // extend
                    target[name] = jQuery.extend(deep, clone, copy);

                    // copyi
                } else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }

    // target{}
    return target;
};

$Util.jsonUtil = {
    object2String: function (obj) {
        try {
            var str = JSON.stringify(obj);
            return str;
        } catch (e) {
            if ($Util.isDebug()) {
                throw  e;
            } else {
                console.error('json', obj);
            }
        }
    },
    string2Object: function (str) {
        try {
            var obj = JSON.parse(str);
            return obj;
        } catch (e) {
            // if (Util.isDebug()) {
            //     throw  e;
            // } else {
                console.error('json', str);
            // }
        }
    }
};

$Util.o2s = function (o) {
    return $Util.jsonUtil.object2String(o);
}

$Util.s2o = function (s) {
    return $Util.jsonUtil.string2Object(s);
}

$Util.toJsonArray = function (json) {
    if (!json) {
        return [];
    }
    var jsonObject = json;
    if (typeof json === "string") {
        jsonObject = $Util.s2o(json);
    }
    var jsonObjects;
    if (jsonObject instanceof Array) {
        jsonObjects = jsonObject;
    } else {
        jsonObjects = [jsonObject];
    }
    return jsonObjects;
}

$Util.findFirstObjectByMouse = function (network, e, filter) {
    if (!filter) {
        filter = function (object3d) {
            return !(object3d instanceof mono.Billboard);
        }
    }
    var objects = network.getElementsByMouseEvent(e);
    if (objects.length) {
        for(var i=0;i<objects.length;i++){
            var first = objects[i];
            var object3d = first.element;
            if(filter(object3d)){
                return first;
            }
        }
    }
    return null;
};

$Util.compare = function(a, b) {
	if (a == b) {
		return 0;
	}

	if (a.length == 0) {
		return 1;
	}
	if (b.length == 0) {
		return -1;
	}
	if (a > b) {
		return 1;
	} else if (b > a) {
		return -1;
	} else {
		return 0;
	}

};

$Util.getEstimateOverviewPositionAndTarget = function(network,angle){
	if (!network) { 
		return null;
	}
	var camera = network.getCamera();
	var bb = network.getNetworkBoundingBox();
     if(bb == null){
        return null;
      }
      var center = bb.center();
      var sub1 = new mono.Vec3(0,bb.max.y - bb.min.y,bb.max.z - bb.min.z);
      var sub2 = new mono.Vec3(bb.max.x - bb.min.x,0,0,0);
      var sub = sub1.clone();
      if(sub.length() < sub2.length()){
          sub = sub2.clone();
      }
      var position;
      if(angle){
        var l = sub1.length();
        sub1.y = sub1.z * Math.tan(angle / 180 * Math.PI);
        sub1.setLength(l);
      }
      position = new mono.Vec3().addVectors(center,sub1.multiplyScalar(0.5));
        var fov = camera.fov,aspect = camera.aspect;
        var length = sub.length() / 2 / Math.tan(fov * Math.PI/180);
        position.add(sub1.normalize().multiplyScalar(length));
      // this._camera.setPosition(position);
      // this._camera.lookAt(center);
      return {target:center,position:position};
      // this._overviewDistance = this._camera.getDistance();
};

/**
 * boudingBox
 * boundingBoxcloneboundingBox
 * @includeChildren boundingBox
 */
$Util.getBoundingBox = function(node,includeChildren) {
	if (!node) {
		return null;
	}
	if (node instanceof mono.Billboard) {
		return null;
	}
	var box = node.getBoundingBox?node.getBoundingBox():null;
	if (!includeChildren 
		&& box
		&& box.size().x 
		&& box.size().x != -Infinity
		&& box.size().x != Infinity) {
		return box;
	}
	var vertices = [];
	var cNode = node.clonePrefab();
	cNode.setPosition(0,0,0);
	$Util.getTransformVertices(cNode, vertices);
	box = new mono.BoundingBox();
	box.setFromPoints(vertices); //0boundingBoxY 
	return box;
};

$Util.getTransformVertices = function(node, vertices) {
    if (vertices == null) {
        vertices = [];
    }
    var i, vertex;
    if ( node instanceof TGL.Node || node instanceof TGL.Billboard) {
        for ( i = 0; i < node.vertices.length; i++) {
            vertex = node.vertices[i].clone();
            if ( node instanceof TGL.Billboard) {
                vertex.x *= node.rotation3d.x;
                vertex.y *= node.rotation3d.y;
                vertex.add(node.getPosition());
            } else {
                vertex.applyMatrix4(node.worldMatrix);
            }
            vertices.push(vertex);
        }
        for (var i = 0; i < (node._childList ? node._childList.size() : 0); i++) {
            var child = node._childList.get(i);
            if (child.getClient('it_data_id') == node.getClient('it_data_id') 
            	&& node.getClient('type') != 'parkSkybox'//
            	) { 
            	$Util.getTransformVertices(child, vertices);
            }
        }
    }
    return vertices;
};

/**
 * 
 * @method playCameraAnimation
 * @static
 * @param  {mono.Camera}   camera   
 * @param  {mono.Vec3}   [pos=null]      
 * @param  {mono.Vec3}   [target=null]   
 * @param  {Number}   [time=2000]     2000ms
 * @param  {Function} callback 
 * cameratargetpostargetlookAttarget
 * play
 *       1cameratargettarget,distance(cameradistance)
 *       2Camera()pos
 *       3
 * 123
 */
$Util.playCameraAnimation = function(camera, pos, target, time, callback) {
  if($Util.activeAnimates && $Util.activeAnimates instanceof Array){ //animate
    for(var a = 0 ; a < $Util.activeAnimates.length ; a++){
      $Util.activeAnimates[a].stop();
    }
  }
    pos = pos || camera.p();
    target = target || camera.getTarget();
    if(pos.equals(camera.getPosition()) 
       && target.equals(camera.target)){ //
        callback&&callback();
      return null;
    }
    var offset=camera.getPosition().sub(camera.getTarget());
    var t_position=new mono.Vec3().addVectors(offset, target);
    time = time || 3000;
    // time = 3000;

    var angles = mono.Utils.getVectorAngles(target, t_position);//camera.getTarget(), camera.p()
    var angles2 = mono.Utils.getVectorAngles(target, pos);
    var dha = angles2[0] - angles[0];
    if (dha > 180) {
        dha = dha - 360;
    } else if (dha < -180) {
        dha = dha + 360;
    }
    var dva = angles2[1] - angles[1];
    if (dva > 180) {
        dva = dva - 360;
    } else if (dva < -180) {
        dva = dva + 360;
    }

    var t1 = camera.getTarget();
    var t2 = target;
    var d1 = camera.getDistance(),d2 = new mono.Vec3().subVectors(pos, target).length();
    var ang00 = angles[0],ang01 = angles[1],ang10 = angles2[0],ang11 = angles2[1];

    var animate2 = new mono.Animate({
      from:0,
      to:1,
      repeat:1,
      dur:time/3,
      onPlay : function(){
        this.isPlaying = true;
      },
      onUpdate : function(value){ // 2x,y,zdistance
            var hAngle = ang10; // 
            // var vAngle = ang01 + dva * value;
            // var vAngle = ang01>ang11?(ang01 + dva * value):(ang01 + dva );
            var vAngle = ang01>ang11?(ang01 + dva * value):ang11;//:ang10(ang10180);
            // var vAngle = ang01>ang11?ang01:ang11;
            var t = t2;//new mono.Vec3().lerpVectors(t1, t2, value);
            var d = d1 + (d2 - d1) * value;
            // update 2017-09-14 Kevin animate0animate2 //2017-8-31
            // var d = d1 > d2 ? d1 : d2; 
            if(d2 > d1 && dha == 0 && ang11 < ang01){ // animate1animate0animate2,d2d2
              // d = (d1 + (d2 - d1) * value); 
               d = d2; 
            }
            var newPos = new mono.Vec3();
            newPos.x = t.x + d * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
            newPos.z = t.z + d * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
            newPos.y = t.y + d * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
            camera.p(newPos);
            camera.lookAt(t);
      },
      onDone : function() {
            if (callback)
                callback();
      },
      onStop : function(){
            // delete this.isPlaying;
      }
    });

    var animate1 = new mono.Animate({ // 1xzdistance
      from: 0,
      to: 1,
      repeat: 1,
      dur: time / 3,
      onPlay: function() {
        // console.log('onplay 1');
        this.isPlaying = true;
      },
      onUpdate: function(value) {
        var hAngle = ang00 + dha * value; // 
        // var vAngle = ang01>ang11?ang01:(ang01 + dva * value);//  ()
        var vAngle = ang01 > ang11 ? ang01 : ang11;
        var t = t2; //new mono.Vec3().lerpVectors(t1, t2, value); //

        // add by Kevin 2017-06-05 animate2(ang11 >= ang01)d1(distance)
        var d = d1 > d2 ? d1 : d2; //(d1+(d2-d1)*value); // camera
        // if(ang11 >= ang01){
            // var d = d2;
        // }
        if(d1 > d2 && ang11 >= ang01){ // update 2017-08-31 Kevin d1<d2 && ang11 >= ang01
            d = (d1 + (d2 - d1) * value); 
        }

        var newPos = new mono.Vec3();
        newPos.x = t.x + d * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.z = t.z + d * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.y = t.y + d * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        camera.p(newPos);
        camera.lookAt(t);
      },
      onDone: function() {
        //     if (callback)
        //         callback();
        d1 = camera.getDistance(); // 
        t1 = camera.getTarget();
      },
      onStop: function() {
        // console.log('stop1');
        if (this.isPlaying) {  // add by Kevin 2017-06-01 callbackplayCameraanimatestop
          delete this.isPlaying;

          if (ang11 >= ang01) {
            callback && callback();
          } else {
            animate2.play();
          }
        }
      }
    });

    // Camerapostarget
    //postarget(Camera)tarpostarpostargettarget
    var animate0 = new mono.Animate({ // targettargettarget
      from: 0,
      to: 1,
      dur: time / 3,
      onPlay: function() {
        this.isPlaying = true;
      },
      onUpdate: function(value) {
        var hAngle = ang00; // 
        // var vAngle = ang01;//  ()
        var vAngle = ang01 > ang11 ? ang01 : (ang01 + dva * value); //  ()
        var t = new mono.Vec3().lerpVectors(t1, t2, value); //
        // camera
        // add by Kevin 2017-06-05 (aminate2,hAngle0): (d1 + (d2 - d1) * value)
        // var d = d1 > d2 ? d1 : (d1 + (d2 - d1) * value); // camera
        var d = (d1 + (d2 - d1) * value); 
        if(d1 > d2 && (dha != 0 || ang11 < ang01)){
            d = d1; 
        }
        var newPos = new mono.Vec3();
        newPos.x = t.x + d * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.z = t.z + d * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.y = t.y + d * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        camera.p(newPos);
        camera.lookAt(t);
      },
      onDone: function() {

      },
	onStop: function() { // stop onDone
		// console.log('stop0');
		if (this.isPlaying) {
			delete this.isPlaying;
			if (dha == 0 && ang11 >= ang01) { // 0  ang11 >= ang01 
				callback && callback();
			} else if (dha != 0) { //
				setTimeout(function() {
					animate1.play();
				}, 0); // onStop  
			} else { // 
				setTimeout(function() {
					animate2.play();
				}, 0); // onStop  
			}
		}
	}
 });

    // 
    // animate0.chain(animate1);
    // animate1.chain(animate2);
    if(dha == 0 && ang11 >= ang01){ //
        animate0.dur = time;
        animate0.finish = time;
    }else if (dha == 0){
        animate2.dur = time*2/3; //1/3,2/3
        animate2.finish = time*2/3; 
    }else if (ang11 < ang01) { // else if (ang11 >= ang01) { update 2017-08-09
        animate1.dur = time*2/3; //1/3,2/3
        animate1.finish = time*2/3; 
    }
    animate0.play();
    $Util.activeAnimates = [animate0,animate1,animate2];
    return [animate0,animate1,animate2];
};

$Util.getZoomEstimateOverviewTargetAndPosition = function(network, angle) {
	if (!network) {
		return;
	}
	var bb = network.getNetworkBoundingBox();
	if (bb == null) {
		return;
	}
	var center = bb.center();
	var sub1 = new $Vec3(0, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
	var sub2 = new $Vec3(bb.max.x - bb.min.x, 0, 0, 0);
	var sub = sub1.clone();
	if (sub.length() < sub2.length()) {
		sub = sub2.clone();
	}
	var position;
	if (angle) {
		var l = sub1.length();
		sub1.y = sub1.z * Math.tan(angle / 180 * Math.PI);
		sub1.setLength(l);
	}
	position = new $Vec3().addVectors(center, sub1.multiplyScalar(0.5));
	var fov = network._camera.fov,
		aspect = network._camera.aspect;
	var length = sub.length() / 2 / Math.tan(fov * Math.PI / 180);
	position.add(sub1.normalize().multiplyScalar(length));
	// network._camera.setPosition(position);
	// network._camera.lookAt(center);
	return {
		target: center,
		position: position
	};
	// this._overviewDistance = this._camera.getDistance();
};

var jsonUtil = window.jsonUtil = $Util.jsonUtil;


    

var $Base = function(){
	mono.PropertyChangeDispatcher.call(this);
};
it.Base = $Base;

mono.extend($Base,mono.PropertyChangeDispatcher,{
   onPropertyChange : function (property, oldValue, newValue) {
   }
});
/**
 * 
 */

var $Category = function (parameters) {
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._id = parameters.id;
    this._description = parameters.description;
    this._selectable = true; // 
    this._stopAlarmPropagationable = false; // 
    this._lazyLoad = false;  // 
    this._lazyLoadScene = ""; //  
    this._rotationExp = {}; // {y : "x % 2 ? Math.IP : 0"};
    this._positionExp = {}; // 
    this._visible = parameters.visible == undefined ? true : parameters.visible; //it.Data
    this._userDataMap = {}; //
    this.handleDoubleClick = null;
    this.handleClick = null;
};

it.Category = $Category;

mono.extend($Category, $Base, {
    ___accessor: ['description', 'stopAlarmPropagationable'],
    getId: function () {
        return this._id;
    },

    setId: function (id) {
        if (this._id === undefined) {
            this._id = id;
        } else {
            throw 'Can not set id';
        }
    },

    setVisible: function (visible) {
        this._visible = visible;
    },

    isVisible: function () {
        return this._visible;
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },

    getUserData: function (key) {
        return this._userDataMap[key];
    },

    fromJson: function (json) {

        if (json.selectable == undefined) {
            json.selectable == true;
        }
        this._id = json.id;
        this._description = json.description;
        this._visible = json.visible;
        this._selectable = json.selectable; // 
        this._stopAlarmPropagationable = json.stopAlarmPropagationable; // 
        this._lazyLoad = json.lazyLoad;  // 
        this._lazyLoadScene = json.lazyLoadScene || ''; //  
        this._rotationExp = json.rotationExp || {}; // {y : "x % 2 ? Math.IP : 0"};
        this._positionExp = json.positionExp || {}; //
    },
});
var $Data = function (parameters) {
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._ii = parameters.ii;
    this._id = parameters.id;
    this._description = parameters.description;
    this._position = parameters.position || new mono.Vec3; // jsonmono.Vec3
    this._position2d = parameters.position2d || new mono.Vec2;
    this._rotation = parameters.rotation; // || new mono.Vec3; express
    this._location = null; //LocationManagerit.Location;
    this._userDataMap = {}; //AssetInfouserDataMap 
    this._parentId = parameters.parentId;//
    this._hostId = ""; //
    this._dataTypeId = parameters.dataTypeId;//
    this._businessTypeId = parameters.businessTypeId; //
    // this._parent = null;
    this._childList = new mono.List();
    this._alarmState = new it.AlarmState(this);
    this._powerParentId = ""; // 
    this._allLinks = {};
    this._power = "";
    this._weight = 0;//
};

it.Data = $Data;

mono.extend($Data, $Base, {
    ___accessor: ['ii','rotation', 'parentId', 'hostId', "dataTypeId","businessTypeId", "alarmState", "description", "power", 'weight',"name","extend"],
    IT_Data: true,
    getId: function () {
        return this._id;
    },

    getLocation: function () {
        return this._location;
    },

    setLocation: function (object) {
        if (object) {
            var l = new it.Location(object);
            if (this._location) {
                if (l.x == this._location.x && l.y == this._location.y && l.z == this._location.z) {
                    return;
                }
            }
            var oldValue = this._location;
            this._location = l;
            this.firePropertyChange("location", oldValue, l);
        }
    },

    setPosition: function (x, y, z) {
        var p;
        if (arguments.length === 3) {
            p = new mono.Vec3(x, y, z);
        } else if (arguments.length === 1) {
            if (mono.Utils.isArray(x)) {
                p = new mono.Vec3(x[0], x[1], x[2]);
            } else {
                p = new mono.Vec3(x.x || 0, x.y || 0, x.z || 0);
            }
        }
        if (this._position) {
            if (p.x == this._position.x && p.y == this._position.y && p.z == this._position.z) {
                return;
            }
        }
        var oldValue = this._position;
        this._position = p;
        this.firePropertyChange("position", oldValue, p);
    },

    setPosition2d: function (x, y) {
        this._position2d = new mono.Vec2(x, y);
    },

    getValue: function (name) {
        if (!name) {
            return null;
        }
        if (this["_" + name]) {
            return this["_" + name];
        } else {
            return this.getUserData(name);
        }

    },

    getPosition: function () {
        return this._position || new mono.Vec3;
    },

    getPosition2d: function () {
        return this._position2d || new mono.Vec2;
    },

    u: function (userData) {
        if (!userData) {
            return;
        }
        for (var p in userData) {
            this.setUserData(p, userData[p]);
        }
    },

    addLink: function (link) {
        if (link && (link instanceof it.Link)
            && link.getId()
            && !this._allLinks[link.getId()]) {
            this._allLinks[link.getId()] = link;
        }
    },

    removeLink: function (link) {
        if (link && link.getId()) {
            delete this._allLinks[link.getId()];
        }
    },

    getAllLinks: function () {
        return this._allLinks;
    },

    getPosition2d: function () {
        return this._position2d;
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },
    
    getUserData: function (key) {
        return this._userDataMap[key];
    },

    fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._ii = json.ii;
        this._id = json.id;
        this._description = json.description;
        if (json.position && (json.position.x !== undefined || json.position.y !== undefined || json.position.z !== undefined)) {
            this._position = new mono.Vec3(json.position.x || 0, json.position.y || 0, json.position.z || 0);
        } else if (mono.Utils.isArray(json.position)) {
            this._position = new mono.Vec3(json.position[0] || 0, json.position[1] || 0, json.position[2] || 0);
        }
        if (json.position2d && (json.position2d.x !== undefined || json.position2d.y !== undefined)) {
            this._position2d = new mono.Vec2(json.position2d.x || 0, json.position2d.y || 0);
        } else if (mono.Utils.isArray(json.position2d)) {
            this._position2d = new mono.Vec2(json.position2d[0] || 0, json.position2d[1] || 0);
        }
        if (json.rotation && ((json.rotation.x !== undefined && json.rotation.x != '')
            || (json.rotation.y !== undefined && json.rotation.y != '')
            || (json.rotation.z !== undefined && json.rotation.z != ''))) {
            this._rotation = new mono.Vec3(json.rotation.x, json.rotation.y, json.rotation.z);
        } else if (mono.Utils.isArray(json.rotation)) {
            this._rotation = new mono.Vec3(json.rotation[0] || 0, json.rotation[1] || 0, json.rotation[2] || 0);
        }
        this.setLocation(json.location);
        this._parentId = json.parentId;
        this._dataTypeId = json.dataTypeId;
        this._businessTypeId = json.businessTypeId;
        this._hostId = json.hostId || json.groupId;
        this._power = json.power;
        this._weight = json.weight;
        this._name = json.name;
        this._extend = json.extend;
    },

    onAlarmChange: function () {

    },

    addChild: function (data) {
        if (data && !this._childList.contains(data)) {
            this._childList.add(data);//list
        }
    },

    addChildren: function (datas) {
        if (!datas || datas.length < 1) {
            return;
        }
        for (var i = 0; i < datas.length; i++) {
            var data = datas[i];
            this.addChild(data);
        }
    },

    removeChild: function (data) {
        this._childList.remove(data);
    },

    removeChildren: function (datas) {
        if (!datas || datas.length < 1) {
            return;
        }
        for (var i = 0; i < datas.length; i++) {
            var data = datas[i];
            this.removeChild(data);
        }
    },

    getChildren: function () {
        return this._childList;
    },

    clone: function (id, cloneParentId) {
        var cloneData = new $Data(id);
        cloneData.setDataTypeId(this.getDataTypeId());
        var pos = this.getPosition(), loc = this.getLocation();
        cloneData.setPosition(pos.clone());
        if (loc) {
            cloneData.setLocation(new $Location(loc.x, loc.y, loc.z));
        }
        if (cloneParentId) {
            cloneData.setParentId(this.getParentId());
        }
        return cloneData;
    }
});
var $DataType = function (parameters) {
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._id = parameters.id;
    this._categoryId = "";
    this._description = "";
    this._size = null;    //    it.Size 
    this._childrenSize = new it.Size(); // it.Size


    this._model2d = "";
    this._model2dParameters = null;
    this._model2d2 = "";
    this._model2d2Parameters = null;

    this._parameters = null;
    this._model = ""; // Link to modellib.js
    this._modelParameters = null;
    this._simpleModel = ""; //  LOD
    this._simpleModelParameters = null;

    this._prefabAble = parameters.prefabAble == undefined ? true : parameters.prefabAble;
    this._simplePrefabAble = parameters.simplePrefabAble == undefined ? true : parameters.simplePrefabAble;
    // this.lod = "";
    this._selectable = true; // 
    this._stopAlarmPropagationable = false; // 
    this._batchable = false; //BatchManager
    this._lazyable = false;  // 
    // this._lazyLoadScene = ""; //  
    this.handleDoubleClick = null; // for user use;
    this.handleClick = null;  // for user use;

    this._rotationExp = {}; // {y : "x % 2 ? Math.IP : 0"};
    this._positionExp = {}; //

    this._visible = true;
    this._weightRating = 0;//
    this._powerRating = 0; // 
    this._subType = 'server'; // ,server-  network-

    //_templateDatasit.DataData
    this._templateDatas = parameters.templateDatas || []; // port001@card001

    this._templateDataMap = {};
    this._userDataMap = {}; //
};


mono.extend($DataType, $Base, {
    ___accessor: ['categoryId', 'description', 'rotationExp', 'positionExp', 'size', 'childrenSize', 'parameters', 'model2d', 'model2dParameters','model2d2', 'model2d2Parameters',
        'model', 'modelParameters', 'simpleModel', 'simpleModelParameters', 'batchable', 'lazyable', 'selectable', 'stopAlarmPropagationable', 'prefabAble', 'noVirtualOther', 'simplePrefabAble',
        'weightRating', 'weight', 'powerRating', 'power', 'subType'],
    getId: function () {
        return this._id;
    },

    setId: function (id) {
        if (this._id === undefined) {
            this._id = id;
        } else {
            throw 'Can\'t change id';
        }
    },

    getTemplateDatas: function (side) {
        side = side || false;
        var result = [];
        for(var id in this._templateDataMap){
            if(id.indexOf('@'+side)>0){
                result.push(this._templateDataMap[id]);
            }
        }
        return result;
    },

    setTemplateDatas: function (templateDatas) {
        this._templateDatas.length = 0;
        var self = this;
        if (templateDatas && templateDatas.length > 0) {
            templateDatas.forEach(function (templateData) {
                self.addTemplateData(templateData);
            });
        }
    },

    addTemplateData: function (data) {
        if (data instanceof it.Data) {
            this._templateDatas.push(data);
            this._templateDataMap[data.getId() + '@' + data.getUserData('side')] = data;
        } else {
            var itData = new it.Data();
            itData.setUserData('side', data.side);
            itData.fromJson(data);
            this._templateDatas.push(itData);
            this._templateDataMap[itData.getId() + '@' + itData.getUserData('side')] = itData;
        }
    },

    getTemplateDataById: function (id) {
        return this._templateDataMap[id];
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },
    
    getUserData: function (key) {
        return this._userDataMap[key];
    },

    fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._categoryId = json.categoryId;
        this._description = json.description;
        this._size = new $Size(json.size)
        this._childrenSize = new $Size(json.childrenSize);
        this._model2d = json.model2d;
        this._model2dParameters = $Util.translateJson(json.model2dParameters);
        this._model2d2 = json.model2d2;
        this._model2d2Parameters = $Util.translateJson(json.model2d2Parameters);
        this._model = json.model;
        this._modelParameters = $Util.translateJson(json.modelParameters);
        this._simpleModel = json.simpleModel;
        this._simpleModelParameters = json.simpleModelParameters;
        this._selectable = json.selectable === undefined ? true : json.selectable;
        this._stopAlarmPropagationable = !!json.stopAlarmPropagationable;
        this._batchable = !!json.batchable;
        this._prefabAble = !!json.prefabAble;
        this._simplePrefabAble = !!json.simplePrefabAble;
        this._noVirtualOther = !!json.noVirtualOther;
        this._rotationExp = json.rotationExp || {};
        this._positionExp = json.positionExp || {};
        this._lazyable = json.lazyable;
        this._weightRating = json.weightRating;
        this._weight = json.weight;
        this._powerRating = json.powerRating;
        this._power = json.power;
        this._subType = json.subType;
    },
});

it.DataType = $DataType;

var $BusinessType = function(parameters){
	$Base.call(this);
	parameters = parameters || {};
	this._id = parameters.id || "";
	this._parentId = parameters.parentId || "";
	this._name = parameters.name || "";
	this._description = parameters.description;
	this._userDataMap = {};
};

mono.extend($BusinessType,$Base,{
	 
	___accessor: ['id', 'name', 'parentId', 'description'],

	fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._parentId = json.parentId;
	    this._name = json.name;
        this._description = json.description;
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },
    
    getUserData: function (key) {
        return this._userDataMap[key];
    }

});

it.BusinessType = $BusinessType;
/*
 * terry  Model View Control MVC
 */
var $DataManager = function(){
   this.defaultCategory = new it.Category(""); // 
   this._categories = [];
   this._categoryMap = {};
   this._dataTypes = [];
   this._dataTypeMap = {};
   this._businessTypes = [];
   this._businessTypeMap = {};
   this._datas = [];
   this._dataMap = {};
   this._roots = []; // Data
   this._rootMap = {}; 

   this._links = [];
   this._linkMap = {};

   this._dataTypeDatas = {}; // Data
   this._categoryDatas = {}; //  Data

   this._scenes = [];
   this._sceneMap = {};
   this._rootScene = null;
   this._categorySceneMap = {};
    this._temperatureFields = {}; //
    this._collectors = {}; //
    this._typeCollectors = {}; //collector()
   
   // 
   this._dataManagerChangeDispatcher = new mono.EventDispatcher();
   this._dataPropertyChangeDispatcher = new mono.EventDispatcher();

   // ,
   // this.viewLoader = null; 
   // 
   // this.locationManager = null;
};

mono.extend($DataManager,mono.PropertyChangeDispatcher,{
    
    addScene : function(scene){
       if(!(scene instanceof it.Scene)){
          return false;
       }
       var id = scene.getId();
       if(this._sceneMap[id]){
           throw "Scene with id '" + id + "' already exists";
       }
       var categoryId = scene.getCategoryId();
       if(!this._categoryMap[categoryId] && !scene.isRoot()){
          throw "Scene Category with category id '" + categoryId + "' does not exist";
       }
       if(this._categorySceneMap[categoryId]){
          throw "Scene with category id '" + categoryId + "' already exists";
       }
       if(scene.isRoot()){
          if(this._rootScene != null){
            throw "Only support one root scene";
          }
          this._rootScene = scene;
       }
       this._scenes.push(scene);
       this._sceneMap[id] = scene;
       this._categorySceneMap[categoryId] = scene;
    },

    addSceneFromJson : function(scenes){
        var i = 0,len = scenes.length;
        for(;i < len;i ++){
            var scene = new it.Scene();
            scene.fromJson(scenes[i]);
            this.addScene(scene);
        }
    },

    getSceneByCategory : function(categoryOrId){
       if(!categoryOrId){
        return null;
       }
       var categoryId = categoryOrId.getId ? categoryOrId.getId() : categoryOrId;
       return this._categorySceneMap[categoryId];
    },

    getSceneByData : function(dataOrId){
      var category = this.getCategoryForData(dataOrId)
      return this.getSceneByCategory(category);
    },

    getRootScene : function(){
      return this._rootScene;
    },

    getChildrenScene : function(scene){
       
    },

    addCategory : function(category){
       var id = category.getId();
        if(!(category instanceof it.Category)){
        	throw "Can only add it.Category";
        }
        if(this._categoryMap[id]){
       	  throw "Category for id '" +id+"' already exists";
        }
        this._categories.push(category);
        this._categoryMap[id] = category;
    },

    removeCategory : function(category){
        if(!category){
          return false;
        }
        var id = category.getId();
        if(!this._categoryMap[id]){
           return false;
        }
        var index = this._categories.indexOf(category);
        if(index == -1){
        	return false;
        }
       	delete this._categoryMap[id];
       	this._categories.splice(index,1);
       	return true;
    },

    removeCategoryById : function(id){
       var category = this._categoryMap[id];
       if(category){
       	  this.removeCategory(category);
       }
    },

    addCategories : function(categories){
    	if(mono.Utils.isArray(categories)){
    		for(var i = 0;i < categories.length;i ++){
    			var category = categories[i];
    			this.addCategory(category);
    		}
    	}
    },
    
    // TODO
    addCategoryFromJson : function(json){
        var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       var i = 0,len = jsonObjects.length;
       for(;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var category = new it.Category();
          category.fromJson(jsonObject);
          this.addCategory(category);
       }
    },

    addDataType : function(dataType){
      if(!dataType){
      	return;
      }
      if(!(dataType instanceof it.DataType)){
      	throw "Can only add 'it.DataType'";
      }
      var id = dataType.getId();
      if(this._dataTypeMap[id]){
          throw "DataType for id '" +id+ "' already exists";
      }
      var categoryId = dataType.getCategoryId();
      if(categoryId && !this._categoryMap[categoryId]){
         throw "Category for '" + categoryId + "' does not exist";
      }
      this._dataTypes.push(dataType);
      this._dataTypeMap[id] = dataType;
    },


    addBusinessType : function(businessType){
       if (!businessType) {
          return;
       }
       var id = businessType.getId();
        if(!(businessType instanceof it.BusinessType)){
          throw "Can only add it.BusinessType";
        }
        if(this._businessTypeMap[id]){
          throw "BusinessType for id '" +id+"' already exists";
        }
        this._businessTypes.push(businessType);
        this._businessTypeMap[id] = businessType;
    },

    removeBusinessType : function(businessType){
        if(!businessType){
           return false;
        }
        var id = businessType.getId();
        if(!this._businessTypeMap[id]){
           return false;
        }
        var index = this._businessTypes.indexOf(businessType);
        if(index == -1){
           return false;
        }
        delete this._businessTypeMap[id];
        this._businessTypes.splice(index,1);
        return true;
    },

    removeBusinessTypeById : function(id){
       var businessType = this._businessTypeMap[id];
       if(businessType){
          this.removeBusinessType(businessType);
       }
    },

    addBusinessTypes : function(businessTypes){
      if(mono.Utils.isArray(businessTypes)){
        for(var i = 0; i < businessTypes.length; i ++){
          var businessType = businessTypes[i];
          this.addBusinessType(businessType);
        }
      }
    },

    addBusinessTypeFromJson : function(json){
        var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       var i = 0,len = jsonObjects.length;
       for(;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var businessType = new it.BusinessType();
          businessType.fromJson(jsonObject);
          this.addBusinessType(businessType);
       }
    },

    getBusinessTypeById : function(id){
        return this._businessTypeMap[id];
    },

    getBusinessTypeForData :function(data){
        var bid = data.getBusinessTypeId();
        if (bid) {
           return this.getBusinessTypeById(bid);
        }else{
          return null;
        }
    },

    /**
     * templatedatajsonDataType
     * @param jsonObj
     * @returns {boolean}
     */
    addTemplateData : function(jsonObj){
        var dataTypeId  = jsonObj.parentDataTypeId||'';
        if(!dataTypeId){
            return false ;
        }
        var dataType = this._dataTypeMap[dataTypeId];
        if(!dataType){
            return false;
        }
        var data = new it.Data();
        //template_datapositiondataposition2d
        if(jsonObj.position){
            var pos3d = jsonObj.position;
            if(pos3d instanceof Array && pos3d.length >= 2){
                jsonObj.position2d = {x:pos3d[0],y:pos3d[1]};
            }else{
                jsonObj.position2d = pos3d;
            }
            //else if(pos3d instanceof Array && pos3d.length == 2){
            //    jsonObj.position2d = {x:pos3d[0],y:pos3d[1]};
            //}
        }
//        delete  jsonObj.position; // 
        data.fromJson(jsonObj);
        data.setUserData('side', jsonObj.side);
        dataType.addTemplateData(data);
    },

    /**
     * jsontemplatedatas,datatype
     * @param json
     */
    addTemplateDataFromJson : function(json){
        var jsonObjects = json;
        if(typeof json === "string"){
            jsonObjects = JSON.parse(json);
        }
        var i = 0,len = jsonObjects.length;
        for(;i < len;i ++){
            var jsonObject = jsonObjects[i];
            this.addTemplateData(jsonObject);
        }
    },

    removeDataType : function(dataType){
       if(!dataType){
          return false;
       }
       var id = dataType.getId();
       if(!this._dataTypeMap[id]){
           return false;
       }
       var index = this._dataTypes.indexOf(dataType);
       if(index === -1){
       	 return false;
       }
       if(this._dataTypeDatas[id]){ // 
       	  return false;
       }
       delete this._dataTypeMap[id];
       this._dataTypes.splice(index,1);
    },

    removeDataTypeById : function(id){
       this.removeDataType[this._dataTypeMap[id]];
    },

    getCategoryForDataType : function(dateTypeOrId){
        var dataType = dateTypeOrId;
        if(typeof dateTypeOrId === 'string'){
          dataType = this._dataTypeMap[dateTypeOrId];
        }
        if(!dataType){
            return null;
        }
        var categoryId = dataType.getCategoryId();
        return this._categoryMap[categoryId];
    },

    getCategoryForData : function(dataOrId){
        var dataType = this.getDataTypeForData(dataOrId);
        if(dataType){
          var categoryId = dataType.getCategoryId();
          return this._categoryMap[categoryId];
        }
        return null;
    },

    getDataTypeForData : function(dataOrId){
    	if(!dataOrId){
    		return;
    	}
    	var data = dataOrId;
        if(typeof data === "string"){ // id
            data = this._dataMap[data];
        }
        if(!data){
          return;
        }
        if(!(data instanceof it.Data) && !(data instanceof it.Link) ){
            return;
        }
        if(!data.getDataTypeId){
          console.log("data.getDataTypeId");
        }
        var dataTypeId = data.getDataTypeId();
        return this._dataTypeMap[dataTypeId];
    },

   getDataTypeById: function(linkId) {
      if (!linkId) {
        return null;
      }
      return this._dataTypeMap[linkId];
   },

    addDataTypeFromJson : function(dataTypes){
        var i = 0,len = dataTypes.length;
        for(;i < len;i ++){
          var dataType = new it.DataType();
          dataType.fromJson(dataTypes[i]);

          this.addDataType(dataType);
        }
    },

    /**
     * data
     * 
     * @param data
     * @returns {null}
     */
    setParentAndChildren : function(data){
        if(!data){
            return null;
        }
        var parentId = data.getParentId();
        if(parentId){
           var parentData =  this._dataMap[parentId];
            if(parentData){
                parentData.addChild(data);
            }
        }
        var children = this.getChildren(data);
        data.addChildren(children);
    },

    /**
     * data
     * setParentAndChildren
     * 
     */
    setAllParentAndChildren : function(){
        for(var id in this._dataMap){
            var data = this._dataMap[id];
            if(data && data.getParentId()){
                var parentData = this._dataMap[data.getParentId()];
                if(parentData){
                    parentData.addChild(data);
                }
            }
        }
    },

    addData : function(data,fireEvent,setParentAndChildren){
       if(!data){
       	 return;
       }
       if(fireEvent === undefined){
          fireEvent = true;
       }
        if(setParentAndChildren === undefined){
            setParentAndChildren = true;
        }
       var id = data.getId();
       var dataTypeId = data.getDataTypeId();

       if(this._dataMap[id]){
       	  throw "Data for '" + id +"' already exists";
       }
       var dataType = this.getDataTypeForData(data);
       if(!dataType){
       	 throw "DataType '" + dataTypeId + "' does not exist";
       }
       this._datas.push(data);
       this._dataMap[id] = data;
       var parentId = data.getParentId();
       if(!parentId){
       	  this._roots.push(data);
       	  this._rootMap[id] = data;
       }
        if(setParentAndChildren){
            this.setParentAndChildren(data);
        }
       // 
       var typeDatas = this._dataTypeDatas[dataTypeId];
       if(typeDatas == null){
       	  typeDatas = {};
       	  this._dataTypeDatas[dataTypeId] = typeDatas;
       }
       typeDatas[id] = data;
       
       // 
       var category = this.getCategoryForData(data);
       if(category){
         var categoryDatas = this._categoryDatas[category.getId()];
         if(categoryDatas == null){
            categoryDatas = {};
            this._categoryDatas[category.getId()] = categoryDatas;
         }
         categoryDatas[id] = data;
       }
       data.addPropertyChangeListener(this.handleDataPropertyChange, this);
       if(fireEvent){
          this._dataManagerChangeDispatcher.fire({
             kind : 'add',
             data : data,
             source : this
          });
       }

    },

    addDataFromJson : function(json){
       var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       // checkData
       var i = 0,len = jsonObjects.length;
       for(;i < len;i ++){
          var id = json.id;
          var dataTypeId = json.dataTypeId;
       } 

       for(i = 0;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var data = new it.Data();
          data.fromJson(jsonObject);
          this.addData(data,true,false);
       }
        this.setAllParentAndChildren();
    },

    /**
     * data
     * datait.Dataid
     */
    removeData : function(data,removeChild){ // TODO
        if (!data) {
            return false;
        }
        var id = data.getId ? data.getId():data;
        if (!this._dataMap[id]) {
            return false;
        }
        var data = this._dataMap[id];
        var index = this._datas.indexOf(data);
        if (index === -1) {
            return false;
        }
        //datamaanger
        if (data.getParentId()) {
            var parentData = this._dataMap[data.getParentId()];
            if (parentData) {
                parentData.removeChild(data);
            }

        }
        var childArray = data.getChildren();//this.getChildren(data);
        if (childArray && childArray.size() && !removeChild) {
            return false;
        } else if (childArray && childArray.size()) {
            for (var i = 0; i < childArray.size(); i++) {
                this.removeData(childArray.get(i), removeChild);
            }
        }

        delete this._dataMap[id];
        this._datas.splice(index, 1);

        var dataTypeId = data.getDataTypeId();
        var typeDatas = this._dataTypeDatas[dataTypeId];
        if (typeDatas != null) {
            delete typeDatas[id];
        }

        var category = this.getCategoryForData(data);
        if (category) {
            var categoryDatas = this._categoryDatas[category.getId()];
            if (categoryDatas != null) {
                delete categoryDatas[id]
            }
        }
        data.removePropertyChangeListener(this.handleDataPropertyChange, this);
        this._dataManagerChangeDispatcher.fire({
            kind: 'remove',
            data: data,
            source: this
        });
        return true;
    },

    addLink : function(link){
        var id = link.getId();
        if (this._linkMap[id]) {
            return;
        }
        var fromId = link.getFromId();
        var toId = link.getToId();

        if (!this._dataMap[fromId]) {
            console.log("From Id does not exist");
            return;
        }
        if (!this._dataMap[toId]) {
            console.log("To Id does not exist");
            return;
        }
        this._linkMap[id] = link;
        this._links.push(link);

        this._dataMap[fromId].addLink(link); // linkdata
        this._dataMap[toId].addLink(link);

        this._dataManagerChangeDispatcher.fire({
            kind: 'add',
            data: link,
            source: this
        });
        return true;
    },

    removeLink : function(link){
       var id = link.getId();
       if(this._linkMap[id]){
          var index = this._links.indexOf(link);
          this._links.splice(index,1);
          delete this._linkMap[id];
       }

        var fromId = link.getFromId();
        var toId = link.getToId();

        this._dataMap[fromId].removeLink(link); // linkdata
        this._dataMap[toId].removeLink(link);

        this._dataManagerChangeDispatcher.fire({
          kind : 'remove',
          data : link,
          source : this
       });
    },

    addTemperatureField : function(field){
        if(!field){
            return ;
        }
        if(this._temperatureFields && this._temperatureFields[field.getId()]){
            throw "Temparature Field for '" + field.getId() +"' already exists";
        }
        this._temperatureFields[field.getId()] = field;
        if(this._collectors){
            for (var cid in this._collectors){
                var collector = this._collectors[cid];
                if(collector.getType() == $Collector.Type.temperature && collector.getParentId() == field.getId()){
                     field.addCollector(collector);
                }
            }
        }

    },

    addTemperatureFieldFromJson : function(json){
        var jsonObjects = json;
        if(typeof json === "string"){
            jsonObjects = JSON.parse(json);
        }
        var i = 0,len = jsonObjects.length;
        for(;i < len;i ++){
            var jsonObject = jsonObjects[i];
            var field = new $TemperatureField();
            field.fromJson(jsonObject);
            this.addTemperatureField(field);
        }
    },

    removeTemparatureField : function(field){
        if(!field){
            return ;
        }
        var collectors = field.getCollectors();
        if(collectors && collectors.size() > 0){
            var self = this;
            collectors.forEach(function(collector){
                if(collector){
                    delete self._collectors[collector.getId()];
                }
            })
        }
        delete this._temperatureFields[field.getId()];

    },

//        this._temperatureFields = {}; //
//        this._collectors
    addCollector : function(collector){
        if(!collector){
            return ;
        }
        if(this._collectors && this._collectors[collector.getId()]){
            throw "Collector for '" + collector.getId() +"' already exists";
        }
        this._collectors[collector.getId()] = collector;
        // if(collector.getType() == 'temperature'){ // remove 2017-09-04
            var tepField = this._temperatureFields[collector.getParentId()];
            if(tepField){
                tepField.addCollector(collector);
            }
        // }
        var collectorType = collector.getType();
        var typeCollectors = this._typeCollectors[collectorType];
        if(typeCollectors == null){
            typeCollectors = {};
            this._typeCollectors[collectorType] = typeCollectors;
        }
        typeCollectors[collector.getId()] = collector;
    },

    addCollectorFromJson : function(json){
        var jsonObjects = json;
        if(typeof json === "string"){
            jsonObjects = JSON.parse(json);
        }
        var i = 0,len = jsonObjects.length;
        for(;i < len;i ++){
            var jsonObject = jsonObjects[i];
            var collector = new $Collector();
            collector.fromJson(jsonObject);
            this.addCollector(collector);
        }
    },

    removeCollector : function(collector){
        if(!collector){
            return ;
        }
        delete this._collectors[collector.getId()];
        if(collector.getType() == 'temperature'){
            var tepField = this._temperatureFields[collector.getParentId()];
            if(tepField){
                tepField.removeCollector(collector);
            }
        }
        var collectorType = collector.getType();
        var typeCollectors = this._typeCollectors[collectorType];
        if(typeCollectors){
            delete typeCollectors[collector.getId()];
        }
    },

    getParent : function(data){
        if(!data){
            return null;
        }
        if(data instanceof it.Data){
           var parentId = data.getParentId();
           return this._dataMap[parentId];
        }
    },

    getChildren : function(data,dataTypeId){
//        var now = new Date();
       var childArray = [];
       if(!data){
        return childArray;
       }
       var pId = data.getId();
       for(var id in this._dataMap){
         var data = this._dataMap[id];
         if(!dataTypeId || data.getDataTypeId() == dataTypeId){
            if(data.getParentId() === pId){
              childArray.push(data);
            }
         }
         
       }
//        console.log(" getChild-------: "+((new Date()).getTime() - now.getTime()));
       return childArray;
    },

    /**
     * ancestorIddataid
     * @param ancestorId id
     * @param data
     */
    isAncestor : function(ancestorId,data,scop){
        if(!data || !ancestorId){
            return false;
        }
        if(data.getId() === ancestorId || data.getParentId() === ancestorId){
            return true;
        }
        var scop = scop||this;
        if(data.getParentId()){
            var parent = this._dataMap[data.getParentId()];
            if(parent){
                return scop.isAncestor(ancestorId,parent,scop);
            }
        }
        return false;
    },

    /**
     * data()
     * @param data
     */
    getDescendants : function(data,results,scope){
        var descendants = results || [];
        var scope = scope || this;
        if(!data){
            return descendants;
        }
//        var pId = data.getId();
//        for(var id in this._dataMap){
//            var data = this._dataMap[id];
//                if(this.isAncestor(pId,data)){
//                    descendants.push(data);
//                }
//        }
        var children = data.getChildren();
        if(children && children.size() > 0){
            children.forEach(function(child){
                descendants.push(child);
                scope.getDescendants(child,descendants,scope);
            });
        }
        return descendants;
    },



    getDataMap : function(){
      return this._dataMap;
    },

    getLinkMap : function(){
      return this._linkMap;
    },

    /**
     * linkIdlink
     * @param id
     */
    getLinkById : function(id){
        if(!id){
            return null;
        }
        return this._linkMap[id];
    },

    getFromLinks : function(dataOrId){

    },

    getToLinks : function(dataOrId){

    },

    getDataMapByCategory : function(categoryOrId){
       var id = categoryOrId;
       if(id instanceof it.Category){
          it = id.getId();
       }
       return this._categoryDatas[id];
    },

    getDataById : function(id){
      if(!id){
         return null;
      }
      var data = this._dataMap[id];
      if(!data && typeof(id) === 'string' &&  id.indexOf('@') > 0){
         var ids = id.split("@");
         var childId = ids[0],parentId = ids[1]
         var parent = this.getDataById(parentId);
         if(parent){
            return null;
         }
         var dataType = this.getDataTypeForData(parent);
         if (!dataType) {
           return null;
         };
         var templateData = dataType.getTemplateDataById(childId);
         if(templateData){
            var templateDataType = this.getDataTypeForData(templateData);
            if(!templateDataType){
                return null;
            }
            var newData = templateData.clone(id);
            newData.setParentId(parentId);
            this.addData(newData);
            return newData;
         }
      }
      return data;
    },

    getCollectorById : function(cid){
       return this._collectors[cid];
    },

    getDatas : function(){
       return this._datas;
    },

    getLinks : function(){
        return this._links;
    },

    getAncestors : function(data,array){
       array = array || [];
       var parent = this.getDataById(data.getParentId());
       if(parent){
          array.push(parent);
          this.getAncestors(parent,array);
       }
       return array;
    },

    getAncestor : function(data,filterFunction){
        var dataType = this.getDataTypeForData(data);
        var category = this.getCategoryForData(data);
        if(filterFunction(data,dataType,category)){
           return data;
        }
        var parent = this.getParent(data);
        if(parent == null){
          return null;
        }else{
          return this.getAncestor(parent,filterFunction);
        }
    },

    getRootMap : function(){
       return this._rootMap;
    },

    getRoots : function(){
       return this._roots;
    },

    getTemperatureFields : function(){
        return this._temperatureFields;
    },

    isLazyable : function(data){
      if(!data){
        return false;
      }
      var dataType = this.getDataTypeForData(data);
      if(dataType.isLazyable()){
         return true;
      }
      var parentData = this.getParent(data);
      if(this.isLazyable(parentData)){ // parent 
         return true;
      }
      return false;
    },

    fromJson : function(json){
       json = $Util.translateJson(json);
       var categories = json.categories || [];
       var dataTypes = json.dataTypes || [];
       var datas = json.datas || [];
       
       var categoryMap = {},dataTypeMap = {},i = 0;
       for(;i < categories.length;i ++){
          var  category = categories[i];
          categoryMap[category.id] = category;
       }

       for(i = 0;i < dataTypes.length;i ++){
          var dataType = dataTypes[i];
          if(dataType.categoryId && !categoryMap[dataType.categoryId] && !this._categoryMap[dataType.categoryId]){
             throw "Category for '" + dataType.categoryId + "' does not exist";
          }
          dataTypeMap[dataType.id] = dataType;
       }

       for(i = 0;i < datas.length;i ++){
           var data = datas[i];
           var dataTypeId = data.dataTypeId;
           if(!dataTypeMap[dataTypeId] && !this._dataTypeMap[dataTypeId]){
                 throw "DataType '" + dataTypeId + "' does not exist"; 
           }
       }

       if(categories && categories.length){
         this.addCategoryFromJson(categories);
       }
       if(dataTypes && dataTypes.length){
         this.addDataTypeFromJson(dataTypes);
       }
       if(datas && datas.length){
         this.addDataFromJson(datas);
       }
    },

    handleDataPropertyChange:function(event){
        var data = event.source;
        if (event.property === "parentId") {
           var oldValue = event.oldValue,newValue = event.newValue;
           if(newValue == null){
              this._roots.push(data);
              this._rootMap[data.getId()] = data;
           }else if(oldValue == null){
              delete this._rootMap[data.getId()];
              var index = this._roots.indexOf(data);
              if(index != -1){
                this._roots.splice(index,1);
              }
           }
        } 
        this.onDataPropertyChanged(data, event);
        this._dataPropertyChangeDispatcher.fire(event);
    },

    onDataPropertyChanged : function(data,event){
       
    },

    addDataPropertyChangeListener : function(listener, scope, ahead) {
        this._dataPropertyChangeDispatcher.add(listener, scope, ahead);
    },
    removeDataPropertyChangeListener : function(listener, scope) {
        this._dataPropertyChangeDispatcher.remove(listener, scope);
    },

    addDataManagerChangeListener: function (listener, scope, ahead) {
        this._dataManagerChangeDispatcher.add(listener, scope, ahead);
    },
    addDataBoxChangeListener: function (listener, scope, ahead) {
        this._dataManagerChangeDispatcher.add(listener, scope, ahead);
    },
    removeDataManagerChangeListener: function (listener, scope) {
        this._dataManagerChangeDispatcher.remove(listener, scope);
    },


    /**
     * data
     * ,false
     * : dataType,,true
     * : category,,true
     * : false
     * @param data {it.Data} data
     * @returns {boolean}
     */
    isStopAlarmPropagation:function(data){

        if(!data){
            return false;
        }
        var dataType = this.getDataTypeForData(data);
        if (!dataType) {
            return false;
        }
        if (dataType.isStopAlarmPropagationable()) {
            return true;
        }
        var category = this.getCategoryForData(data);
        if (!category) {
            return false;
        }
        if (category.isStopAlarmPropagationable()) {
            return true;
        }
        return false;
    },
});

it.DataManager = $DataManager;
/**
 * terry SceneManager
 */
var $Scene = function (parameters) {
    $Base.call(this);
	parameters = parameters || {};
    if(typeof parameters === 'string'){
       parameters = {id : parameters};
    }
	this._id = parameters.id;
	this._categoryId = parameters.categoryId;
    this._root =  false || parameters.root;
	this._sceneType = parameters.sceneType || "ShowSelf";
    this._twod = parameters.twod||false; //twod
    this._withGis = parameters.withGis || false;
    this.zoomLevel = parameters.zoomLevel|| 5;
    this.center = parameters.center;
    this._description = "";
    //network
    this.lights = [];
    this.networkParameters = {};
    this.cameraParameters = {};
    this.animateParameters = {};
    this.showStaticInfo = parameters.showStaticInfo;
    this.defaultInteractionParameters = parameters.defaultInteractionParameters;
    this._preRender = parameters.preRender || false;
};

mono.extend($Scene,$Base,{
   ___accessor : ["categoryId","sceneType","root",'twod','withGis','description','preRender'],

    getId : function(){
     return this._id;
    },

    isRoot : function(){
      return this._root;
    },

    isShowStaticInfo : function(){
        return this.showStaticInfo;
    },

    fromJson : function(json){
        if(typeof json === 'string'){
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._categoryId = json.categoryId;
        this._root =  false || json.root;
        this._sceneType = json.sceneType || "ShowSelf";
        this._twod = json.twod||false; //twod
        this._withGis = json.withGis || false;
        this.zoomLevel = json.zoomLevel|| 5;
        this.center = json.center;
        this._description = json.description;
        this.networkParameters = json.networkParameters;
        this.cameraParameters = json.cameraParameters;
        this.showStaticInfo = json.showStaticInfo;
        this.defaultInteractionParameters = json.defaultInteractionParameters;
        this._preRender = json.preRender || false;
//        this._dialog = json.dialog;
    }
});

it.Scene = $Scene;

/**
 * Create By: Bozai 
 * ,(networkdiv)
 * scenerootDataCustomSceneView
 * ViewManagerViewManager2D
 */
var $CustomSceneView = function(sceneId, sceneManager) {
	this.sceneManager = sceneManager;
	this.sceneId = sceneId;
	// this.scene = this.sceneManager.dataManager._sceneMap[sceneId];
	this.defaultEventHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
	// this.rootData = rootData;
	// this.init();
};

mono.extend($CustomSceneView, Object, {

	// init: function() {
	// },

    /**
     * View
     * nullviewManager3D
     */
	getContainer: function() {
		return null;
	},

	getNetwork3D : function(){
		return null;
	},

	getCamera : function(){
		return null;
	},

	adjustBounds : function(w, h, left, top){
		// view
	},

	/**
	 * view
	 */
	show: function(rootData) {

	},

	/**
	 * 
	 */
	clear: function() {
		return null;
	},

    /**
     * 
     */
	setFocusNode : function(node){

	},
    
    /**
     * lookAt
     */
	lookAt : function(node){

	},

	isLoadData : function(){
		return true;
	}

});

it.CustomSceneView = $CustomSceneView;


/**
 * 
 */
var $Link = function(parameters){
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._id = parameters.id;
    this._name = parameters.name || '';
    this._dataTypeId = parameters.dataTypeId || '';
    this._type = parameters.type || '';
    this._fromId = parameters.fromId;//  F01_01.1
    this._fromSide = parameters.fromSide||0; //01
    this._toId = parameters.toId;
    this._toSide = parameters.toSide||0;//01
    this._userDataMap = {}; //DataInfouserDataMap 
    // this._controls = null;
    this._fromControls = parameters.fromControls || null;
    this._toControls = parameters.toControls || null;
    this._radius = 2;
    this._alarmState = new it.AlarmState(this);
    this._fromPortId = parameters.fromPortId;
    this._toPortId = parameters.toPortId;
    this._routeType = parameters.routeType;
    this._fromIpAddress = parameters.fromIpAddress;
    this._toIpAddress = parameters.toIpAddress;
    // "$p0.front + $p0.depth/2","$p1"
};
mono.extend($Link,$Base,{
   ___accessor : ['name','type','dataTypeId','fromId','fromSide','toId','toSide','fromControls','toControls','radius','alarmState','fromPortId','toPortId','routeType','fromIpAddress','toIpAddress'],
    IT_Data:true,
   getId : function(){
      return this._id;
   },
   
   setId : function(id){
       if(this._id === undefined){
          this._id = id;
       }else{
          throw 'Can\'t change id';
       }
   },

   setUserData : function(key,value){
       if(value == null){
         delete this._userDataMap[key];
       }else{
         this._userDataMap[key] = value;
       }
    },
   
    getUserData  :function(key){
       return this._userDataMap[key];
    },
});
it.Link = $Link;

/**
 * /
 * typeparentIddataId
 *      typeparentIdtemperatureFieldId(id)
 * @constructor
*/

var $Collector = function(parameters){
    $Base.call(this);
    parameters = parameters || {};
    this._parentId = parameters.parentId||""; // id
    this._id = parameters.id || "";
    this._position = parameters.position || new mono.Vec3();
    this._location = parameters.location||''; //dataid
    this._value = parameters.value || "0";
    this._data = parameters.data||{}; //dataobj
    // 
    this._width = parameters.width || 0;
    this._height = parameters.height || 0;
    this._depth = parameters.depth ||0;
    this._description = parameters.description;
    this._type = parameters.type || "temperature";
};
/**
 * 
 * @type {string}
 */
$Collector.Type = {};
$Collector.Type.humidity = 'humidity';
$Collector.Type.temperature = 'temperature';

mono.extend($Collector,$Base,{
    ___accessor: ['id','parentId','value','data','width',"height","depth","type","position","location"],

    fromJson : function(json){
        if(typeof json === 'string'){
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._parentId = json.parentId;
        this._description = json.description;
        this._width = json.width;
        this._height = json.height;
        this._depth = json.depth;
        this._type = json.type;
        this._value = json.value;
        this._data = json.data;
        if(json.position && (json.position.x!== undefined || json.position.y!== undefined || json.position.z!== undefined)){
            this._position = new mono.Vec3(json.position.x || 0,json.position.y || 0,json.position.z || 0);
        }else if(mono.Utils.isArray(json.position)){
            this._position = new mono.Vec3(json.position[0] || 0,json.position[1] || 0,json.position[2] || 0);
        }
        this._location = json.location;
    },

});

it.Collector = $Collector;

/**
 * 
 * @type {string}
 */
//it.Collector.Type = {};
//it.Collector.Type.humidity = 'humidity';
//it.Collector.Type.temperature = 'temperature';
//it.Collector.Type.humidity = 'humidity';

/**
 * 
 * @constructor
 */
var $TemperatureField = function(parameters){
    $Base.call(this);
//    this.sceneManager = sceneManager;
    parameters = parameters || {};
    this._parentDataId = parameters.parentDataId; // id(area)
    this._id = parameters.id || "";
    this._width = parameters.width || null; // 
    this._height = parameters.height || null;
    this._position = parameters.position || new mono.Vec3();
    this._description = parameters.description || "";
//    this.heatMap = null;
    ///,(manager)
    this._minValue = parameters.minValue || null;
    this._maxValue = parameters.maxValue ||null;
    this._withBg = parameters.withBg || false; //

//    this.tempBillbords = {};
//    this.parentNode = this.sceneManager.getNodeByDataOrId(this._parentDataId);
    this.collectors = new mono.List(); // 
//    this.dataBox = this.sceneManager.network3d.getDataBox();
    //,
//    this.isVirtualElementFunction = function(){ //
//        return true;
//    };
//    this.virtualFilter = new it.VirtualManager(this.sceneManager);
//    this.sceneManager.viewManager3d.addMaterialFilter(this.virtualFilter);
//    this.tempBoard = null;
};

mono.extend($TemperatureField,$Base,{

    ___accessor: ['id',"parentDataId",'width','height',"position","minValue","maxValue","withBg"],

    fromJson : function(json){
        if(typeof json === 'string'){
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._parentDataId = json.parentDataId;
        this._description = json.description;
        this._width = json.width;
        this._height = json.height;
        this._withBg = json.withBg;
        this._minValue = json.minValue;
        this._maxValue = json.maxValue;
        if(json.position && (json.position.x!== undefined || json.position.y!== undefined || json.position.z!== undefined)){
            this._position = new mono.Vec3(json.position.x || 0,json.position.y || 0,json.position.z || 0);
        }else if(mono.Utils.isArray(json.position)){
            this._position = new mono.Vec3(json.position[0] || 0,json.position[1] || 0,json.position[2] || 0);
        }
    },

    addCollector : function(collector){
        if(collector){
            this.collectors.add(collector);
        }
    },

    removeCollector : function(collector){
        if(collector){
            this.collectors.remove(collector);
        }
    },

    getCollectors : function(){
        return this.collectors;
    }

});

it.TemperatureField = $TemperatureField;

var $Light = function(params){
   var params = params||{};
   this._id = params.id||'';
   this._description = params.description;
   this._sceneId = params.sceneId;
   this._type = params.type; // 
   this._color = params.color || 'PointLight';
   this._intensity = params.intensity;
   this._distance = params.distance;
   this._position = params.position||new mono.Vec3;
};

mono.extend($Light,$Base,{
   ___accessor: ['id','sceneId','type','color', 'intensity', "distance", "position"],
	
	fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._description = json.description;
        if (json.position && (json.position.x !== undefined || json.position.y !== undefined || json.position.z !== undefined)) {
            this._position = new mono.Vec3(json.position.x || 0, json.position.y || 0, json.position.z || 0);
        } else if (mono.Utils.isArray(json.position)) {
            this._position = new mono.Vec3(json.position[0] || 0, json.position[1] || 0, json.position[2] || 0);
        }
        
        this._sceneId = json.sceneId;
        this._type = json.type;
        this._color = json.color;
        this._intensity = json.intensity;
        this._distance = json.distance;
    },
});

it.Light = $Light;

/**
 * 
 * @param sceneManager
 * @constructor
 */
var $TemperatureFieldManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.isVirtualElementFunction = function(){ //
        return true;
    };
    this.virtualFilter = new it.VirtualManager(this.sceneManager);
    this.oldOpacityValue = this.virtualFilter.opacityValue;
    this.virtualFilter.opacityValue = 0.20;
    this.sceneManager.viewManager3d.addMaterialFilter(this.virtualFilter);
    this.fields = null;
    this.dataBox = this.sceneManager.network3d.getDataBox();
    this.heatMaps = {};
    this.tempBoards = {};
    this.bgMap = {}; //map {'blue':[minValue,maxValue]} add By Kevin 2016-11-16TemperatureField_minValue_maxValue
    this.isAnimate = true; // 
    this.deltaY = 0;
    this.billboardCanvasMap = {};//billboardcanvas,canvas
    this.highestValue = 70.0;//1(0-1)70.01
    this.isBillboardVertical = true;
};

mono.extend($TemperatureFieldManager,Object,{

    getAllCollectors : function(){
        return this.sceneManager.dataManager._typeCollectors[$Collector.Type.temperature];
    },

    /**
     * 
     */
     showWithoutTempField : function(withIntervalRefresh,interval){
        this.tempBillbords = {};
        this.tempCollectors = this.getAllCollectors();//this.sceneManager.dataManager._typeCollectors[$Collector.Type.temperature];
        if(!this.tempCollectors){
            return 0;
        }
        if(this.intervalId){
            return 0;
        }
        var count = 0;
        for(var id in this.tempCollectors){
            var collector =  this.tempCollectors[id];
            if(collector){
                if(this.sceneManager.isCurrentSceneInstance(collector.getParentId())){
                    this.createBillboard(collector);
                    count++;
                }
            }
        }
        if(count < 1){
            return 0;
        }
        var self = this;
        if (withIntervalRefresh) {
            interval = parseInt(interval)||5000;
            this.intervalId = window.setInterval(function() {
                self.updateBillboards();
            }, interval);
        }else {
            this.intervalId = window.setInterval(function() { //intervalId
                // do nothing
            }, 10000);
        }
        return count;
     },

     getCollectorById : function(id){
         return this.dataManager._collectors[id];
     },

     beforeUpdateBillboards : function(){
         return;
     },

     updateBillboards : function(){
        this.beforeUpdateBillboards();
        if(!this.tempBillbords){
            return ;
        }
        for(var id in this.tempBillbords){
            var collector = this.getCollectorById(id);//this.dataManager._collectors[id];
            this.createBillboard(collector);
        }
     },

    /**
     * 
     * :
     * 1scenescenetempfeild
     * 2scenerootfieldroot
     */
    show : function(){
        var tempFieldSetting = [4,50];
        this.fields = this.dataManager.getTemperatureFields();
        if(this.intervalId){ // 
            return ;
        }
        if(this.tempFieldArr && this.tempFieldArr.length){
            this.tempFieldArr.forEach(function(field){
                if(field.name.toLowerCase() == 'layernum'){
                    tempFieldSetting[0] = parseInt(field.value);
                }
                if(field.name.toLowerCase() == 'spacing'){
                    tempFieldSetting[1] = parseInt(field.value);
                }
            })
        }
        var currentFields = this.getCurrentSceneFields();
        if (!currentFields || currentFields.length < 1) {
            return ;
        }
        for(var i = 0 ; i < currentFields.length ; i++){
            this.createTempFieldByField(currentFields[i]);
        }
        this.virtualAllElement();
        this.sceneManager.network3d.dirtyNetwork();

        // 3:
        var self = this;
        this.intervalId = window.setInterval(function(){

            self.beforeRefresh();

            self.refresh(function(fid) {
                var hm = self.heatMaps[fid];
                var tempBoard = self.tempBoards[fid];
                if (self.isAnimate) {
                    var py = parseFloat(tempBoard.orgPositionY) + parseFloat(self.deltaY);
                    tempBoard.setPositionY(py);
                }
                if (tempBoard) {
                    tempBoard.setStyle('m.texture.image', hm.heatMapCanvas);
                    tempBoard.invalidateTexture();
                    // tempBoard.setStyle('m.texture.image', hm.getImage());
                    if (hm.heatMapCanvas.parentNode) {
                        document.body.removeChild(hm.heatMapCanvas);
                    }
                }
            });
            if(self.deltaY > tempFieldSetting[1]*(tempFieldSetting[0]-2)){
                self.deltaY = 0;
             }else{
                self.deltaY += tempFieldSetting[1];
            }
        },2000);
    },

    beforeRefresh : function(){

    },

    /**
     * 
     */
    refresh: function (callback) {
        var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
        var self = this;
        var fun = function(){
            for(var fid in self.heatMaps) {
                var hm = self.heatMaps[fid];
                if(self.isAnimate && self.deltaY > 0){
                    if(hm.datas && hm.datas.length > 0){
                        for(var i = 0 ; i < hm.datas.length ; i++){
                            var data = hm.datas[i];
                            if(data && data.length == 3){
                                data[2] = data[2] + 0.05; //0.05
                            }
                        }
                    }
                    self.refreshColletor(self.fields[fid],hm);
                }else{// floordeltaY++refresh
                    hm.clear();
                    self.setDataByField(self.fields[fid],hm);
                }
                document.body.appendChild(hm.getCanvas());
                if (callback) {
                    callback(fid);
                }
            }
        };
        raf(fun);
    },

    /**
     * 
     */
    hide : function(){
        if(this.intervalId) {
            window.clearInterval(this.intervalId);
            delete this.intervalId;
        }else{
            return;
        }
        this.virtualFilter.clearAll();
        this.sceneManager.network3d.setSelectTransparencyThreshold(this.oldOpacityValue + 0.1); //
        if(this.tempBoards){
            for(var fid in this.tempBoards){
                var board = this.tempBoards[fid];
                this.dataBox.remove(board);
                delete this.heatMaps[fid];
                delete this.tempBoards[fid];
            }
        }
        if(this.tempBillbords) {
            for (var collectorId in this.tempBillbords) {
                if (collectorId) {
                    var billboard = this.tempBillbords[collectorId];
                    if (billboard) {
                        billboard.setParent(null);
                        this.dataBox.remove(billboard);
                    }
                }
            }
            delete this.tempBillbords;
        }
        this.sceneManager.network3d.dirtyNetwork();
    },

    isShowing : function(){
        if(this.intervalId){
            return true;
        }
        return false;
    },

    /** 
     * 
     * floorroom
     */
    getNnVirtualCategorys : function(){
        return ['floor','room'];
    },

    virtualAllElement : function(){
        //
        this.sceneManager.network3d.setSelectTransparencyThreshold(this.virtualFilter.opacityValue + 0.01);
        if(this.isVirtualElementFunction &&  this.isVirtualElementFunction()){
            this.virtualFilter.addAll();
            /*
            //
            var categoryDatas = this.dataManager.getDataMapByCategory('floor');
            if(categoryDatas){
                for(var id in categoryDatas){
                    var data = categoryDatas[id];
                    if(data){
                        this.virtualFilter.remove(data);
                    }
                }
            }
            var roomDatas = this.dataManager.getDataMapByCategory('room');
            if(roomDatas){
                for(var id in roomDatas){
                    var data = roomDatas[id];
                    if(data){
                        this.virtualFilter.remove(data);
                    }
                }
            }
            */
            var nuVirtualCategorys = this.getNnVirtualCategorys();
            if (nuVirtualCategorys && nuVirtualCategorys.length > 0) {
                for (var i = 0; i < nuVirtualCategorys.length; i++) {
                    var cId = nuVirtualCategorys[i];
                    var categoryDatas = this.dataManager.getDataMapByCategory(cId);
                    if (categoryDatas) {
                        for (var id in categoryDatas) {
                            var data = categoryDatas[id];
                            if (data) {
                                this.virtualFilter.remove(data);
                            }
                        }
                    }
                }
            }
        }
    },

    createTempFieldByField: function (field) {
        if (!field) return null;
        var parentNode = this.sceneManager.getNodeByDataOrId(field.getParentDataId());
        if (!parentNode) { // parent
            return null;
        }
        var position = field.getPosition();
        var withBg = field.getWithBg();
        // heatMap(position)parent
//        var p_w_pos = parentNode.getWorldPosition();
        var p_w_pos = it.Util.getNodeCenterPosition(parentNode);
        var px = p_w_pos.x + position.x;
        var py = p_w_pos.z + position.y;
        var heatMap = new it.HeatMap({
            width: field.getWidth(),
            height: field.getHeight(),
            positionX: px,
            positionY: py,
            withBg : withBg,
        });
        this.setDataByField(field, heatMap);
        this.heatMaps[field.getId()] = heatMap;
        var tempBoard = heatMap.getTemperatureBoard();
        this.tempBoards[field.getId()] = tempBoard;
        var height = position.z||0;//ypositionz
        var bpy = parentNode.getWorldPosition().y+50+height;
        tempBoard.setPositionY(bpy);
        var parentWorldPos = parentNode.getWorldPosition();
        // tempBoard.setPositionX(parentWorldPos.x - position.x);// parentNode
        // tempBoard.setPositionZ(parentWorldPos.z - position.y);
        tempBoard.setPositionX(position.x+parentWorldPos.x);// parentNode
        tempBoard.setPositionZ(position.y+parentWorldPos.z);
        tempBoard.orgPositionY = bpy;
        tempBoard.setRotationZ(parentNode.getRotationY()*(-1));//yboardX90"Y""Z"
        tempBoard.setClient(it.SceneManager.CLIENT_EXT_VITUAL,true);//filter
        this.dataBox.add(tempBoard);
        return heatMap;
    },

    setDataByField : function(field,heatMap){
        if(!field) return ;
        if(!field.collectors || field.collectors.length < 1){
            return;
        }
        this.dataBox.startBatch();
        for(var i = 0 ; i < field.collectors.size(); i++){
            var collector = field.collectors.get(i);
            if(collector){
                this.createHeatPoint(collector,heatMap,field);
            }
        }
        this.dataBox.endBatch();
    },

    refreshColletor: function(field) {
        if (!field) return;
        if (!field.collectors || field.collectors.length < 1) {
            return;
        }
        for (var i = 0; i < field.collectors.size(); i++){
            var collector = field.collectors.get(i);
            if (collector) {
                if (this.showBillboard(collector)){
                    this.createBillboard(collector, field);
                }
            }
        }
    },

    format: function (value) {
        return ":\n" + value.toFixed(1) + "C";
    },

    /**
     * billboard
     * @returns {boolean}
     */
    showBillboard : function(collector){
        return true;
    },

    getToFixed : function(){
        return 0;
    },

    /**
     * @param assetNode
     * @param humValue
    */
    createBillboard : function(collector,field){
        if(!collector) return;
        var collectorId = collector.getId();
        if(!this.tempBillbords){
            this.tempBillbords = {};
        }
        var billboard = this.tempBillbords[collectorId];
        if(!billboard){
            var parentDataId = null;
            if (field) {
                parentDataId = field.getParentDataId();
            }else{
                parentDataId = collector.getParentId();
            }
            var parentNode = this.sceneManager.getNodeByDataOrId(parentDataId);
            var position = collector.getPosition();
            var location = collector.getLocation();//dataiddataid3D
            var px,pz,py;
            var p_w_pos = parentNode.getWorldPosition();
            if(location && typeof(location) == 'string' && this.dataManager.getDataById(location)){
                var dataNode = this.sceneManager.getNodeByDataOrId(location);
                if(dataNode){
                    var p_w_pos = it.Util.getNodeCenterPosition(dataNode);
                    px = p_w_pos.x;
                    pz = p_w_pos.z;
                }
            }else{
                px = p_w_pos.x + position.x; 
                pz = p_w_pos.z + position.z;
            }
            var py = p_w_pos.y + position.y;
            var pbb = parentNode.getBoundingBox();
            if(pbb){
                var height = (pbb.max.y-pbb.min.y)/2;
                if(height < 10){ //shapeNode(area)
                    height = 100;
                }
                py = py + height;
            }else {
                py = py + 100;
            }
            // var canvas = this.createCanvas(collectorId,'',':','',null);
            // billboard = it.Util.createSpecailTextBillboard("text",null,true,canvas);//createHumidityBoard
            billboard = new mono.Billboard();
            billboard.s({
                   'm.texture.image':this.createCanvas(collectorId,0,'','',null),
                   'm.transparent': true,
                   'm.alignment': mono.BillboardAlignment.bottomCenter,
                   'm.vertical': !!this.isBillboardVertical, //tue 2017-05-16 Kevin
            }); 
            //collector3d3Dcollector(collectorpositionobj)
//            billboard.setParent(parentNode);
            billboard.setPositionX(px);
            billboard.setPositionY(py);
            billboard.setPositionZ(pz);
            this.tempBillbords[collectorId] = billboard;
            this.dataBox.add(billboard);
        }
        var value = collector.getValue()||0;
        value = Number(parseFloat(value).toFixed(this.getToFixed()));
        if (billboard._tvalue == value) { //
            return;
        }
        var bg = null;
        if(this.bgMap){
            for (var color in this.bgMap) {
                var values = this.bgMap[color];
                if (!values) {
                    continue;
                }
                if (values.length == 2) {
                    if (values[0] != undefined 
                        && values[1] != undefined && value >= values[0] && value < values[1]) {
                        bg = color;
                        break;
                    }else if((values[0] == undefined || values[0] == '') 
                        && values[1] != undefined && value <= values[1]){
                        bg = color;
                        break;
                    }else if(values[0] != undefined 
                        && (values[1] == undefined || values[1] == '') && value >= values[0]){
                        bg = color;
                        break;
                    }
                }else if(values.length == 1 
                    && values[0] != undefined 
                    && value >= values[0]){
                     bg = color;
                     break;
                }
            }
        }
        billboard._tvalue = value;
        var newCanvas = this.createCanvas(collectorId,value,':','C',bg);
        billboard.setStyle('m.texture.image',newCanvas);
        // billboard.setScale(newCanvas.width / 2, newCanvas.height / 2, 1);
        this.setBillboardScale(billboard,newCanvas);
        billboard.setStyle("m.transparent",false);
        billboard.setStyle("m.alphaTest",0.5);
        var image = it.Util.getImageById(bg, value);
        var scaleX = newCanvas.width/2,scaleY = newCanvas.height/2;
        if (image && image.client) {
            if (image.client['scaleX']) {
                scaleX = parseFloat(image.client['scaleX']);
            }
            if (image.client['scaleY']) {
                scaleY = parseFloat(image.client['scaleY']);
            }
        }
        billboard.setScale(scaleX,scaleY,1);
        billboard.invalidateTexture();
        this.afterCreateBillboard(parentNode,billboard);
    },

    afterCreateBillboard : function(parentNode,billboard){
        // billboard
    },

    setBillboardScale : function(billboard,canvas){
        if (billboard && canvas) {
             billboard.setScale(canvas.width / 2, canvas.height / 2, 1);
        }
    },

    createCanvas : function(collectorId,text,titleText,unit,bgcolor){
        var canvas = this.billboardCanvasMap[collectorId];
        // var newCanvas = it.Util.getSpecialTextBillboard(text,titleText,unit,bgcolor,true,canvas);
        // var newCanvas = it.Util.getHumOrTempCanvas(text,titleText,unit,bgcolor,canvas);
        // var newCanvas = this.drawCanvas(text,unit,bgcolor,canvas);
         var newCanvas = it.Util.createHumOrTempCanvas(text,unit,bgcolor,canvas);
        if (!canvas) {
           this.billboardCanvasMap[collectorId] = newCanvas; 
        }
        return newCanvas;
    },

    /*
    drawCanvas: function(text,unit,bgcolor,canvas) {
        var image = it.Util.getImageById(bgcolor, text);
        var canvas = canvas || document.createElement('canvas');
        if (!image) {
            return canvas;
        }
        if (!image.client) {
            image.client = {
                width: 256,
                height: 123,
                size: 50,
                lineWidth: 5,
                color: '#FFFFFF',
                startX: 20,
                startY: 60
            };
        };
        color = image.client['color'] || '#888888';
        var width = image.width,
            height = image.height;
        var context = canvas.getContext('2d');
        width = image.client['width'] || image.width * 2, height = image.client['height'] || image.height * 2;
        canvas.height = height;
        canvas.width = width;
        context.drawImage(image, 0, 0, width, height);
        var x = parseInt(image.client['startX']) || (height - 50);
        var y = parseInt(image.client['startY']) || (height - 50);
        if (text) {
            var csize = parseInt(image.client['size']) || 80;
            var fontFamily = parseInt(image.client['fontFamily'])||'"Microsoft Yahei"';
            // context.font = '80px DigifaceWide';            
            context.font = 'bold '+csize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth = parseInt(image.client['lineWidth']) || 8;
            if (image.client['stroke']) {
                context.strokeStyle = color;
                context.strokeText(text, x, y);
            } else {
                context.fillStyle = color;
                context.fillText(text, x, y);
            }
            if (image.client['withUnit']) {
                var width = context.measureText(text).width;
                var unitSize = parseInt(csize/2)||5;
                context.font = 'bold '+unitSize + 'px "Microsoft Yahei"';
                if (image.client['stroke']) {
                     context.strokeText('C', x+width, y);
                }else{
                     context.fillText('C', x+width, y);
                }
            }

        }
        return canvas;
    },
    */

    /**
    * ba
    * aparentb
    **/
    getRelativePosition: function(a, b) {
        var m1, m2;
        m1 =  new mono.Mat4().getInverse(a.worldMatrix.clone());
        m2 =  new mono.Mat4().multiplyMatrices(m1, b.worldMatrix.clone());
        var position = new mono.Vec3().getPositionFromMatrix(m2);
        return position;
    },

    createHeatPoint : function(collector,heatMap,field){
        if(!collector || !heatMap) return;
        // var position = collector.getPosition();
        var parentNode = this.sceneManager.getNodeByDataOrId(field.getParentDataId());
        //setRotationgetRelativeTransformdataNode
        // var rotationY = parentNode.getRotationY();
        // if (!rotationY) {
        //     parentNode.setRotationY(0);//Y0
        // }
        // var wpp = it.Util.getNodeCenterPosition(parentNode);//parentNode?parentNode.getWorldPosition():new mono.Vec3();
        var rpp = parentNode.getPosition(); //parent

        var position = collector.getPosition();
        var location = collector.getLocation();//dataiddataid3D
        var px,pz;
        if(location && typeof(location) == 'string' && this.dataManager.getDataById(location)){
            var dataNode = this.sceneManager.getNodeByDataOrId(location);
            // var rto =  parentNode.getRelativeTransform(dataNode);
            var rto = this.getRelativePosition(parentNode,dataNode);
            if(dataNode){
                var p_w_pos = it.Util.getNodeCenterPosition(dataNode);
                // p_w_pos.x = p_w_pos.x - wpp.x; //floor
                // p_w_pos.z = p_w_pos.z - wpp.z;
                p_w_pos.x = rto.x; //rto.position.x; //floor
                p_w_pos.z = rto.z; //rto.position.z;
                p_w_pos.x = p_w_pos.x + rpp.x; //(),
                p_w_pos.z = p_w_pos.z + rpp.z; //getRelativeTransform
                px = p_w_pos.x;
                pz = p_w_pos.z;
            }
        }else{
            var p_w_pos = it.Util.getNodeCenterPosition(parentNode);
            // p_w_pos.x = p_w_pos.x - wpp.x; //floor
            // p_w_pos.z = p_w_pos.z - wpp.z;
            // p_w_pos.x = rto.position.x; //floor
            // p_w_pos.z = rto.position.z;
            p_w_pos.x = p_w_pos.x ;//+ rpp.x; //()
            p_w_pos.z = p_w_pos.z ;//+ rpp.z; 
            px = p_w_pos.x + position.x;
            pz = p_w_pos.z + position.z;
        }
        // if (!rotationY) {
        //    parentNode.setRotationY(rotationY);
        // }

        // p_w_pos floor
        // 1p_w_posfloor;

        var value = collector.getValue();//0-1(1)
        if(value){
            value = parseFloat(value/(this.highestValue||70.0)); //701
        }

        if(px!=undefined && pz!=undefined){
//            heatMap.addPoint(px,pz,collector.getValue() || 0);
            var obj = {
                x: px || 0,
                y: pz || 0,
                w: collector.getWidth() || 0,
                l: collector.getDepth() || 0,
                value: value || 0,
//            axis:axis //
            };
            heatMap.addPointWithArea(obj);
        }
        if(this.showBillboard(collector)){
            this.createBillboard(collector,field);
        }
    },

    /**
     * 
     */
    getCurrentSceneFields : function(){
        var tFields = [];
        var fields = this.dataManager.getTemperatureFields();
        for(var fid in fields) {
            var tempField = fields[fid];
            if (!tempField) {
                continue;
            }
            if (this.sceneManager.isCurrentSceneInstance(tempField.getParentDataId(),true)) {
                tFields.push(tempField);
            }
        }
        return tFields;
    }

});

it.TemperatureFieldManager = $TemperatureFieldManager;

var $HumidityManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.dataBox = this.sceneManager.network3d.getDataBox();
    this.humCollectors = null;
    this.tempBillbords = {};
    this.bgMap = {}; //map {'blue':[minValue,maxValue]} add By Kevin 2016-11-16
    // this._minValue = null; //bgMap
    // this._maxValue = null;
    this.billboardCanvasMap = {};
    this.isBillboardVertical = false;
};

mono.extend($HumidityManager,Object,{

    /**
     * 
     * billboard
     * @returns {number} billboard
     */
    show:function(){
        this.humCollectors = this.sceneManager.dataManager._typeCollectors[$Collector.Type.humidity];
        if(!this.humCollectors){
            return 0;
        }
        if(this.intervalIndex){
            return 0;
        }
        var count = 0;
        for(var id in this.humCollectors){
            var collector =  this.humCollectors[id];
            if(collector){
                if(this.sceneManager.isCurrentSceneInstance(collector.getParentId())){
                    this.createBillboard(collector);
                    count++;
                }
            }
        }
        if(count < 1){
            return 0;
        }
        var self = this;
        this.intervalIndex = window.setInterval(function(){
            self.update();
        },5000);
        return count;
    },

    update : function(){
        if(!this.tempBillbords){
            return ;
        }
        for(var id in this.tempBillbords){
            var collector = this.dataManager._collectors[id];
            this.createBillboard(collector);
        }
    },

    hide:function(){
        if(this.intervalIndex){
            window.clearInterval(this.intervalIndex);
            delete this.intervalIndex;
        }
        if(this.tempBillbords){
            for(var id in this.tempBillbords){
                var billboard = this.tempBillbords[id];
                if(billboard){
                    this.dataBox.remove(billboard);
                }
                delete this.tempBillbords[id];
            }
        }
    },

    isShowing : function(){
        if(this.intervalIndex){
            return true;
        }
        return false;
    },

    getToFixed : function(){
        return 2;
    },

    // format: function (value) {
    //     return ":\n" + value.toFixed(1) + "";
    // },

    createBillboard:function(collector){
        if(!collector) return null;
        var collectorId = collector.getId();
        var billboard = this.tempBillbords[collectorId];
        if(!billboard){
            var parentNode = this.sceneManager.getNodeByDataOrId(collector.getParentId());
            if(!parentNode){
                console.log('parent does not exists!');
                return null;
            }
            var position = collector.getPosition();
            var p_w_pos = it.Util.getNodeCenterPosition(parentNode);
            var px = p_w_pos.x + position.x;
            var pz = p_w_pos.z + position.z;
            var py = p_w_pos.y + position.y; //parent+
            var pbb = parentNode.getBoundingBox();
            var height = 0;
            if(pbb){
                height =  (pbb.max.y-pbb.min.y)/2;
            }

            if (height < 10) {
                height = 100;
            }
            py = py + height;

            // var canvas = this.createCanvas(collectorId,'',':','',null);
            billboard = new mono.Billboard();
            billboard.s({
                   'm.texture.image':this.createCanvas(collectorId,0,'','',null),
                   'm.transparent': true,
                   'm.alignment': mono.BillboardAlignment.bottomCenter,
                   'm.vertical': !!this.isBillboardVertical, //false
            }); 
        // billboard = it.Util.createSpecailTextBillboard("text",null,true,canvas);//createHumidityBoard
            //collector3d3Dcollector(collectorpositionobj)
            billboard.setPositionX(px);
            billboard.setPositionY(py);
            billboard.setPositionZ(pz);
            // billboard.setStyle('m.vertical', true);
            this.tempBillbords[collectorId] = billboard;
            this.dataBox.add(billboard);
        }
        var value = parseFloat(collector.getValue()||0);
         if (billboard._tvalue == value) { //
            return billboard;
        }
        var bg = null;
        if(this.bgMap){
            for (var color in this.bgMap) {
                var values = this.bgMap[color];
                if (!values) {
                    continue;
                }
                if (values.length == 2) {
                    if (values[0] != undefined 
                        && values[1] != undefined && value >= values[0] && value <= values[1]) {
                        bg = color;
                        break;
                    }else if((values[0] == undefined || values[0] == '')
                        && values[1] != undefined && value <= values[1]){
                        bg = color;
                        break;
                    }else if(values[0] != undefined 
                        && (values[1] == undefined || values[1] == '') && value >= values[0]){
                        bg = color;
                        break;
                    }
                }else if(values.length == 1 
                    && values[0] != undefined 
                    && value >= values[0]){
                     bg = color;
                     break;
                }
            }
        }
        billboard._tvalue = value;
        var canvas = this.createCanvas(collectorId,value.toFixed(this.getToFixed()),':','%',bg);
        var image = it.Util.getImageById(bg, value);
        var scaleX = canvas.width/2,scaleY = canvas.height/2;
        if (image && image.client) {
            if (image.client['scaleX']) {
                scaleX = parseFloat(image.client['scaleX']);
            }
            if (image.client['scaleY']) {
                scaleY = parseFloat(image.client['scaleY']);
            }
        }
        billboard.setScale(scaleX,scaleY,1);
        // billboard.setScale(canvas.width*1.5,canvas.height*1.5,1);
        billboard.setStyle('m.texture.image',canvas);
        billboard.setStyle("m.transparent",false);
        billboard.setStyle("m.alphaTest",0.5);
        billboard.invalidateTexture();
        return billboard;
    },

    createCanvas : function(collectorId,text,titleText,unit,bgcolor){
        var canvas = this.billboardCanvasMap[collectorId];
        // var newCanvas = it.Util.getHumOrTempCanvas(text,titleText,unit,bgcolor,canvas);
        // var newCanvas = this.drawCanvas(text,unit,bgcolor,canvas);
        var newCanvas = it.Util.createHumOrTempCanvas(text,unit,bgcolor,canvas);
        if (!canvas) {
           this.billboardCanvasMap[collectorId] = newCanvas; 
        }
        return newCanvas;
    },

/*
    drawCanvas: function(text,unit, bgcolor, canvas) {
        var image = it.Util.getImageById(bgcolor, text);
        var canvas = canvas || document.createElement('canvas');
        if (!image) {
            return canvas;
        }
        if (!image.client) {
            image.client = {
                width: 256,
                height: 123,
                size: 50,
                lineWidth: 5,
                color: '#FFFFFF',
                startX: 20,
                startY: 60
            };
        };
        color = image.client['color'] || '#888888';
        var width = image.width,
            height = image.height;
        var context = canvas.getContext('2d');
        width = image.client['width'] || image.width * 2, height = image.client['height'] || image.height * 2;
        canvas.height = height;
        canvas.width = width;
        context.drawImage(image, 0, 0, width, height);
        var x = parseInt(image.client['startX']) || (height - 50);
        var y = parseInt(image.client['startY']) || (height - 50);
        if (text) {
            var csize = parseInt(image.client['size']) || 80;
            var fontFamily = parseInt(image.client['fontFamily'])||'"Microsoft Yahei"';
            // context.font = '80px DigifaceWide';            
            context.font = csize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth = parseInt(image.client['lineWidth']) || 8;
            if (image.client['stroke']) {
                context.strokeStyle = color;
                context.strokeText(text, x, y);
            } else {
                context.fillStyle = color;
                context.fillText(text, x, y);
            }
        }
        return canvas;
    },
    */

    getsCurrentCollector : function(){
        this.humCollectors = this.sceneManager.dataManager._typeCollectors[$Collector.Type.humidity];
        if(!this.humCollectors)return;
        var currentCollector = [];
        for(var id in this.humCollectors){
            var collector =  this.humCollectors[id];
            if(!collector)continue;
            if(this.sceneManager.isCurrentSceneInstance(collector.getParentId())){
                currentCollector.push(collector);
            }
        }
        return currentCollector;
    }

});


it.HumidityManager = $HumidityManager;
/**
 * terry  EventHandler
 */
var $EventHandler = function  () {
	
}

mono.extend($EventHandler,Object,{
    getQueue : function(){
       return 1000;
    },

	shouldHandleDoubleClickElement : function(element,network,data,clickedObj){
       return false;
	},

	shouldHandleMouseUpElement : function(element,network,data,clickedObj){
		return false;
	},

	shouldPropogateDoubleClickElement : function(element,network,data,clickedObj){
       return false;
	},

	shouldHandleDoubleClickBackground : function(network, event){
		return false;
	},

	shouldHandleMouseUpBackground : function(network, event){
		return false;
	},

	shouldPropogateDoubleClickBackground : function(network){
       return false;
	},

	shouldHandleClickElement : function(element,network,data,clickedObj){
       return false;
	},
    
    shouldPropogateClickElement : function(element,network,data,clickedObj){
       return false;
    },

	shouldHandleClickBackground : function(network){
        return false;
	},

	shouldPropogateClickBackground : function(network){
		return false;
	},

	handleDoubleClickBackground : function(network){
        
	},

	handleClickBackground : function(network){
        
	},

	handleDoubleClickElement : function(element,network,data,clickedObj,callback){
	    
	}, 

    handleClickElement : function(element,network,data,clickedObj){
        
    },

    handleMouseMoveElement : function(node,network,data,clickedObj,event){

    },

    handleMouseMoveBackground : function(network){

    },

	handleMouseUpElement : function(node,network,data,clickedObj,event){

	},

	handleMouseUpBackground : function(network){

	},
});

it.EventHandler = $EventHandler;

/**
 * Network
 */
var $ViewManager = function (sceneManager, network, for2d) {
    mono.PropertyChangeDispatcher.call(this);
    this.sceneManager = sceneManager;
    this.network = network || this.initView();
    this.network.getRootView().style.position = 'absolute';
    this._for2d = for2d;
    this._defaultNode = new mono.List();
    this.initResource();
    this.configView();
    this.networkParameters = {};
    this.cameraParameters = {};
    this.enableDBLClick = true; //
    this.enableClick = false;
    this.enableMousemove = true;
    this.enableMouseup = false;
    this.visibleMap = {}; //
};

mono.extend($ViewManager, mono.PropertyChangeDispatcher, {
    initView: function () {
        return new mono.Network3D();
    },

    initResource: function () {
        this._eventHandlers = [];
        this._materialFilters = [];
        this.visibleMap = {};
        this._visibleFilters = [];
        this._selectableFilters = [];
        this._renderCallbacks = [];
        this._focusNode = null;
    },

    initDefault: function () {
        this.defaultEventHandler = new it.DefaultEventHandler(this.sceneManager);
        this._eventHandlers.push(this.defaultEventHandler);

        this.defaultMaterialFilter = new it.VirtualManager(this.sceneManager);
        this._materialFilters.push(this.defaultMaterialFilter);

        this.defaultSelectableFilter = new it.SelectableManager(this.defaultMaterialFilter);
        this._selectableFilters.push(this.defaultSelectableFilter);

        var self = this;
        this.addPropertyChangeListener(function (event) {
            if (event.property == "focusNode") { // lookAtit.Link
                var node = event.newValue;
                if (self.isDealWithVirtual) {
                    self.dealWithVirtual(node);
                }
                /*
                if (self.defaultMaterialFilter) {
                    if(!node){ // 
                        self.defaultMaterialFilter.clear();
                    }else{
                        if (self.defaultMaterialFilter.isVirtualOther(self.getDataByNode(node))) {
                            self.defaultMaterialFilter.addAll();
                            self.defaultMaterialFilter.removeByDescendant(node);
                            if(self.sceneManager.isLink(node)){ //lookAtLinkfromNodetoNode
                                var fromNode = node.getFromNode();
                                var toNode = node.getToNode(); 
                                //:
                                var link = self.getDataByNode(node);
                                if (link) {
                                   if (link.getFromId()) {
                                      fromNode = self.sceneManager.getNodeByDataOrId(link.getFromId());
                                   }
                                   if (link.getToId()) {
                                      toNode = self.sceneManager.getNodeByDataOrId(link.getToId());
                                   }
                                }
                                self.defaultMaterialFilter.removeByDescendant(fromNode);
                                self.defaultMaterialFilter.removeByDescendant(toNode);
                            }
                        }else{ // 
                          self.defaultMaterialFilter.clear();
                        }
                    }
                }
                */
                /**
                 * add by kevin at 2017-05-25
                 * resetCameraDistance 
                 * 1maxdistanceroomfloorresetDistancecamera
                 * 2maxdistanceroomfloorrackcamera
                 * 3minDistance
                 */
                // self.resetCameraDistance(node); 
                self.setCameraDistanceForBeforePlayCamere(node);
            }
        });

        /* Add 2017-08-23 setCameraDistancebeforemin=1max=2wlookAfter
         * beforeminmaxafterdistance
         *   
         */
        // lookAtsetFocusAfter  2017-05-31
        // setFous
        //     setCameraDistanceForBeforePlayCamere,mainNodefocusNode
        this.defaultEventHandler.addAfterLookFinishedAtListener(function (mainNode, node) {
            if (self._focusNode == mainNode) {
                self.setCameraDistanceForAfterPlayCamere(mainNode);
            }
        });

        this.network.setPickingTexturePixel(false);

        // this.network.sortNodes = false; // -- add By Kevin 2017-05-25
        this.network.sortNodes = true;

        this.tooltipManager = new it.TooltipManager(this.sceneManager);
        this.addEventHandler(this.tooltipManager);
        this.addRenderCallback(this.tooltipManager);
        this.addDefaultYRestrict();
        this.addCameraDistanceRestrict();
        this.setDefaultCamera();

        this.sceneManager.addSceneVisibleChangeListener(function (eve) {
            self.visibleMap = {};
        });
    },

    dealWithVirtual: function (node) {
        if (this.defaultMaterialFilter) {
            if (!node) { // 
                this.defaultMaterialFilter.clear();
            } else {
                if (this.defaultMaterialFilter.isVirtualOther(this.getDataByNode(node))) {
                    this.defaultMaterialFilter.addAll();
                    this.defaultMaterialFilter.removeByDescendant(node);
                    if (this.sceneManager.isLink(node)) { //lookAtLinkfromNodetoNode
                        var fromNode = node.getFromNode();
                        var toNode = node.getToNode();
                        //:
                        var link = this.getDataByNode(node);
                        if (link) {
                            if (link.getFromId()) {
                                fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                            }
                            if (link.getToId()) {
                                toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                            }
                        }
                        this.defaultMaterialFilter.removeByDescendant(fromNode);
                        this.defaultMaterialFilter.removeByDescendant(toNode);
                    }
                } else { // 
                    // this.defaultMaterialFilter.clear();

                    //
                    this.defaultMaterialFilter.addAll();
                    var data = this.sceneManager.getNodeData(node);
                    this.defaultMaterialFilter.remove(data);
                    var parentId = data._parentId;
                    var parentData = this.sceneManager.dataManager.getDataById(parentId);
                    this.defaultMaterialFilter.remove(parentData);
                }
            }
        }
    },


    getSetMethod: function (key) {
        var setMethod = 'set' + key.charAt(0).toUpperCase() + key.slice(1);
        return setMethod;
    },

    /**
     * network
     */
    setNetworkValue: function (key, value) {
        if (!key) {
            return;
        }
        var setMethod = this.getSetMethod(key);
        if (this.network[setMethod] && (typeof (this.network[setMethod]) === 'function')) {
            this.network[setMethod](value);
        } else {
            this.network[key] = value;
        }
        this.networkParameters[key] = value;
    },

    /**
     * networkcamera
     */
    resetNetwork: function () {
        if (this.networkParameters) {
            for (var key in this.networkParameters) {
                this.setNetworkValue(key, this.networkParameters[key]);
            }
        }
    },

    /**
     * camera
     */
    setCameraValue: function (key, value) {
        if (!key) {
            return;
        }
        var camera = this.network.getCamera();
        var setMethod = this.getSetMethod(key);
        if (camera[setMethod] && (typeof (camera[setMethod]) === 'function')) {
            camera[setMethod](value);
        } else {
            camera[key] = value;
        }
        this.cameraParameters[key] = value;
    },

    /**
     * camera
     */
    resetCamera: function () {
        if (this.cameraParameters) {
            for (var key in this.cameraParameters) {
                this.setCameraValue(key, this.cameraParameters[key]);
            }
        }
    },

    // data
    clear: function () {
        this.defaultMaterialFilter.clearAll();
        var box = this.network.getDataBox();
        box.clear();
        this.network.pm.currentEntity = null; 
        this.network.pm.currentGroup = null; 
        this.network.pm.currentMaterial = null;
        if (this._defaultNode.size() > 0) {
            this._defaultNode.forEach(function (node) {
                if (!(node instanceof mono.Light)) {
                    box.add(node);
                }
            });
        }
    },

    addDefaultNode: function (node) {
        if (!node) {
            return;
        }
        var box = this.network.getDataBox();
        if (!(node instanceof mono.Light)) {
            this._defaultNode.add(node);
        }
        box.add(node);
    },

    initLights: function () { // 
        var ambientLight = new mono.AmbientLight(0xFFFFFF);
        // var box = this.network.getDataBox();
        this.addDefaultNode(ambientLight);

        // var pointLight = new mono.PointLight(0xFFFFFF,0.05);                
        // pointLight.setPosition(0,1000,-1000);                              
        // this.addDefaultNode(pointLight);

        // var pointLight = new mono.PointLight(0xFFFFFF,0.05);                
        // pointLight.setPosition(0,1000,1000);                               
        //  this.addDefaultNode(pointLight);

        // var pointLight = new mono.PointLight(0xFFFFFF,0.05);                
        // pointLight.setPosition(1000,-1000,-1000);                          
        //  this.addDefaultNode(pointLight);


        var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(10000, 10000, 10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(-10000, 10000, -10000);
        this.addDefaultNode(pointLight);
        var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(10000, 10000, -10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(-10000, 10000, 10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(0, 0, 10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(0, 0, -10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(10000, 0, 0);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(0, 0, -10000);
        this.addDefaultNode(pointLight);
    },

    addDefaultYRestrict: function () {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        defaultInteraction.yRistrict = true;
        defaultInteraction.yLowerLimitAngle = 0; //-Math.PI/20;
        defaultInteraction.yUpLimitAngle = Math.PI / 4;
        defaultInteraction.minDistance = 200;
        defaultInteraction.maxDistance = 10000;
    },

    removeDefaultYRestrict: function () {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        defaultInteraction.yRistrict = true;
        defaultInteraction.yLowerLimitAngle = -Math.PI / 2;
        defaultInteraction.yUpLimitAngle = Math.PI / 2;
        defaultInteraction.minDistance = 0;
        defaultInteraction.maxDistance = Infinity;
    },

    setDistance: function (minDistance, maxDistance) {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        if (minDistance || minDistance == 0) {
            defaultInteraction.minDistance = 0;
        }
        if (maxDistance) {
            defaultInteraction.maxDistance = Infinity;
        }
    },

    configView: function () {
        // this.initLights(); // remove to lightManager

        //        var networkView = this.network.getView();
        //        if(networkView
        //            && networkView.parentNode
        //            && networkView.parentNode.parentNode
        //            && networkView.parentNode.parentNode == document.body){ //viewparentbodyappendChild,null
        //            mono.Utils.autoAdjustNetworkBounds(this.network,document.documentElement,'clientWidth', 'clientHeight', 0, 35);
        //        }
        var self = this,
            mousedown = false,
            mousemove = false;
        this.network.getRootView().addEventListener('dblclick', function (e) {
            if (!self.enableDBLClick) {
                return;
            }
            var element = self.filterDoubleClickElement(e);
            if (element && self.isHandleDoubleClickable(element.element)) {
                self.handleDoubleClick(element);
            } else if (element && element.element.getClient('bid') == 'unableDBLClick') { //bidunableDBLClickdblclick --loda
                return false;
            } else {
                self.handleDoubleClickBackground();
            }
        });

        this.network.getRootView().addEventListener('click', function (e) {
            if (!self.enableClick) { //clickdatacenterpickerclick
                return;
            }
            var element = self.filterClickElement(e);
            if (element) {
                self.handleClick(element);
            } else {
                self.handleClickBackground();
            }
        });

        this.network.getRootView().addEventListener('mousedown', function (e) {
            mousedown = true;
            mousemove = false;
        });

        this.network.getRootView().addEventListener('mouseup', function (e) {
            mousedown = false;

            if (!self.enableMouseup) { //clickdatacenterpicker,mousemovetooltip
                return;
            }
            e._mousemove = mousemove;
            mousemove = false;
            var element = self.filterMouseMoveElement(e); //picker
            if (element) {
                var node = element.element;
                self.handleMouseUpElement(element, e);
            } else {
                self.handleMouseUpBackground(e);
            }

        });

        this.network.getRootView().addEventListener('mousemove', function (e) {
            mousemove = true;
            if (!self.enableMousemove) { //clickdatacenterpicker,mousemovetooltip
                return;
            }
            e._mousedown = mousedown;
            if (mousedown) {
                return;
            }
            var element = self.filterMouseMoveElement(e); //picker
            if (element) {
                var node = element.element;
                self.handleMouseMoveElement(element, e);
            } else {
                self.handleMouseMoveBackground(e);
            }
        });

        this.setOverLoadMaterial();
        this.setVisibleFunction();
        this.setSelectableFunction();
        this.setNetworkRenderCallback();
    },

    /**
     * Element
     * node,handleDoubleClickhandleDoubleClickBackground
     *         
     */
    isHandleDoubleClickable: function (node) {
        return true;
    },

    getDataByNode: function (node) {
        if (!node) {
            return null;
        }

        var data = this.sceneManager.getNodeData(node);
        if (data == null && node.getParent()) {
            var parent = node.getParent();
            data = this.sceneManager.getNodeData(parent);
            if (data == null && parent.getParent()) {
                data = this.sceneManager.getNodeData(parent.getParent());
            }
        }
        return data;
    },

    setFocusNode: function (node, dealWithVirtual) {
        if (dealWithVirtual == undefined) {
            dealWithVirtual = true;
        }
        if (this._focusNode == node) {
            return;
        }
        var data = this.getDataByNode(node);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId().indexOf('earth') >= 0) { //why
            this._focusNode = null; // nullFloorEarth
            return;
        }
        var oldNode = this._focusNode;
        this._focusNode = node;
        this.isDealWithVirtual = dealWithVirtual;
        this.firePropertyChange("focusNode", oldNode, node);
        this.isDealWithVirtual = true;
    },

    getFocusNode: function () {
        return this._focusNode;
    },

    getDefaultEventHandler: function () {
        return this.defaultEventHandler;
    },

    removeDefaultEventHandler: function () {
        if (this.defaultEventHandler) {
            this.removeEventHandler(this.defaultEventHandler);
            this.defaultEventHandler = null;
        }
    },

    getDefaultVirtualMaterialFilter: function () {
        return this.defaultMaterialFilter;
    },

    removeDefaultMaterialFilter: function () {
        if (this.defaultMaterialFilter) {
            this.removeMaterialFilter(this.defaultMaterialFilter);
            this.defaultMaterialFilter = null;
        }
    },

    getDefaultInteraction: function () {
        return this.network.getDefaultInteraction();
    },

    addMaterialFilter: function (materialFilter) {
        if (!this.includeMaterialFilter(materialFilter)) {
            this._materialFilters.push(materialFilter);
        }
    },

    removeMaterialFilter: function (materialFilter) {
        var index = this._materialFilters.indexOf(materialFilter);
        if (index !== -1) {
            if (materialFilter.destoryBillboard) {
                materialFilter.destoryBillboard(); // materialFilterclearBillboard
            }
            if (materialFilter.destoryParticle) {
                materialFilter.destoryParticle();
            }
            this._materialFilters.splice(index, 1);
        }
    },

    includeMaterialFilter: function (materialFilter) {
        var index = this._materialFilters.indexOf(materialFilter);
        if (index !== -1) {
            return true;
        }
        return false;
    },

    addVisibleFilter: function (visibleFilter) {
        if (!this.includeVisibleFilter(visibleFilter)) {
            this.visibleMap = {};
            this._visibleFilters.push(visibleFilter);
        }
    },

    removeVisibleFilter: function (visibleFilter) {
        var index = this._visibleFilters.indexOf(visibleFilter);
        if (index !== -1) {
            this.visibleMap = {};
            this._visibleFilters.splice(index, 1);
        }
    },

    includeVisibleFilter: function (visibleFilter) {
        var index = this._visibleFilters.indexOf(visibleFilter);
        if (index !== -1) {
            return true;
        } else {
            return false;
        }
    },

    addSelectableFilter: function (selectableFilter) {
        this._selectableFilters.push(selectableFilter);
    },

    removeSelectableFilter: function (selectableFilter) {
        var index = this._selectableFilters.indexOf(selectableFilter);
        if (index !== -1) {
            this._selectableFilters.splice(index);
        }
    },

    addEventHandler: function (eventHandler, index) {
        if (eventHandler instanceof it.EventHandler) {
            if (index === undefined) {
                return this._eventHandlers.push(eventHandler);
            } else {
                return this._eventHandlers.splice(index, 0, eventHandler);
            }
        }
    },

    removeEventHandler: function (eventHandler) {
        var index = this._eventHandlers.indexOf(eventHandler);
        if (index !== -1) {
            this._eventHandlers.splice(index, 1);
        }
    },

    addRenderCallback: function (renderCallback, index) {
        if (this._renderCallbacks.indexOf(renderCallback) >= 0) { //
            return;
        }
        if (renderCallback.onRenderCallback) {
            if (index === undefined) {
                return this._renderCallbacks.push(renderCallback);
            } else {
                return this._renderCallbacks.splice(index, 0, renderCallback);
            }
        }
    },

    removeRenderCallback: function (renderCallback) {
        var index = this._renderCallbacks.indexOf(renderCallback);
        if (index !== -1) {
            this._renderCallbacks.splice(index, 1);
        }
    },

    filterMouseMoveElement: function (event) {
        return this.network.getFirstElementByMouseEvent(event, false);
    },

    handleMouseMoveElement: function (element, event) {
        var node = element.element;
        var data = this.getDataByNode(node);
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            eventHandler.handleMouseMoveElement(node, this.network, data, element, event);
        }
    },

    handleMouseMoveBackground: function (event) {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            eventHandler.handleMouseMoveBackground(this.network, event);
        }
    },

    handleMouseUpElement: function (element, event) {
        var node = element.element;
        var data = this.getDataByNode(node);
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleMouseUpElement(node, this.network, data, element, event)) {
                eventHandler.handleMouseUpElement(node, this.network, data, element, event);
                return;
            }
        }
    },

    handleMouseUpBackground: function (event) {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleMouseUpBackground(this.network, event)) {
                eventHandler.handleMouseUpBackground(this.network, event);
                return;
            }
        }
    },

    /**
     * 
     */
    isFilterVirtualElement: function () {
        return true;
    },

    filterDoubleClickElement: function (event) {
        var filterFunction = null;
        // 
        // var currentScene = this.sceneManager.getCurrentScene();
        // if(currentScene && currentScene.getCategoryId().toLowerCase().indexOf('datacenter')>=0){
        //   filterFunction = function(ele){
        //       if(ele.getClient('type') == 'parkSkybox'){
        //          return false;
        //      }
        //       return true;
        //   }
        // }
        var self = this;
        if (this.isFilterVirtualElement()) {
            filterFunction = function (ele) {
                return self.isVirtual(ele);
            }
        }
        return this.network.getFirstElementByMouseEvent(event, false, filterFunction);
    },

    getFirstElementInIntersectsByMouseEvent: function (intersects, event, intersectUnVisible, filterFunction) {
        var picking = this.network.getPickingByEvent(event);
        var list = intersects;
        if (intersects instanceof mono.List) {
            list = intersects.toArray();
        }
        var objects = picking.intersectObjects(list, false, intersectUnVisible);
        if (objects.length) {
            for (var i = 0; i < objects.length; i++) {
                var first = objects[i];
                var object3d = first.element;
                if (filterFunction == null || filterFunction.call(null, object3d)) {
                    return first;
                }
            }
        }
        return null;
    },

    getAnimation: function (element) {
        var node = element.element ? element.element : element;
        var animation = node.getClient('animation');
        return animation;
    },

    playAnimation: function (element, animation) {
        animation = animation || this.getAnimation(element);
        if (animation) {
            //          mono.AniUtil.playAnimation(element.element || element, animation);
            make.Default.playAnimation(element.element || element, animation);
        }
    },

    filterClickElement: function (event) {
        return this.network.getFirstElementByMouseEvent(event, false);
    },


    handleDoubleClick: function (element) {
        var node = element.element;
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            var data = this.getDataByNode(node);
            if (eventHandler.shouldHandleDoubleClickElement(node, this.network, data, element)) {
                eventHandler.handleDoubleClickElement(node, this.network, data, element);
                return;
            }
        }
        var animation = this.getAnimation(node);
        if (animation) {
            this.playAnimation(node, animation);
        }
    },

    handleClick: function (element) {
        var node = element.element;
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            var data = this.getDataByNode(node);
            if (eventHandler.shouldHandleClickElement(node, this.network, data, element)) {
                eventHandler.handleClickElement(node, this.network, data, element);
                return;
            }
        }
    },

    handleDoubleClickBackground: function () {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleDoubleClickBackground(this.network)) {
                eventHandler.handleDoubleClickBackground(this.network);
                return;
            }
        }
    },

    handleClickBackground: function () {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleClickBackground(this.network)) {
                eventHandler.handleClickBackground(this.network);
                return;
            }
        }
    },

    clearVisibleMap: function () {
        this.visibleMap = {};
        this.network.dirtyNetwork();
    },

    setOverLoadMaterial: function () { // 
        var network = this.network;
        // network.sortOpaqueOrderByMaterial = false; // 2018-01-16true
        var self = this,
            mfs = this._materialFilters;
        network.getOverLoadMaterial = function (node, material) {
            // if (!node.isVisible() || !self.visibleMap[node.getId()]) {
            //    return null;
            // } // update by Kevin 2017-06-09 Visible
            var isVirtual = false;
            var filterdMaterial = null;
            for (var i = 0; i < mfs.length; i++) {
                var mf = mfs[i];
                filterdMaterial = mf.filterMaterial(material, filterdMaterial, node);
                if (mf && mf.isVirtual && mf.isVirtual(node)) {
                    isVirtual = true;
                }
            }
            // if (isVirtual) {
            //    if (node._orgDepthMask == undefined) {
            //       node._orgDepthMask = node.getStyle('m.depthMask');
            //    }
            //    node.setStyle('m.depthMask', false); // Kevin 2018-01-23 network
            // }else{
            //    if (node._orgDepthMask != undefined) {
            //       node.setStyle('m.depthMask', node._orgDepthMask); 
            //    }
            // }
            return filterdMaterial;
        };
    },

    setVisibleFunction: function () {
        var network = this.network;
        var self = this;
        network.isVisible = function (node) {
            /*if (node) {
              if (!node.isVisible()) { //(nodevisible)
                    return false;
              }
              if (self.visibleMap[node.getId()] == true) {
                 return true;
              }else if(self.visibleMap[node.getId()] == false){
                 return false;
              }else{
                if(node instanceof TGL.Link || node instanceof TGL.PathLink){
                      if(!this.isVisible(node._fromNode)){
                          self.visibleMap[node.getId()] = false;
                          return false;
                      }
                      if(!this.isVisible(node._toNode)){
                          self.visibleMap[node.getId()] = false;
                          return false;
                      }
                }
                var vf = self._visibleFilters;
                for(var i = 0;i < vf.length;i ++){
                    var filter = vf[i];
                    if(!filter.isVisible(node,self.getDataByNode(node),network)){ //,filter
                        self.visibleMap[node.getId()] = false;
                        return false;
                    }
                }
              }
            }
            self.visibleMap[node.getId()] = true;
            return true;
            */
            return self.isVisible(node);
        }
    },

    setSelectableFunction: function () {
        var self = this;
        this.network.selectableFunction = function (node) {
            if (node) {
                var sfs = self._selectableFilters;
                if (!sfs || sfs.length < 1) {
                    return true;
                }
                for (var i = 0; i < sfs.length; i++) {
                    var sf = sfs[i];
                    if (!sf.isSelectable(node, self.network)) {
                        return false;
                    }
                }
            }
            return true;
        }
    },

    setNetworkRenderCallback: function () {
        var self = this;
        var rcs = this._renderCallbacks;
        this.network.renderCallback = function () {
            for (var i = 0; i < rcs.length; i++) {
                var renderCallback = rcs[i];
                renderCallback.onRenderCallback(self.network);
            }
        };
    },

    /**
     * nodeminDistance
     */
    _computeMinDistanceByNode: function (node) {
        if (!node) {
            return 0;
        }
        var bb = node.getBoundingBox();
        var minDistance = 0;
        if (bb && bb.size()) {
            minDistance = bb.size().x;
            if (bb.size().y < minDistance) { // add By Kevin 2017-06-08 
                minDistance = bb.size().y;
            }
            if (bb.size().z < minDistance) {
                minDistance = bb.size().z;
            }
            if (minDistance) {
                minDistance += this.network.getCamera().getNear() * 0.6;
            }
        }
        return minDistance;
    },

    getMinDistanceByNode: function (node) {
        var data = this.sceneManager.getNodeData(node);
        if (data && data instanceof $Link) {
            var fromNode = this.sceneManager.getNodeByDataOrId(data.getFromId());
            var toNode = this.sceneManager.getNodeByDataOrId(data.getToId());
            var fromMinDistance = this._computeMinDistanceByNode(fromNode);
            var toMinDistance = this._computeMinDistanceByNode(toNode);
            if (fromMinDistance < toMinDistance) {
                return fromMinDistance;
            } else {
                return toMinDistance;
            }
        }
        return this._computeMinDistanceByNode(node);
    },

    getCameraDistanceByNode: function (lookAtNode) {
        if (!lookAtNode) {
            return null;
        }
        var fov = this.network.getCamera().getFov() || 70;
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) { //defaultInteraction
            return;
        }
        var data = this.sceneManager.getNodeData(lookAtNode);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        var _minDistance = defaultInteraction.minDistance;
        var _maxDistance = defaultInteraction.maxDistance;
        var comNode = lookAtNode.getClient('complexNode');
        if (comNode == 'unload') {
            comNode = this.sceneManager.loadComplexNode(data);
        }
        lookAtNode = comNode || lookAtNode;
        if (!lookAtNode || !lookAtNode.getBoundingBoxWithChildren) { // billboard
            return null;
        }
        var bb = lookAtNode.getBoundingBoxWithChildren();
        var minDistance = this.getMinDistanceByNode(lookAtNode);
        if (!category) { //link
            defaultInteraction.minDistance = minDistance || 200;
            defaultInteraction.maxDistance = 10000;
            return;
        }
        var cId = category.getId().toLowerCase();
        var currentScene = this.sceneManager.getCurrentScene();
        if (cId.indexOf('datacenter') >= 0) {
            var maxDistance = 1500;
            var maxSize = 0
            if (bb && bb.size().x) {
                maxSize = bb.size().x;
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
            }
            if (maxSize > 0) {
                maxDistance = maxSize * Math.atan(Math.PI * (90 - fov / 2) / 360);
            }
            _minDistance = 300;
            _maxDistance = maxDistance; //2000
        } else if (cId.indexOf('building') >= 0) { //buildingfloorsdc
            if (currentScene && currentScene.getCategoryId().toLowerCase().indexOf('building') >= 0) {
                _minDistance = 100;
                _maxDistance = 10000;
            } else {
                var rootNode = this.sceneManager.getCurrentRootNode();
                if (rootNode) {
                    var comNode = rootNode.getClient('complexNode');
                    if (comNode == 'unload') {
                        comNode = this.sceneManager.loadComplexNode(this.sceneManager.getNodeData(rootNode));
                    }
                    rootNode = comNode || rootNode;
                }
                var bb = rootNode ? rootNode.getBoundingBox() : null;
                var maxDistance = 2000;
                if (bb) {
                    var maxLength = bb.size().x;
                    if (bb.size().y > maxLength) {
                        maxLength = bb.size().y;
                    }
                    if (maxLength) {
                        maxDistance = maxLength * Math.atan(Math.PI * (90 - fov / 2) / 180);
                    }
                }
                if (maxDistance == -Infinity) {
                    maxDistance = 2000;
                }
                _minDistance = 200;
                _maxDistance = maxDistance; //2000
            }
        } else if (cId.indexOf('floor') >= 0 || cId.indexOf('channel') >= 0 || cId.indexOf('area') >= 0 || cId.indexOf('room') >= 0) {
            _minDistance = 100;
            _maxDistance = 10000;
            if (bb && bb.size()) { // floor
                var maxSize = 0;
                if (bb.size().x > maxSize) {
                    maxSize = bb.size().x;
                }
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
                if (bb.size().y > maxSize) {
                    maxSize = bb.size().y;
                }
                if (maxSize > 10000) {
                    _maxDistance = maxSize;
                }
            }
        } else if (cId.indexOf('rack') >= 0 || cId.indexOf('equipment') >= 0 || cId.indexOf('card') >= 0) {
            minDistance = this.calcCameraMinDistance(lookAtNode, minDistance);
            _minDistance = minDistance || 50;
            _maxDistance = 500; //1000 update by Kevin 2017-05-26
        } else {
            _minDistance = minDistance || 200;
            _maxDistance = 10000;
        }
        if (currentScene && category && currentScene.defaultInteractionParameters && currentScene.getCategoryId() == category.getId()) {
            var defParams = currentScene.defaultInteractionParameters;
            if (parseInt(defParams.maxDistance)) {
                _maxDistance = parseInt(defParams.maxDistance);
            }
            if (parseInt(defParams.minDistance)) {
                _minDistance = parseInt(defParams.minDistance);
            }
        }
        return { maxDistance: _maxDistance, minDistance: _minDistance };
    },

    calcCameraMinDistance: function (node, minDistance) {
        var bb = node.getBoundingBox();
        if (!bb && !bb.size()) {
            return;
        }
        var x = bb.size().x;
        var y = bb.size().y;
        var z = bb.size().z;
        var arr = [];
        arr.push(parseInt(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))));
        arr.push(parseInt(Math.sqrt(Math.pow(y, 2) + Math.pow(z, 2))));
        arr.push(parseInt(Math.sqrt(Math.pow(x, 2) + Math.pow(z, 2))));
        var near = this.network.getCamera().near;
        arr.push(near);
        arr = arr.sort(function (pre, next) {
            return pre - next
        });
        var max = arr[arr.length - 1];
        if (minDistance < max) {
            minDistance = max + near * 0.2;
        }
        return minDistance;
    },

    /**
     * cameraplayresetCameraDistancesetCameraDistanceForBeforePlayCameresetCameraDistanceForAfterPlayCamere
     * setCameraDistanceForBeforePlayCamereplay lookAt
     * maxDistancecameramaxDistanceminDistancecameraminDistance
     */
    setCameraDistanceForBeforePlayCamere: function (node) {
        if (!this.cameraDistanceRestrict || !node) {
            return;
        }
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        var distanceObj = this.getCameraDistanceByNode(node);
        if (!distanceObj) {
            return;
        }
        var orgMaxDistance = defaultInteraction.maxDistance;
        var orgMinDistance = defaultInteraction.minDistance;
        var minDistance = distanceObj.minDistance;
        var maxDistance = distanceObj.maxDistance;
        if (maxDistance && maxDistance > orgMaxDistance) {
            defaultInteraction.maxDistance = maxDistance;
        }
        if (minDistance && minDistance < orgMinDistance) {
            defaultInteraction.minDistance = minDistance;
        }
        // */ 
        // defaultInteraction.minDistance = 1;
        // defaultInteraction.maxDistance = 20000;
    },

    /**
     * setCameraDistanceForAfterPlayCamere lookAt
     * maxDistancecameramaxDistanceminDistancecameraminDistance
     */
    setCameraDistanceForAfterPlayCamere: function (node) {
        if (!this.cameraDistanceRestrict || !node) {
            return;
        }
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        var distanceObj = this.getCameraDistanceByNode(node);
        if (!distanceObj) {
            return;
        }

        var orgMaxDistance = defaultInteraction.maxDistance;
        var orgMinDistance = defaultInteraction.minDistance;
        var minDistance = distanceObj.minDistance;
        var maxDistance = distanceObj.maxDistance;
        // if (maxDistance && maxDistance < orgMaxDistance) {
        //    defaultInteraction.maxDistance = maxDistance;
        // }
        // if (minDistance && minDistance > orgMinDistance) {
        //    defaultInteraction.minDistance = minDistance;
        // } 
        if (maxDistance) {
            defaultInteraction.maxDistance = maxDistance;
        }
        if (minDistance) {
            defaultInteraction.minDistance = minDistance;
        }
    },

    /**
     * DCDC
     * @param lookAtNode
     */
    resetCameraDistance: function (lookAtNode) {
        if (!this.cameraDistanceRestrict || !lookAtNode) {
            return;
        }
        var fov = this.network.getCamera().getFov() || 70;
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        var data = this.sceneManager.getNodeData(lookAtNode);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        var comNode = lookAtNode.getClient('complexNode');
        if (comNode == 'unload') {
            comNode = this.sceneManager.loadComplexNode(data);
        }
        lookAtNode = comNode || lookAtNode;
        // var bb = lookAtNode.getBoundingBox();
        var bb = lookAtNode.getBoundingBoxWithChildren();
        //minDistance boundingBox
        var minDistance = this.getMinDistanceByNode(lookAtNode);
        if (!category) { //link
            defaultInteraction.minDistance = minDistance || 200;
            defaultInteraction.maxDistance = 10000;
            return;
        }
        var cId = category.getId().toLowerCase();
        var currentScene = this.sceneManager.getCurrentScene();
        if (cId.indexOf('datacenter') >= 0) {
            var maxDistance = 1500;
            var maxSize = 0
            if (bb && bb.size().x) {
                maxSize = bb.size().x;
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
            }
            if (maxSize > 0) {
                maxDistance = maxSize * Math.atan(Math.PI * (90 - fov / 2) / 360);
            }
            defaultInteraction.minDistance = 300;
            defaultInteraction.maxDistance = maxDistance; //2000
        } else if (cId.indexOf('building') >= 0) { //buildingfloorsdc
            if (currentScene &&
                currentScene.getCategoryId().toLowerCase().indexOf('building') >= 0) {
                defaultInteraction.minDistance = 100;
                defaultInteraction.maxDistance = 10000;
            } else {
                var rootNode = this.sceneManager.getCurrentRootNode();
                if (rootNode) {
                    var comNode = rootNode.getClient('complexNode');
                    if (comNode == 'unload') {
                        comNode = this.sceneManager.loadComplexNode(this.sceneManager.getNodeData(rootNode));
                    }
                    rootNode = comNode || rootNode;
                }
                var bb = rootNode ? rootNode.getBoundingBox() : null;
                var maxDistance = 2000;
                if (bb) {
                    var maxLength = bb.size().x;
                    if (bb.size().y > maxLength) {
                        maxLength = bb.size().y;
                    }
                    if (maxLength) {
                        maxDistance = maxLength * Math.atan(Math.PI * (90 - fov / 2) / 180);
                    }
                }
                if (maxDistance == -Infinity) {
                    maxDistance = 2000;
                }
                defaultInteraction.minDistance = 200;
                defaultInteraction.maxDistance = maxDistance; //2000
            }
        } else if (cId.indexOf('floor') >= 0 ||
            cId.indexOf('channel') >= 0 ||
            cId.indexOf('area') >= 0 ||
            cId.indexOf('room') >= 0) {
            defaultInteraction.minDistance = 100;
            defaultInteraction.maxDistance = 10000;
            if (bb && bb.size()) { // floor
                var maxSize = 0;
                if (bb.size().x > maxSize) {
                    maxSize = bb.size().x;
                }
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
                if (bb.size().y > maxSize) {
                    maxSize = bb.size().y;
                }
                if (maxSize > 10000) {
                    defaultInteraction.maxDistance = maxSize;
                }
            }
        } else if (cId.indexOf('rack') >= 0 || cId.indexOf('equipment') >= 0 || cId.indexOf('card') >= 0) {
            defaultInteraction.minDistance = minDistance || 50;
            defaultInteraction.maxDistance = 1000;
        } else {
            defaultInteraction.minDistance = minDistance || 200;
            defaultInteraction.maxDistance = 10000;
        }
        if (currentScene && category &&
            currentScene.defaultInteractionParameters &&
            currentScene.getCategoryId() == category.getId()) {
            var defParams = currentScene.defaultInteractionParameters;
            if (parseInt(defParams.maxDistance)) {
                defaultInteraction.maxDistance = parseInt(defParams.maxDistance);
            }
            if (parseInt(defParams.minDistance)) {
                defaultInteraction.minDistance = parseInt(defParams.minDistance);
            }
        }
    },

    /**
     * minDistancemaxDistance
     */
    setCameraDistance: function (minDistance, maxDistance) {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        if (minDistance != null && minDistance != undefined && parseInt(minDistance)) {
            defaultInteraction.minDistance = parseInt(minDistance);
        }
        if (maxDistance != null && maxDistance != undefined && parseInt(maxDistance)) {
            defaultInteraction.maxDistance = parseInt(maxDistance);
        }
    },

    setSelectedStype: function (nodes, selectColor) {
        if (!nodes) {
            return;
        } else if (nodes instanceof Array && nodes.length < 1) {
            return;
        }
        this.defaultInteractions = this.network.getInteractions();
        var interaction = new mono.DefaultInteraction(this.network);
        interaction.maxDistance = 3000;
        interaction.minDistance = 800;
        this.network.setInteractions([interaction]);
        var selectColor = selectColor || '#0431B4';
        var smodel = this.network.getDataBox().getSelectionModel();
        if (nodes instanceof Array) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                node.s({
                    'm.type': 'phong',
                    'select.style': 'outline.glow',
                    'select.color': selectColor
                });
                smodel.appendSelection(node);
            }
        } else {
            nodes.s({
                'm.type': 'phong',
                'select.style': 'outline.glow',
                'select.color': selectColor
            });
            smodel.appendSelection(nodes);
        }

    },

    //    clearSelectedStyle :function(){
    //        if(this.defaultInteractions){
    //
    //        }
    //    },

    addCameraDistanceRestrict: function () {
        this.cameraDistanceRestrict = true;
    },

    removeCameraDistanceRestrict: function () {
        delete this.cameraDistanceRestrict;
    },

    lookAt: function (node) {
        if (this.defaultEventHandler && this.defaultEventHandler.lookAt) {
            this.defaultEventHandler.lookAt(node);
        }
    },

    setDefaultCamera: function () {
        var camera = this.network.getCamera();
        camera.setNear(50);
        camera.fov = 70;
    },

    /**
     * datanodeSDKnodeisVisiblevisibleFilter
     * @param dataOrNode
     * @returns {*}
     */
    /*
    isVisible : function(dataOrNode){
        if(!dataOrNode){
            return false;
        }
        var data = null;
        if(dataOrNode instanceof it.Data){
            data = dataOrNode;
        }else if(dataOrNode instanceof mono.Element){
            data = this.sceneManager.getNodeData(dataOrNode);
        }else if(typeof(dataOrNode) == 'string'){
            data = this.sceneManager.dataManager.getDataById(dataOrNode);
        }
        if(!data){
            return false;
        }
        var node = this.sceneManager.getNodeByDataOrId(data);
        if(!node){
            return false;
        }
        if(!this._visibleFilters ||  this._visibleFilters.length < 1){
            return node.isVisible();
        }
        for(var i = 0 ; i < this._visibleFilters.length ; i++){
            var vf = this._visibleFilters[i];
            if(vf && !vf.isVisible(node,data,this.network)){
                return false;
            }
        }
        return true;
    },
    */

    isVisible: function (dataOrNode) {
        if (!dataOrNode) {
            return false;
        }
        var data = null;
        var node = dataOrNode;
        if (dataOrNode instanceof it.Data) {
            data = dataOrNode;
            node = null;
        } else if (node instanceof mono.Billboard && node.getClient('_alarmBillboard')) { //billboard
            data = node.getClient('_alarmBillboard');
        } else if (dataOrNode instanceof mono.Element) {
            data = this.sceneManager.getNodeData(dataOrNode);
        } else if (typeof (dataOrNode) == 'string') {
            data = this.sceneManager.dataManager.getDataById(dataOrNode);
            node = null;
        }
        if (!data && !node.getClient('itv_data')) {
            return node.isVisible();
        }
        if (!node) {
            node = this.sceneManager.getNodeByDataOrId(data);
        }
        if (!node) {
            return false;
        }
        if (!node.isVisible()) {
            return false;
        }
        if (this.visibleMap[node.getId()] == true) {
            return true;
        } else if (this.visibleMap[node.getId()] == false) {
            return false;
        } else {
            if (node instanceof TGL.Link || node instanceof TGL.PathLink) {
                if (!this.isVisible.call(this, node._fromNode)) {
                    this.visibleMap[node.getId()] = false;
                    return false;
                }
                if (!this.isVisible.call(this, node._toNode)) {
                    this.visibleMap[node.getId()] = false;
                    return false;
                }
            }
            var vf = this._visibleFilters;
            for (var i = 0; i < vf.length; i++) {
                var filter = vf[i];
                if (!filter.isVisible(node, data, this.network)) { //,filter
                    this.visibleMap[node.getId()] = false;
                    return false;
                }
            }
        }
        this.visibleMap[node.getId()] = true;
        return true;
    },

    /**
     * nodedefaultVirtual
     * @param dataOrNode
     */
    isVirtual: function (dataOrNode) {
        // return this.defaultMaterialFilter.isVirtual(dataOrNode);
        for (var i = 0; i < this._materialFilters.length; i++) {
            var vm = this._materialFilters[i];
            if (vm && vm.isVirtual && vm.isVirtual(dataOrNode)) {
                return false;
            }
        }
        return true;
    }



});

it.ViewManager = $ViewManager;

var $ViewManager2D = function(sceneManager,network){
    mono.PropertyChangeDispatcher.call(this);
    this.sceneManager = sceneManager;
    this.map = null;
    this.network = network;
    if(!network){
      if(window.BMap){
        this.network = new twaver.canvas.Network();
        this.network.setRectSelectEnabled(false);
      }else{
        this.network = new twaver.vector.Network();
      }
    }
    this.container = document.createElement('div');
    this.container.style.position = 'absolute';
    this.mapView = null;
    this._visibleFilters = [];
    this._selectableFilters = [];
    this._eventHandlers = [];
    var self =  this;
    this.dbClickHandle = function (event) {
        if(event){
            var element = self.network.getElementAt(event);
            if(element){
                self.handleDoubleClick({element:element});
            }else{
                self.handleDoubleClickBackground();
            }
        }
    };
    //viewdocument
    this.network.adjustBounds({ x: 0, y: 0, width:1,height:1});
    this.left = 1;
    this.top = 0;
    this.width = document.documentElement.clientWidth;
    this.height = document.documentElement.clientHeight;
    this.adapter = null;
    this.isCreateMap = false;
//    this.createMap();
    this.focusData = null;
    this.isGis = null;
    var box = this.network.getElementBox();
    this.tree = new twaver.controls.Tree(box);
    this.table = new twaver.controls.Table(box);
    this.tableRule = {}; //table,{ID[{column1},{column2},...]}idcategorydatatype,type
    this.treeRule = {}; // tree{id:{}};
//    this.centerSplit,this.mainSplit;
    this.addTableAndTree();
};

mono.extend($ViewManager2D,mono.PropertyChangeDispatcher,{

    /**
     * @param container,divgisdivcontainer
     */
    createMap : function(){
        this.registerNormalImage('./images/building1.png','b1');
        this.registerNormalImage('./images/building2.png','b2');
        this.registerNormalImage('./images/building3.png','b3');
        if(window.BMap){
            var mainView;
          if(!document.getElementById("mainView")){
            mainView = document.createElement('div');
            mainView.id = "mainView";
            mainView.style.height = "100%";
            document.body.appendChild(mainView);
          }else{
            mainView = document.getElementById("mainView");
          }
          
          mainView.appendChild(this.container);
          this.container.style.height = "100%";
          this.container.style.width = "100%";
          this.mapView = document.createElement('div');
          this.mapView.id = "MapView";
          this.mapView.style.height = "100%";
          this.container.appendChild(this.mapView);

          this.map = new BMap.Map("MapView");
          var map = this.map;
          var point = new BMap.Point(108.95, 34.27);
          map.centerAndZoom(point, 7);
          map.addControl(new BMap.NavigationControl());
          map.enableScrollWheelZoom();
          var networkDom = this.network.getView();
          document.getElementsByClassName("BMap_mask")[0].appendChild(networkDom);
          this.network.adjustBounds({x:0,y:0,width:document.documentElement.clientWidth,height:document.documentElement.clientHeight});


          var network = this.network;
          var self = this;
          network.addInteractionListener(function(event) {
              if(event.kind = "liveMoveBetween") {
                  map.disableDragging();
                  var list = network.getSelectionModel().getSelection();
                  list.forEach(function(element) {
                      var pixel = new BMap.Pixel(element.getX(),element.getY());
                      var point = map.pixelToPoint(pixel)
                      // element.setClient("coordinate", point);
                  });

              }
          });
          network.getView().addEventListener("dbclick", function(event) {
              if(network.getElementAt(event)) {
                  map.disableDoubleClickZoom();
                  event.preventDefault();
              } else {
                  map.enableDoubleClickZoom();
              }
          });
          network.getView().addEventListener("mousedown", function(event) {
              if(!network.getElementAt(event)) {
                  map.enableDragging();
              } else {
                  map.disableDragging();
              }
          });
          network.getView().addEventListener("mousedown", function(event) {
              clickPoint = network.getLogicalPoint(event);
          });
          network.getView().addEventListener("mouseup", function(event) {
              clickPoint = null;
          });

          map.addEventListener("movestart", function(){
              networkDom.style.opacity = 0;
          });
          map.addEventListener("moveend", function(){
              networkDom.style.opacity = 1;
              self.changePostionWithMap();
          });
          map.addEventListener("dragstart", function(){
              networkDom.style.opacity = 0;
              self.changePostionWithMap();
          });
          map.addEventListener("dragend", function(){
              networkDom.style.opacity = 1;
              self.changePostionWithMap();
          });
          map.addEventListener("zoomstart", function(){
              networkDom.style.opacity = 0;
              self.changePostionWithMap();
          });
          map.addEventListener("zoomend", function(){
              networkDom.style.opacity = 1;
              self.changePostionWithMap();
          });
          this.isCreateMap = true;
        }else{
            this.mapView = document.createElement('div');
    //        GisManager.registerDefaultSetting(TWaverGisConst.MAPDRIVER_MAPABC,"http://emap3.mapabc.com/mapabc/maptile?");
            var map = this.map = new twaver.gis.Map(this.mapView,"MapView");
            map.setSize({width:document.documentElement.clientWidth,height:document.documentElement.clientHeight});
            map.setEnableDoubleZoom(false); //
            map.addLayer("BINGMAP",GISConsts.EXECUTOR_TYPE_BINGMAP);//MapABCMapABC
            //tiletomcat
            //map.addLayer("google",GISConsts.EXECUTOR_TYPE_MAPABC,"http://localhost:8080/localecache");
            map.setZoomLevel(5);//
            map.setCenter(new twaver.gis.geometry.GeoCoordinate(31.41,121.48));//
            this.adapter = new twaver.gis.Adapter();//
            
            this.isCreateMap = true;
        }
        
    },

    changePostionWithMap:function() {
      if(window.BMap){
        var self = this;
        this.network.getElementBox().forEach(function(element) {
            if(element instanceof twaver.Node) {
                var point = element.getClient("coordinate");
                var pixel = self.map.pointToPixel(point);
                element.setCenterLocation(pixel.x,pixel.y);

            }
        });
      }
    },

    clearContainer : function(){
        var children = this.container.childNodes;
        if(children && children.length > 0){
            for(var i = 0 ; i < children.length ; i++){
                this.container.removeChild(children[i]);
            }
        }
    },

    bindGIS : function(){
        if(this.isGis != null && this.isGis){
            return;
        }
        if(!this.isCreateMap){
            this.createMap();
        }
        if(this.adapter && this.map){
            this.adapter.bindNetworkAndMap(this.network,this.map);
        }
        this.clearContainer();
        this.container.appendChild(this.mapView);
        this.network.getView().removeEventListener("dblclick",this.dbClickHandle);
        if(window.BMap){
            this.map.addEventListener("dblclick",this.dbClickHandle);
        }else{
            this.map.getView().addEventListener("dblclick",this.dbClickHandle);
        }
//        if(!isAdjustBound){ // GIS,gisadjustnodegisnetwork
//            this.adjustViewBounds(parseInt(this.width)+1);
//        }
        this.adjustViewBounds();
        this.isGis = true;
    },

    unbindGIS : function(){
        if(this.isGis != null && !this.isGis){
            return;
        }
        if(this.adapter){
            this.adapter.unbindNetworkAndMap();
        }
        this.clearContainer();
//        if(this.mainSplit){
//            this.container.appendChild(this.mainSplit.getView());
//        }else{
            this.container.appendChild(this.network.getView());
//        }
//        this.network.adjustBounds({ x: this.left, y: this.top, width: this.width, height: this.height});
        //unbindGisadjust2DGisadjust,
        // viewappend,
        // containerparentNodebody,Bodyadjust. 
        if(this.container.parentNode){
            this.adjustViewBounds();
        }
        if(this.map){
            if(window.BMap){
                this.map.removeEventListener("dblclick",this.dbClickHandle);
            }else{
                this.map.getView().removeEventListener("dblclick",this.dbClickHandle);
            }
        }
        this.network.getView().addEventListener("dblclick",this.dbClickHandle);
        this.isGis = false;
    },

    getContainer : function(){
        return this.container;
    },

    removeGis : function(){
            this.unbindGIS();
            this.hideNavigator();
            this.hideOverView();
    },

    addGis : function(showNav,showOverView){
        this.bindGIS();
        if(showNav){
            this.showNavigator();
        }
        if(showOverView){
            this.showOverView();
        }
    },

    /**
     * 2DnetworkbodyadjustBounds
     * networkboundsmapbounds
     * 3Dajdusttwaver
     */
    adjustViewBounds : function(width,height,left,top){
        if(arguments.length < 1){
            if(!this.flag){
                this.flag = 1;
            }else{
                this.flag++
            }
            this.width = this.width + Math.pow(-1,parseInt(this.flag));
        }else{
            this.flag = 0;
        }
        this.left = left || this.left;
        this.top = top || this.top;
        this.width = width || this.width;
        this.height = height || this.height;
//        if(this.container.contains(this.network.getView())){ //adjustnode
            this.network.adjustBounds({ x: this.left, y: this.top, width: this.width, height: this.height});
//        }
        if(this.isCreateMap && this.map){
          if(window.BMap){

          }else{
            this.map.setSize({width:this.width,height:this.height});
            this.map.content.style.left = this.left + 'px';
            this.map.content.style.top = this.top + 'px';
          }
        }
//        this._createNetwork2D = true;
    },

    setZoomLevel : function(zoomLevel){
      if(zoomLevel && this.isCreateMap && this.map){
        if(window.BMap){

        }else{
          this.map.setZoomLevel(5);
        }
      }
    },

    setCenter : function(center){
        if(this.isCreateMap && this.map && center && center.x && center.y){
          if(window.BMap){
            var point = new BMap.Point(center.y, center.x);
            this.map.centerAndZoom(point, 7);
          }else{
            this.map.setCenter(new twaver.gis.geometry.GeoCoordinate(center.x,center.y));
          }
        }
    },

    showNavigator :function(x,y){
        if(!this.isCreateMap) {
            return;
        }
        if(window.BMap){
          return;
        }
        var nav = document.getElementById('navigator_id');
        if(nav){
            nav.style.display = 'block';
        }else{
            var navigator = new twaver.gis.gadget.Navigator("navigator_id",this.map);
            if(!x){
                x = 20;
            }
            if(!y){
                y = 50;
            }
            this.map.installGadget(navigator,{x:x,y:y});
        }
    },

    hideNavigator : function(){
        if(!this.isCreateMap) {
            return;
        }
        var nav = document.getElementById('navigator_id');
//        if(nav && nav.parentElement){
//            nav.parentElement.removeChild(nav);
//        }
        if(nav){
            nav.style.display = 'none';
        }
    },

    showOverView : function(right,bottom,width,height){
        if(!this.isCreateMap) {
            return ;
        }
        if(window.BMap){
          return;
        }
        if(this.overview && this.overview.getView()){
            this.overview.getView().style.display = 'block';
        }else{
            var overview = this.overview = new twaver.gis.gadget.Overview("overview_id",this.map);
            if(width == null || width == undefined || width < 0){
                width = 150;
            }
            if(height == null || height == undefined || height <0){
                height = 150;
            }
            overview.setSize({width:width,height:height});
            overview.map.addLayer("BINGMAP",GISConsts.EXECUTOR_TYPE_BINGMAP);
            overview.setBorder("1px solid red");
            if(right){
                right = right-width+5;
            }else{
                right = width+5;
            }
            if(bottom){
                bottom = bottom - height+5;
            }else{
                bottom = height+5;
            }
            this.map.installGadget(overview,{right:right,bottom:bottom});
        }
    },

    hideOverView : function(){
        if(this.overview && this.overview.getView()){
            this.overview.getView().style.display = 'none';
        }
    },

    registerNormalImage : function (url, name) {
        var self = this;
        var image = new Image();
        image.src = url;
        image.onload = function () {
            twaver.Util.registerImage(name, image, image.width/2, image.height/2);
            image.onload = null;
            self.network.invalidateElementUIs();
        };
    },

    setPosition : function(node,x,y){
        if(!node) return;
        if(this.container.contains(this.mapView)){
            if(window.BMap){
                var point = new BMap.Point(y, x);
                node.setClient("coordinate",point);
                var location = this.map.pointToPixel(point)
                node.setCenterLocation(location.x,location.y);
            }else{
                var geo = new twaver.gis.geometry.GeoCoordinate(parseInt(x)||0,parseInt(y)||0);
                node.setClient(GISSettings.GEOCOORDINATE, geo);
            }
            this.setDefaultImage(node); // test
        }else{
            node.setLocation(parseInt(x)||0,parseInt(y)||0);
        }
    },

    setDefaultImage : function(node,index){
        if(!node) return;
        if(index == 1){
            node.setImage('b1');
        }else if(index == 2){
            node.setImage('b2');
        }else if (index == 3){
            node.setImage('b3');
        }else{
            var i = parseInt(Math.random()*3+1);
            node.setImage('b'+i);
        }
    },

    /**
     * 2D3D
     * @param node
     * @returns {*}
     */
    getDataByNode : function(node){
        if(!node){
            return null;
        }
        return this.sceneManager.getNodeData(node);
    },

    handleDoubleClick : function (element) {
        var node = element.element;
        var i = 0,eventHandler;
        for(; i < this._eventHandlers.length;i ++){
            eventHandler = this._eventHandlers[i];
            var data = this.getDataByNode(node);
            if(eventHandler.shouldHandleDoubleClickElement(node,this.network,data,element)){
                eventHandler.handleDoubleClickElement(node,this.network,data,element);
                this.focusData = data;
                return;
            }
        }
    },

    handleDoubleClickBackground : function(){
        if(this.focusData && this.focusData.getParentId()){
           var parentNode = this.sceneManager.dataNodeMap[this.focusData.getParentId()];
           if(parentNode){
              this.sceneManager.viewManager3d.setFocusNode(parentNode);
           }
        }
        var i = 0,eventHandler;
        for(; i < this._eventHandlers.length;i ++){
            eventHandler = this._eventHandlers[i];
            if(eventHandler.shouldHandleDoubleClickBackground(this.network)){
                eventHandler.handleDoubleClickBackground(this.network);
                return;
            }
        }
    },

    addEventHandler : function(eventHandler,index){
        if(eventHandler instanceof it.EventHandler){
            if(index === undefined){
                return this._eventHandlers.push(eventHandler);
            }else{
                return this._eventHandlers.splice(index,0,eventHandler);
            }
        }
    },

    removeEventHandler : function(eventHandler){
        var index = this._eventHandlers.indexOf(eventHandler);
        if(index !== -1){
            this._eventHandlers.splice(index,1);
        }
    },

    createColumn: function (table, name, propetyName, propertyType, valueType, width) {
        var column = new twaver.Column(name);
        column.setName(name);
        column.setPropertyName(propetyName);
        column.setPropertyType(propertyType); //accessor,client,Styles
        if (valueType) {
            column.setValueType(valueType);
        }
        if(width){
            column.setWidth(width);
        }else{
            column.setClient('pack',true);
        }
        column.renderHeader = function (div) {
            var span = document.createElement('span');
            span.style.whiteSpace = 'nowrap';
            span.style.verticalAlign = 'middle';
            span.style.padding = '1px 2px 1px 2px';
            span.innerHTML = column.getName() ? column.getName() : column.getPropertyName();
            span.setAttribute('title', span.innerHTML);
            span.style.font = 'bold 12px Helvetica';
//            div.style.backgroundColor = '#ffab00';// 'rgba(255,0,0,1)';
            div.style.textAlign = 'center';
            div.appendChild(span);
        };
        table.getColumnBox().add(column);
        return column;
    },

    addTableAndTree : function(){
        var view = this.network.getView();
        var tablePane = new twaver.controls.TablePane(this.table);
        var tableHeader = tablePane.getTableHeader().getView();
        tableHeader.style.backgroundColor = 'rgba(255,255,255,0.1)';
        var tableDom = tablePane.getView();
        tableDom.style.position = 'absolute';
        tableDom.style.bottom = '30px';
        tableDom.style.left = '400px';
        tableDom.style.width = "500px";
        tableDom.style.height = "120px";
        view.appendChild(tableDom);

        var treeView = this.tree.getView();
        treeView.style.position = 'absolute';
        treeView.style.top = '30px';
        treeView.style.left = '30px';
        treeView.style.width = "160px";
        treeView.style.height = "250px";
        view.appendChild(treeView);

        this.tree.getToggleImage = function (data) {
            if (data.getChildrenSize()>0) {
                return this.isExpanded(data) ?  '../images/collapse_icon.png':'../images/expand_icon.png';
            }
            return null;
        };

        this.tree.getIcon = function (data) { return null; };

    },

    /**
     * tablescenescenetable
     * @param scene
     */
    initTable : function (scene) {
        this.table.setEditable(true);
        this.createColumn(this.table,'', 'toolTip', 'accessor', 'string').setWidth(80);
        var column = this.createColumn(this.table, '', 'toId', 'client', 'string', true);
        column.setWidth(150);
        this.createColumn(this.table, '', 'flow', 'client', 'string', true).setWidth(120);
        var timeColumn = this.createColumn(this.table, '', 'raisedTime', 'client','Date');
        timeColumn.setWidth(150);
        timeColumn.setHorizontalAlign('center');
        timeColumn.renderCell = function (params) {
            var span = document.createElement('span');
            span.innerHTML = it.Util.formatDate(params.value, 'yyyy-MM-dd hh:mm:ss');
            span.style.whiteSpace = 'nowrap';
            params.div.appendChild(span);
        }
    },

    refreshTable : function(){
        var view = this.network.getView();
        var tablePane = new twaver.controls.TablePane(this.table);
        var tableHeader = tablePane.getTableHeader().getView();
//        tableHeader.style.backgroundColor = 'rgba(255,255,255,0.1)';
        var tableDom = tablePane.getView();
        tableDom.style.position = 'absolute';
        tableDom.style.bottom = '30px';
        tableDom.style.left = '400px';
        tableDom.style.width = "500px";
        tableDom.style.height = "120px";
        view.appendChild(tableDom);
    },

    showTable : function(scene){
        this.table.getColumnBox().clear();
//        if(this.sceneManager._currentScene.getTwod()){
            this.table.getView().style.display = 'block';
            this.table.setVisibleFunction(function(node){
                if(node.getName()){
                    return false;
                }
                if(!node.getName() && !node.getToolTip()){
                    return false;
                }
                if(node.getClient('group_id')){
                    return false;
                }
                return true;
            });
            this.initTable(scene);
            this.refreshTable();
//        }else{
//            this.table.getView().style.display = 'none';
//        }
    },

    showTree : function(scene){
//        if(this.sceneManager._currentScene.getTwod()){
            this.tree.getView().style.display = 'block';
            this.tree.setLineType('dotted');// solid
            this.tree.setLineColor('#000000');// #ffab00
            this.tree.setLineAlpha(1);//
            this.tree.setLineThickness(0.5);//
            this.tree.setLineDash([1,1]);
            this.tree.setVisibleFunction(function(node){
                if(!node.getName() && !node.getToolTip()){
                    return false;
                }
                return true;
            });
            this.tree.getLabel = function(data){
                return data.getToolTip() || data.getName();
            };
            this.tree.expandAll();
//        }else{
//            this.tree.getView().style.display = 'none';
//        }
    },

});

it.ViewManager2D =$ViewManager2D;


// dataManager3DviewManagerNetwork
// ;
// Scene.js;

it.SceneManager = function (dataManager) {
    $Util.checkNotNull(dataManager, "dataManager");
    $EventHandler.call(this);
    this.dataManager = dataManager;
    this.initViewManager();
    this.network3d = this.viewManager3d.network;
    this.network2d = this.viewManager2d && this.viewManager2d.network;
    this.prefabMap = {}; // 
    this.dataNodeMap = {};
    this.dataNode2DMap = {}; // dataNodeMap2D
    this.linkMap = {};
    this.categoryNodeMap = {};
    this.assetTypeNodeMap = {};
    this.locationManager = new it.LocationManager(this); // TODO
    // 
    this._sceneManagerChangeDispatcher = new mono.EventDispatcher();
    this._sceneChangeDispather = new mono.EventDispatcher();
    this._sceneVirtualChangeDispather = new mono.EventDispatcher();//
    this._sceneVisibleChangeDispather = new mono.EventDispatcher();
    this._scenes = [];
    this._sceneMap = []; 
    this._sceneNodeMap = {}; //
    this._sceneNodes = [];
    this.cameraManager = new $CameraManager(this);
    this.viewManager3d.initDefault();
    this._linkTemplateMap = {};
    var AlarmManagerClass = this.getAlarmManagerClass();
    this._alarmManager = new AlarmManagerClass(this.dataManager, this);
    this.doubleClickBackgroundGotoUpLevelScene = false;
    this.linkControlsFunction = function(link,fromNode,toNode){
        var bb1 = fromNode.getBoundingBox(),bb2 = toNode.getBoundingBox();
        var maxZ = 20, maxY = Math.max(bb1.max.y,bb2.max.y) ;
        var pos1 = fromNode.frontWorldPosition(bb1.max.z + maxZ),pos2 = toNode.frontWorldPosition(bb2.max.z + maxZ);
        var controls = [];
        controls.push(pos1);
        controls.push(pos1.clone().add(new mono.Vec3(0,maxY,0)));
        controls.push(pos2.clone().add(new mono.Vec3(0,maxY,0)));
        controls.push(pos2);
        return controls;
    };
    this.gcsManager = new it.GCSManager({sceneManager:this});
    this.postManager = new $PortManager(this);
    this.beforeLoadSceneFunction = null;
    this.afterLoadSceneFunction = null;
    this.isBindingBuildingAndFloor = true; //floorbuilding
    this.sceneChangeWithOutAnimate = false;
    this.resetCameraWhenSceneChange = true; 
    
    this.lightManager = new $LightManager(this);
    // this.cameraManager = new $CameraManager(this);
    this.adapterManager = new $PropertyChangeAdaperManager(this);
    this.invisibleFilter = new it.VisibleManager(this);
    this.viewManager3d.addVisibleFilter(this.invisibleFilter);
    this.sceneViewMap = {};
    this._focusNode = null;
    this.isClearCache = false;

    var self = this;
    dataManager.addDataManagerChangeListener(function(event){
       if(self._loaded){
          var kind = event.kind;
          if(kind === 'add'){
             self.handleDataAdd(event);
          }else if(kind === 'remove'){
             self.handleDataRemove(event);
          }
       }
    });

    dataManager.addDataPropertyChangeListener(function(event){
        if(self._loaded){
           self.handleDataPropertyChange(event);
        }
    });

    this.removeAndAddAllChildrenWhenSetFocusFilter = null;

    this.addSceneChangeListener(function(eve){
        // self.setSceneNetworkAndLight(eve.data);
        self.setDefaultInteractionValue(eve.data);
    });

};
it.SceneManager.CLIENT_IT_DATA = 'it_data';
it.SceneManager.CLIENT_IT_DATA_ID = 'it_data_id';
//nodeiddata
//nodeCLIENT_EXT
it.SceneManager.CLIENT_EXT_VITUAL = 'it_extend_virtual_node';
it.SceneManager.CLIENT_EXT_VISIBLE = 'it_extend_visible_node';

it.SceneManager.getNodeData =function(node){
    return node.getClient(it.SceneManager.CLIENT_IT_DATA);
},

it.SceneManager.getNodeDataId = function(node){
    if(!node){
        return null;
    }
    return node.getClient(it.SceneManager.CLIENT_IT_DATA_ID);
},

mono.extend(it.SceneManager,$EventHandler,{

	  getSceneView : function(sceneCategory){
          // if(show2D){
              //View3D2Dnetwork3D
          var mainView ;
          if(!document.getElementById("mainView")){
              mainView = this.mainView = document.createElement('div');
              mainView.id = 'mainView';
          }else{
              mainView = this.mainView = document.getElementById("mainView");
              // mainView.appendChild(this.network3d.getRootView());
          }

          if (sceneCategory 
              && this.sceneViewMap[sceneCategory] 
              && this.sceneViewMap[sceneCategory].getContainer()) {
               mainView.appendChild(this.sceneViewMap[sceneCategory].getContainer());
               this.network3d.getRootView().style.display = 'none';
          }

          // var earthSceneView = this.sceneViewMap['earth'];
          // if (earthSceneView && earthSceneView.getContainer()) {
          //     mainView.appendChild(earthSceneView.getContainer());
          // }
          mainView.appendChild(this.network3d.getRootView());
          // this.network3d.getRootView().style.display = 'none';
          if (this.viewManager2d) {
             mainView.appendChild(this.viewManager2d.getContainer());
          };
          return mainView;
          // }else{
          //     return this.network3d.getRootView();
          // }
	  },

    /**
     * 2DnetworkbodyadjustBounds
     */
    adjust2DBounds : function(width,height,left,top){
        this.viewManager2d&&this.viewManager2d.adjustViewBounds(width,height,left,top);
    },

    adjust3DBounds : function(w, h, left, top) {
        if(!w){
            w = document.documentElement.clientWidth;
        }
        if(!h){
            h = document.documentElement.clientHeight;
        }
        left = left || 0;
        top = top || 0;
        this.network3d.adjustBounds(w - left, h - top);
        var self = this;
        if (window.addEventListener) {
            window.addEventListener('resize', function () {
                self.network3d.adjustBounds(w - left, h - top, top, left);
            }, true);
        } else if (window.attachEvent) {
            window.attachEvent('onresize', function () {
                self.network3d.adjustBounds(w - left, h - top, top, left);
            });
        } else {
            window.onresize = function () {
                self.network3d.adjustBounds(w - left, h - top, top, left);
            };
        }
    },

    /**
     * -Boxbox
     * @param node
     */
    removeAndAddAllChildrenWhenSetFocus : function(node){
        if(this.removeAndAddAllChildrenWhenSetFocusFilter){
            return this.removeAndAddAllChildrenWhenSetFocusFilter(node);
        }
        if(!node) return false;
        var data = this.getNodeData(node);
        if(data){
            var category = this.dataManager.getCategoryForData(data);
            if(category && category.getId() && category.getId().toLowerCase().indexOf('rack') >= 0 ){
                return true;
            }
        }
        return false;
    },

    isChild : function(parentNode,childNode){
        if(!parentNode || !childNode){
            return false;
        }
        var pdata = this.getNodeData(parentNode);
        if(!pdata) {
            return false;
        }
        var cdata = this.getNodeData(childNode);
        if(!cdata || !(cdata instanceof $Data)){
            return false;
        }
        if(cdata.getParentId() && cdata.getParentId() === pdata.getId()){
            return true;
        }
        return false;
    },

    adjustBounds : function(width,height,left,top){
        this.adjust2DBounds(width,height,left,top);
        this.adjust3DBounds(width,height,left,top);
    },

    getDataBox : function(){
      var sceneView = this.getCurrentSceneView();
      if (sceneView && sceneView.getNetwork3D()) {
        return sceneView.getNetwork3D().getDataBox();
      }
      return this.network3d.getDataBox();
    },

    getDataBox2d : function(){
        return this.network2d.getElementBox();
    },

    setDefaultInteractionSpeed : function(rotateSpeed,panSpeed,zoomSpeed){
        var defaultInteraction = this.network3d.getDefaultInteraction();
        if(!defaultInteraction){
          return;
        }
        defaultInteraction.setRotateSpeed(rotateSpeed);
        defaultInteraction.setPanSpeed(panSpeed);
        defaultInteraction.setZoomSpeed(zoomSpeed);
    },

    shouldHandleDoubleClickBackground : function(network){
        
        if(!this.doubleClickBackgroundGotoUpLevelScene){    // 
          return false;
        }
        if(!this.dataManager.getRootScene()){
          return false;
        }
        if(this._currentScene === this.dataManager.getRootScene()){
          return false;
        }
        if(network instanceof mono.Network3D){
            var focusNode = this.viewManager3d.getFocusNode();
            //focusNodelookAt
            if(focusNode){
                focusNode = this.getMainNode(focusNode);
                if(this._currentRootNode !== focusNode){
                    return false;
                }
            }
        }
        return true;
    },
 
    handleDoubleClickBackground : function(network){
        this.gotoUpLevelScene();
    },

    shouldHandleDoubleClickElement : function(element,network,data,clickedObj){
       var dm = this.dataManager;
       if(!dm.getRootScene()){
         return false;
       }
        if(element.doubliClick){
            return true;
        }
       if(!data){
         return false;
       }
       var scene = null;
       var lastSceneAndRootData = this.getSceneAndRootByData(data);
       if (lastSceneAndRootData) {
          scene = lastSceneAndRootData.scene;
       }
       if(scene && this._currentScene != scene){
         return true;
       }
       return false;
    },

    handleDoubleClickElement : function(element,network,data,clickedObj,callback){
        var dm = this.dataManager;
        var lastSceneAndRootData = this.getSceneAndRootByData(data);
        var scene = lastSceneAndRootData.scene;
        var rootData = lastSceneAndRootData.rootData||data;
        var dataNode = this.getNodeByDataOrId(rootData);
        var doubliClick = element.doubliClick || (dataNode?dataNode.doubliClick:null);
        if(doubliClick){
            return doubliClick(element,network,data,clickedObj,callback);
        }
        if(this._currentScene == scene){
            callback && callback();
            return;
        }
        this.toScene(scene,rootData,callback);
        if (rootData) {
            this.viewManager3d.setFocusNode(this.dataNodeMap[rootData.getId()]);
        }
    }, 

    /**
     * 
     * 
     * 
     */
    clearCache : function(scene,rootData){
        scene = scene || this._currentScene;
        rootData = rootData || this._currentRootData;
        // dataNodeMap
        if (scene && rootData) {
          for (var id in this.dataNodeMap) {
             var dataNode = this.dataNodeMap[id];
             var nodeData = this.getNodeData(dataNode);
             var dataType = this.dataManager.getDataTypeForData(nodeData);
             if (dataType && dataType.getModel()) {
                var model = dataType.getModel().replace('twaver.idc.','').replace('twaver.meeting.',''); //dcdc 2017-10-13
                if (make.Default._objObject[model]) {
                  delete make.Default._objObject[model];
                }
                if (make.Utils3D._objObject[model]) {
                   delete make.Utils3D._objObject[model];
                }
             }
             // var sceneAndRootData = this.getSceneAndRootByData(this.getNodeData(dataNode));
             // if (sceneAndRootData 
             //    && sceneAndRootData.scene == scene 
             //    && sceneAndRootData.rootData == rootData) {
             if (scene 
                 && scene.getCategoryId() != 'earth' // 
                 && this.isSceneInstance(scene,rootData,nodeData)) {
                  continue;
             }else{
                delete this.dataNodeMap[id];
             }
          }
        }else{
           this.dataNodeMap = {};
        }
        for(var name in make.Default._objMap){
           make.Default._objMap[name] = [];
        }//obj

        this.prefabMap = {};
        //nodeMap
        this._sceneNodes = [];
        this._sceneNodeMap = {};
        //categoryMap
        // for(var id in this.categoryNodeMap){
        //    delete this.categoryNodeMap[id];
        // }
        this.categoryNodeMap = {};
        //assetTypeNodeMap
        // for(var id in this.assetTypeNodeMap){
        //   delete this.assetTypeNodeMap[id;]
        // }
        this.assetTypeNodeMap = {};
        //billboard
        var datas = this.dataManager._datas
        for (var i = 0; i < datas.length; i++) {
           var boards = datas[i].boards; 
           if (boards && (boards instanceof Array)){
              for(var k = 0 ; k < boards.length ; k++){
                  var board = boards[k];
                  if (board) {
                    board.setParent(null);
                  }
              }
              delete datas[i].boards;
           } 
        }
        //Map
        this._alarmManager._alarmBillboardMap = {};
        this._alarmManager._alarmNodeMap = {};
    },

    clear : function(scene,root){
        this.beforeClearFunction && this.beforeClearFunction();
        var nodes = new mono.List();
        for (var id in this.dataNodeMap) {
            var node = this.dataNodeMap[id];
            if (node) {
                node.setParent(null);
                nodes.add(node);
            }
        }
        this.viewManager3d.clear();
        this.getDataBox2d().clear();
        this.clearSceneNodeMap();
        this._sceneManagerChangeDispatcher.fire({
            kind:'clear',
            datas:nodes
        });
        if (this.isClearCache) {
           this.clearCache(scene,root);
        }
    },

    getCurrentScene : function(){
      return this._currentScene;
    },

    getParentScene : function(data){
        if(!data) return null;
        var parentData = this.dataManager.getParent(data);
        if (!parentData) {
            return null;
        }
        var category = this.dataManager.getCategoryForData(parentData);
        if (!category) {
            return this.getParentScene(parentData,this);
        }
        var parentScene = this.dataManager.getSceneByCategory(category);
        if (!parentScene) {
            return this.getParentScene(parentData,this);
        }else{
            return {scene:parentScene,data:parentData};
        }
    },

    gotoUpLevelScene : function(){
        var scene = this._currentScene;
        if(!scene) return false;
        if(scene.getTwod()){
            this.clear();//3D
            this.gotoUpLevelSceneFor2D();
        }else{
            this.gotoUpLevelSceneFor3D();
        }
    },

    /**
     * clearloadOneScene
     * sceneclear
     * clear
     * @param scene
     * @param data
     */
    toScene : function(scene,data,callback,clientMap){
        if(!scene){
            return;
        }
        var self = this;
        var action = function(){
           self.clear(scene,data);
           self._loadOneScene(scene,data,callback,clientMap);
        }
        this.beforeLoadSceneAnimate(scene,data,this._currentScene,this._currentRootData,action,this);
    },
    
    /**
     * 
     */
    gotoScene : function(scene, data, callback,clientMap){
        if(!scene) {
            callback && callback('scene is null');
            return;
        }
        if(scene == this._currentScene){ //
            var rootData = this.getNodeData(this._currentRootNode);
            if(data && rootData && data == rootData){
                callback && callback('scene is current scene, no change');
                return ;
            }
        }
        this.toScene(scene,data, callback,clientMap);
        if (data && !scene.getTwod()) {
            // this.viewManager3d.setFocusNode(this.dataNodeMap[data.getId()]);
            this.setFocusNode(this.dataNodeMap[data.getId()]); // 2017-08-11
        }
    },

    /**
     * 2D(2D)scenescenelookat
     */
    gotoUpLevelSceneFor2D : function(){
        var scene = this._currentScene;
        if (!scene) {
            return false;
        }
        var rootNode = this._currentRootNode;
        if (!rootNode) {
            return false;
        }
//        var lookAt = rootNode; // 2Dfocus3Dfocus(:dcuptodc)
        var data = this.getNodeData(rootNode);
        var sceneObj = this.getParentScene(data);
        if(sceneObj && sceneObj.scene && sceneObj.data){
            var self = this;
            var callback = function(){
//                if(lookAt){
                    var lookAtData = self.getNodeData(rootNode);
                    if(lookAtData && lookAtData.getParentId()){
                        var parentNode = self.dataNodeMap[lookAtData.getParentId()];
                        var box3D = self.network3d.getDataBox();
//                getFocusdc
                        //lookAtRootNode,
                        if(!parentNode //box
                            || !box3D.getDataById(parentNode.getId())){
                            self.loadLazyData(lookAtData.getParentId());
                            parentNode = self.dataNodeMap[lookAtData.getParentId()];
                        }
                        if(parentNode){
                            self.viewManager3d.lookAt(parentNode);
                        }
                    }
//                }
            };
            this.toScene(sceneObj.scene, sceneObj.data);
            callback();
        }
        this.afterGotoUpLevelScene(data,scene,sceneObj.data,sceneObj.scene);
    },

    /**
     * 
     * 
     */
    afterGotoUpLevelScene : function(oldData,oldScene,data,scene){

    },

    /**
     * datadataparentData
     */
    getUpLevelDataByData : function(data){
       if (!data) {
          return null;
       }
       return this.dataManager.getParent(data);
    },

    gotoUpLevelSceneFor3D : function(){
        var scene = this._currentScene;
        if (!scene) {
            return false;
        }
        var rootNode = this._currentRootNode;
        var rootData = this._currentRootData;
        if (!rootNode && !rootData) {
            return false;
        } 

        var data = this.getNodeData(rootNode);
        if (!data) {
          data = rootData;
        }
        // var parentData = this.dataManager.getParent(data);
        var parentData = this.getUpLevelDataByData(data);
        if (!parentData) {
            return false;
        }
        var parentScene = this.getSceneAndRootByData(parentData);
        if(!parentScene){
            return false;
        }
        this.gotoScene(parentScene.scene, parentScene.rootData); //
        this.afterGotoUpLevelScene(data,scene,parentData,parentScene);
        return true;
    },

    gotoData : function(dataOrId){
      var dm = this.dataManager;
      var data = dataOrId;
      if(!(typeof dataOrId === $Data)){
         data = dm.getDataById(dataOrId);
      }
      if(!data){
        return false;
      }
      var category = dm.getCategoryForData(data);
      if(!category){
        return false;
      }

      var scene = this.dataManager.getSceneByCategory(category);
      if(!scene){
        return false;
      }
        this.toScene(scene,data);
        var dataNode = null;
        if (data) {
            dataNode = this.dataNodeMap[data.getId()];
        }
        // this.viewManager3d.setFocusNode(dataNode);
        this.setFocusNode(dataNode); //2017-08-11
        return true;
    },

    initViewManager : function(){
        this.viewManager3d = new it.ViewManager(this);
        this.viewManager3d.addEventHandler(this);
        if (it.ViewManager2D) {
           this.viewManager2d = new it.ViewManager2D(this);
           this.viewManager2d.addEventHandler(this);
        }
    },

    removeNodeChildren : function(dataOrNodeOrId,filterFunction){
       var node = dataOrNodeOrId;
       if(dataOrNodeOrId instanceof $Data || typeof dataOrNodeOrId === 'string'){
         node = this.getNodeByDataOrId(dataOrNodeOrId);
       }
       var box = this.getDataBox();
       var children = node.getChildren().toList();

       children.forEach(function(child){
          if(!filterFunction || filterFunction(child)){
              child.setParent(null);
              box.removeByDescendant(child);
          }
       });
    },

    setNodeData : function(data,node,root){
        if(!node) return ;
        // add 2017-11-06 nodeparent
        if (node.getClient(it.SceneManager.CLIENT_IT_DATA) 
            && node.getClient(it.SceneManager.CLIENT_IT_DATA_ID)) {
              return ;
        }
       node.setClient(it.SceneManager.CLIENT_IT_DATA,data);
       node.setClient(it.SceneManager.CLIENT_IT_DATA_ID,data.getId());
        if(!root){
            root = node;
            node.setClient('modelParent',null);
        }else{
            node.setClient('modelParent',root);
        }
        var complexNode = node.getClient('complexNode');
        if(complexNode && complexNode != 'unload'){
          this.setNodeData(data,complexNode,root);
        }
        var self = this;
        if(node.getChildren() && node.getChildren().size() > 0 ){// 
            node.getChildren().forEach(function(child){
                self.setNodeData(data,child,root);
            });
        }
    },

    getMainNode : function(node){
        if(!node) return;
        if(node.getClient(it.SceneManager.CLIENT_IT_DATA) == null){
            node = node.getParent();
        }
        return this.getNodeByDataOrId(this.getNodeData(node));
    },

    getParentNode : function(data){
       var parentId = data.getParentId();
       if(parentId){
        return this.dataNodeMap[parentId];
       }
       return null;
    },

    getChildrenNodes : function(nodeOrData,dataTypeId){
      var data = nodeOrData;
      if(nodeOrData instanceof mono.Node){
        data = this.getNodeData(node);
      }
      var children,i = 0,nodes = [];
      if(data){
        children = this.dataManager.getChildren(data,dataTypeId);
        for(i = 0;i < children.length;i ++){
            nodes.push(this.getNodeByDataOrId(children[i]));
        }
      }

      return nodes;
    },

    getNodeData : function(node){
        if(!node || !node.getClient) return null;
       return node.getClient('it_data');
    },

    getNodeByDataOrId : function(dataOrId){
        if(!dataOrId) return null;
        var id = dataOrId.getId ? dataOrId.getId() : dataOrId;
        return this.dataNodeMap[id];
    },

    getNodeForDataOrId : function(data){
        if(!data) return null;
        var id = data.getId ? data.getId() : data;
        return this.dataNodeMap[id];
    },

    loadModel: function(model,params,prefabAble,prefabId,callback){
        var params = JSON.parse(JSON.stringify(params));
        var node = null;
        if(prefabAble && prefabId){
           node = this.prefabMap[prefabId];
           if(node && node.clonePrefab){
              node = node.clonePrefab();
           }
        }
        if(!node){
            params = params || {};
            params.type = params.type || model;
            var id = model || params.type;
            if(!id){
                return null;
            }
            var obj = {};
            if(params instanceof Array){
                obj.data = params;
                obj.id = id;
            //
            }else if(id === 'twaver.loader'){
                obj.id = id;
                obj.data = params;
            }else{
                obj = params || {};
                obj.id = id;
            }
            var prefaNode = make.Default.load(obj,callback);
            if(!prefaNode){
                return null;
            }
            if(prefabAble && prefabId && id != 'twaver.loader'){
               this.prefabMap[prefabId] = prefaNode;
               node = prefaNode.clonePrefab();
            }else{
              node = prefaNode;
            }
            // if (prefaNode && prefaNode.clonePrefab) {
            //   node = prefaNode.clonePrefab();
            // }else {
            //   node = prefaNode;
            // }
        }
        return node;
    },

    loadDataTypeTemplateModels : function(dataType,parentData,onLoadFinish) {
        var templateDatas = dataType.getTemplateDatas();
        if(templateDatas == null || templateDatas.length == 0){
            return;
        }
        var self = this;
        templateDatas.forEach(function(data){
            data = self._translateTemplateData(data,parentData)
            var parentNode = self.dataNode2DMap[parentData.getId()];
            var node = self.loadDataModel2D(data,onLoadFinish)
            if (node) {
               node.setMovable(false);
               node.setHost(parentNode);
               node.setParent(parentNode);
               node.setName("");
            }
        });
    },

    _loadDataModeCallback : function(data,node,onLoadFinish){
          var dm = this.dataManager,
          box = this.network3d.getDataBox();
          var id = data.getId();
          var assetType = dm.getDataTypeForData(data);
          var category = dm.getCategoryForData(data);
           box.addByDescendant(node);
           if (!this.dataNodeMap[id] && this.afterFirstLoadDataModelFunction) {
              this.afterFirstLoadDataModelFunction(data, node); //dataNode
           }
           this.dataNodeMap[id] = node;
           var temp = this.assetTypeNodeMap[assetType.getId()];
           if(!temp){
              temp = {};
              this.assetTypeNodeMap[assetType.getId()] = temp;
           }
           temp[id] = node;
           if(category){
              temp = this.categoryNodeMap[category.getId()];
              if(!temp){
                temp = {};
                this.categoryNodeMap[category.getId()] = temp;
              }
              temp[id] = node;
           }
           this.setNodeData(data,node);
           this.addToSceneNodeMap(data,node);
           if (onLoadFinish) {
              onLoadFinish(node);
           }
           this._sceneManagerChangeDispatcher.fire({
               kind:'add',
               data:node
           });
    },

    /**
     * data3D
     * @includeInvisible (categoryvisible)
     *
     */
    loadDataModel : function(data,includeInvisible,onLoadFinish){
       var dm = this.dataManager;
       var dataType = dm.getDataTypeForData(data);
       var category = dm.getCategoryForData(data);
       if (category && !category.isVisible()) { 
            this.invisibleFilter.setVisible(data,false); // load,load
            if (!includeInvisible) {
               return;
            }
       }
       var self = this,
           box = this.network3d.getDataBox(),
           id = data.getId();
       var node = this.dataNodeMap[id];
       var parameters = dataType.getModelParameters();
       var params = parameters;
       var prefabAble = dataType.isPrefabAble(),simplePrefabAble = dataType.isSimplePrefabAble();
       var simpleModel = dataType.getSimpleModel();
       var simpleModelParameters = dataType.getSimpleModelParameters();
       if(node){
          this._loadDataModeCallback(data,node,onLoadFinish);
       }else{
          var simpleNode;
          if(simpleModel){
              simpleNode = this.loadModel(simpleModel,simpleModelParameters,simplePrefabAble,dataType.getId() + '_simple');
          }
          if(simpleNode){
              // var boundingBox = node.getBoundingBoxWithChildren();
              var boundingBox = simpleNode.getBoundingBoxWithChildren && simpleNode.getBoundingBoxWithChildren();
              var size = {x:1,y:1,z:1} ; 
              if(boundingBox){
                size = boundingBox.size();
              }
              var fakeNode = new mono.Cube(size.x,size.y,size.z);
              fakeNode.s({
                'm.visible' : false
              });
              simpleNode.setParent(fakeNode);
              fakeNode.setClient("simpleNode",simpleNode);
              fakeNode.setClient("complexNode","unload");
              // fakeNode.setClient("complexNode",node);
              // callback(fakeNode);
              this._loadDataModeCallback(data,fakeNode,onLoadFinish);
          }else{
              // callback(node); 
              // this._loadDataModeCallback(data,node,onLoadFinish);
              this.loadComplexNode(data,onLoadFinish);
          }
       }
    },

    /**
     * 
     * 1(fakeNode)relactionposition
     *             2
     * obj
     */
    loadComplexNode : function(data,callback){
        if (!data) {
            callback&&callback(null);
            return null;
        }
        var dataNode = this.dataNodeMap[data.getId()];
        if (dataNode) {
           var complexNode = dataNode.getClient('complexNode');
           // if (!complexNode || complexNode != 'unload') {
          if (complexNode && complexNode != 'unload') { // 2017-10-31
              callback&&callback(complexNode);
              return complexNode;
           }
        }
        var dm = this.dataManager;
        var self = this;
        var dataType = dm.getDataTypeForData(data);
        var params = dataType.getModelParameters();
        var prefabAble = dataType.isPrefabAble(),simplePrefabAble = dataType.isSimplePrefabAble();
        
        var complexNode = this.loadModel(dataType.getModel(),params,prefabAble,dataType.getId()); // callback
        if(!complexNode) {
            this.loadModel(dataType.getModel(),params,prefabAble,dataType.getId(),function(node){
                if (self.dataNodeMap[data.getId()]) { 
                    return ;
                }
                if(node && node instanceof Array){
                   for(var i = 1 ; i < node.length ; i++){
                      console.log('load a lots of model');
                      node[i].setParent(node[0]); //
                   }
                   node = node[0];
                }
                if (dataNode) {
                   dataNode.setClient('complexNode',node);
                   self.setNodeData(data,node,dataNode);
                   callback&&callback(node);
                }else{
                    if (self.isCurrentSceneInstance(data)) { //
                        self._loadDataModeCallback(data,node,null);
                        self.setRelationShipAndPosition(data); //
                        callback&&callback(node);
                    }else{
                       // 
                       callback&&callback(node); // 2018-01-04 kevin callback
                    }
                }
            });
            return null;
        }else{
           if (complexNode instanceof Array) {
              for(var i =1 ; i< complexNode.length ; i++){
                complexNode[i].setParent(complexNode[0]);
              }
              complexNode = complexNode[0];
           }
           if (dataNode) {
              dataNode.setClient('complexNode',complexNode);
              this.setNodeData(data,complexNode,dataNode);
              callback&&callback(complexNode);
           }else{
              this._loadDataModeCallback(data,complexNode,null);
              this.setRelationShipAndPosition(data); // bug
              callback&&callback(complexNode);
           }
           return complexNode;
        }
    },

    /**
     * modelparams2DNode2dModellib
     * @param model
     * @param params
     * @returns {twaver.Node}
     */
    loadModel2D : function(model,params,data){
        if(model || mono.Utils.isArray(params)){
            var obj = {};
            if(params instanceof Array){
                params.forEach(function(node){
                    node.scale = 20;
                });
                obj.data = params;
                obj.id = model;
            }else{
                obj = params || {};
                obj.id = model;
            }
            return make.Default.load(obj);
        }else {
             console.log('unknown 2d model params: ' + params);
             return null;
        }
    },

    /**
     * template
     * @param data
     * @param parentData
     * @returns {*}
     * @private
     */
    _translateTemplateData : function(data,parentData) {
        var id = data.getId(),
            parentId = parentData.getId(),
            pos = data.getPosition2d()||new mono.Vec2,
            pPos = parentData.getPosition2d()||new mono.Vec2;
        var dataId = id + "@" + parentId;
        var newData = this.dataManager.getDataById(dataId);
        if(!newData){
            newData = data.clone(dataId);
            newData.setHostId(data.getHostId());
            this.dataManager.addData(newData,false);
            var newPos = newData.getPosition2d() || new mono.Vec2;
            //
            // pPos{x:"0",y:"0",z:"0"}
            newPos.x = parseInt(pPos.x||0) + pos.x;
            newPos.y = parseInt(pPos.y||0) + pos.y;
//            newPos.z = parseInt(pPos.z||0) + pos.z; //z
        }
        //dataTypedata
//        pos.x = pPos.x + pos.x;
//        pos.y = pPos.y + pos.y;
//        pos.z = pPos.z + pos.z;
        newData.setParentId(parentId);
        return newData;
    },

    /**
     * 2D dataTypetemplateDatas,
     * @param dataType
     * @param parentData
     * @param onLoadFinish
     */
    loadDataTypeTemplateModel2Ds : function  (dataType,parentData,onLoadFinish) {
        var templateDatas = dataType.getTemplateDatas();
        if(templateDatas == null || templateDatas.length == 0){
            return;
        }
        var self = this;
        var groups = {};
        templateDatas.forEach(function(data){ //childgroupID(datahostId)
            data = self._translateTemplateData(data,parentData);
            var groupId = data.getHostId();
            var parentNode = self.dataNode2DMap[parentData.getId()];
            var node = self.loadDataModel2D(data,onLoadFinish);
            if (!node) {
               return ;
            }
            node.setMovable(false);
            if(groupId){
                self.setTemplatesGroup(node,groupId,parentNode,groups);
            }else{
                if(parentNode){
                    node.setHost(parentNode);
                    node.setParent(parentNode);
                }
            }
            node.setName("");
            var tooltip = data.getId();
            var parentId = parentData.getId();
            if(tooltip.length > (parentId.length+1)){
                tooltip = tooltip.substring(0,(tooltip.length-parentId.length-1));
            }
            node.setToolTip(tooltip);
        });
    },

    setTemplatesGroup : function(node,groupId,parentNode,groups){
        if(!node || !groupId){
            return null;
        }
        if(!groups){
            groups = {};
        }
        //()
        var nodeGroup = node.getParent();
        if(nodeGroup
            && nodeGroup.getClient('group_id')
            && nodeGroup.getClient('group_id') == groupId){
            return ;
        }
        var group = null;
        if(!groups[groupId]){
            var box = this.getDataBox2d();
            group = new twaver.Node();
            if(parentNode){
                var parentData = this.getNodeData(parentNode);
                group.setParent(parentNode);
                group.setClient('parent_data',parentData);
                group.setName('');
                group.setToolTip(groupId);
                group.setVisible(false);
            }
            group.setClient('group_id',groupId);
            groups[groupId] = group;
            box.add(group);
        }else{
            group = groups[groupId];
        }
        node.setHost(parentNode);//
        node.setParent(group);
    },

    /**
     * 2d
     * @param data
     * @param onLoadFinish
     * @returns {*}
     */
    loadDataModel2D : function(data,onLoadFinish){
        if (!this.viewManager2d) {
            console.log('need add ViewManager2D model!');
            return null;
        }
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        var box = this.getDataBox2d(),id = data.getId();
        var node = this.dataNode2DMap[id];
        var parameters = dataType.getModel2dParameters();
        if(!node){
            node = this.loadModel2D(dataType.getModel2d(), parameters,data);
            var parentNode = node;
            if(node instanceof Array){
                parentNode = node[0];
                if(parentNode){
                    parentNode.setMovable(false);
                    for(var i = 1 ; i < node.length ; i++){
                        var child = node[i];
                        if(child){
                            child.setMovable(false);
                            this.setNodeData(data,child);
                            parentNode.addChild(child);
                            child.setHost(parentNode);
                        }
                    }
                }
            }
            if(parentNode){
                parentNode.setName(data.getDescription() || id);
                this.setNodeData(data,parentNode);
                this.dataNode2DMap[id] = parentNode;
                var position = data.getPosition2d();
                if(position){
                   this.viewManager2d.setPosition(parentNode, position.x, position.y);
                }
            }
        }
        if(!box.getDataById(node.getId())){//load child
            box.addByDescendant(node);
        }
        this.loadDataTypeTemplateModel2Ds(dataType,data,onLoadFinish);
        return node;
    },

    handleDataAdd : function(event){
       var data = event.data;
       if(data instanceof $Data){
          if(this.shouldLoadData(data)){
            this.loadOneData(data);
          }else if(this.shouldLoadData2D(data)){
            this.loadDataModel2D(data); 
          }
       }else if(data instanceof $Link){
          this.loadLink(data);
       }
    },

    /**
     * dataEquipment,lookAt
     * @param data
     * @returns {boolean}
     */
    shouldLoadData : function(data,forParent){
        if(!data){
            return false;
        }
        if(forParent){
             var node = this.getNodeByDataOrId(data);
              if(node ){ //
                return true;
              }
        }
       
        var dataType = this.dataManager.getDataTypeForData(data);
        if(dataType && dataType.isLazyable()){
            var focusNode = this.viewManager3d.getFocusNode();
            var focusData = this.getNodeData(focusNode);
            if(focusData && (focusData.getId() == data.getId())){
                return true;
            }else{
                return false;
            }
        }else{ //
//            var currentScene = this.getCurrentScene();
//            if(currentScene == null){
//                return true;
//            }
//            var sceneData = this.getParentScene(data);
//            return sceneData.scene == this.getCurrentScene() && !currentScene.getTwod();
            var parentId = data.getParentId(),
            parent = this.dataManager.getDataById(parentId);
            return this.shouldLoadData(parent,true) && this.isCurrentSceneInstance(data);
        }
    },

    /**
     *
     * @param data
     * @returns {*}
     */
    shouldLoadData2D : function(data){
       var currentScene = this.getCurrentScene();
       if(currentScene == null){
          return false;
       }
       var sceneData = this.getParentScene(data)
       return sceneData.scene == this.getCurrentScene() && currentScene.getTwod();
    },

    handleDataRemove : function(event){
       var data = event.data;
       var dm = this.dataManager;
       var box = this.network3d.getDataBox();
       if(data instanceof $Data){
         var node = this.dataNodeMap[data.getId()];
         box.removeByDescendant(node);
       }else if(data instanceof $Link){
         var link = this.linkMap[data.getId()];
         box.removeByDescendant(link);
       }
    },

    handleDataPropertyChange : function(event){
        var data = event.source;
        var property = event.property;
        if(property === "parentId"){
           var oldParentId = event.oldValue;
           var parentId = data.getId();
           this.setParentRelationShip(data);
           this.translatePosition(data);
        }else if(property === "location" || property === "position"){
           this.translatePosition(data);
        }
    },

    setAllParentRelationShip : function(scene,rootData){
    	  for(var id in this.dataNodeMap){
    		    var node = this.dataNodeMap[id];
    		    var data = this.getNodeData(node);
            // this.setParentRelationShip(data); //
            /*
            if (scene && rootData) {
                var dataScene = this.getSceneAndRootByData(data);
                if (dataScene.scene == scene && dataScene.rootData == rootData) {
                   this.setParentRelationShip(data);
                }
            }else{*/
               this.setParentRelationShip(data);
            /*}*/
    	  }
    },

    //parentlookAtbyDecendantdataparentid
    // Data
    isNeedSetParent: function(data, node) {
        // return true;
        if (data) {
            var parentNode = this.dataNodeMap[data.getParentId()];
            if (this.earthScene && this.earthScene.rootData) {
                var earthNode = this.getNodeByDataOrId(this.earthScene.rootData);
                //parentparent
                if (parentNode && parentNode == earthNode) {
                    if (this._currentScene 
                        && this._currentScene.getCategoryId().indexOf('earth') >= 0) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
            //lazyLoad  2017-09-28
            // var parentData = this.getNodeData(parentNode);
            // if (!this.isCurrentSceneInstance(parentData)) { // 
            //     return false;
            // }
        }
        return true;
    },

    /**
     * 
     *
     */
    setParentRelationShip : function(data){
        if(!data) return;
        var node = this.dataNodeMap[data.getId()];
        if(!this.isNeedSetParent(data,node)){
            return ;
        }
        var parentNode = this.dataNodeMap[data.getParentId()];
        if(node && parentNode){
          node.setParent(parentNode);
        }
    },

    /**
     * datadata
     * 3D
     */
    setRelationShipAndPosition : function(data){
        if (!data) {
            return;
        }
        this.setParentRelationShip(data);
        this.translatePosition(data);
        var children = data.getChildren();
        if (!children || children.size() < 1) {
            return;
        }
        var node = this.dataNodeMap[data.getId()];
        var self = this;
        children.forEach(function(child){
            var childNode = self.dataNodeMap[child.getId()];
            if (childNode && self.isNeedSetParent(child,childNode)) {
                childNode.setParent(node);
            }
            self.translatePosition(child);
        });
    },

    translateAllPosition : function(){
       for(var id in this.dataNodeMap){
          var node = this.dataNodeMap[id];
          var data = this.getNodeData(node);
          this.translatePosition(data);
       }
    },
    
    // 
    computePosition : function(data,parentData,node,parentNode){
    	this.locationManager.computePosition(data,parentData,node,parentNode);
    },

    computeRotation : function(data,parentData,node,parentNode){
      this.locationManager.computeRotation(data,parentData,node,parentNode);
    },

    translatePosition : function(data){
  		if(!data){
  			return;
  		}
  		var dm = this.dataManager;
  	  var id = data.getId();
  	  var node = this.dataNodeMap[id];
  	  if(!node){
  	    	return;
  	  }
  		var parentId = data.getParentId();
  		var parentData = dm.getDataById(parentId);
  		var node = this.dataNodeMap[id];
  		var parentNode = this.dataNodeMap[parentId];
      // SceneparentNode,parentbuildingdata
      
      this.computePosition(data,parentData,node,parentNode);
      this.computeRotation(data,parentData,node,parentNode);
    },

    /**
     * beforeLoadScene
     * 
     * 
     * beforeLoadScene(callback)
     */
    beforeLoadSceneAnimate : function(scene,sceneRootData,oldScene,oldSceneRootData,callback,scope){
        if(callback){
          callback.call(scope);
        }
    },

    /**
     * 
     * truefalse
     * beforeLoadSceneAnimate
     */
    beforeLoadScene : function(scene,sceneRootData,clientMap){ // 
        if(this.beforeLoadSceneFunction){
            this.beforeLoadSceneFunction(scene,sceneRootData,clientMap);
        }
    	return true;
    },

    /**
     * 
     */
    afterLoadScene : function(scene,sceneRootData,oldScene,oldRootData,clientMap){ //for user use.
        this._sceneChangeDispather.fire({
            kind:'changeScene',
            data:scene,
            rootData:sceneRootData,
            oldData:oldScene,
            oldRootData:oldRootData,
            clientMap:clientMap
        });
        if(this.afterLoadSceneFunction){
            this.afterLoadSceneFunction(scene,sceneRootData);
        }
    },

    /**
     * data3D
     * @includeInvisible 
     */
    loadOneData : function(data,includeInvisible,onLoadFinish){
       var dataType = this.dataManager.getDataTypeForData(data);
        if(!dataType || !make.Default.getCreator(dataType._model)) {
          if (!dataType) {
             console.log('modelType is  null!');
          }else{
             console.log('model id ' + dataType._model+' does not exist!');
          }
          onLoadFinish && onLoadFinish();
          return ;
        }
       this.loadDataModel(data,includeInvisible,onLoadFinish);
       this.setParentRelationShip(data);
       this.translatePosition(data);
    },

    getSceneFromData : function(dataOrId){
        var dm = this.dataManager;
        if(dm.getRootScene() == null){
           return null;
        }
        if(!dataOrId){
          return null;
        }
        var dm = this.dataManager;
        var data = dataOrId;
        if(!dataOrId.getId){
         data = dm.getDataById(dataOrId);
        }
        var scene = dm.getSceneByData(data);
        if(scene == null){
          return data&&this.getSceneFromData(data.getParentId());
        }
        scene.__currentRootData = data;
        return scene;
    },

    /**
     * 
     * nodeSceneScene...
     *
     * @param dataOrId
     * @param callback callback
     */
    loadLazyData : function(dataOrId,callback){ //dataOrIdfloorsceneloadData
        if (!dataOrId) {
            return;
        }
        var self = this;
        var dm = this.dataManager;
        var data = dataOrId;
        if (!dataOrId.getId) {
            data = dm.getDataById(dataOrId);
        }
        var parentId = data.getParentId();
        var parentScene = this.getSceneFromData(parentId);
        var dataScene = this.getSceneFromData(data);
        // AddByDescendant; 
        if ((parentScene != null || dataScene != null) && parentScene != dataScene) {
           var node = this.getNodeByDataOrId(data); 
           if (!node) {
             this.loadOneData(data,null,callback);
           } else {
              var box = this.getDataBox();
              if (!box.contains(node)) {
                 box.addByDescendant(node,function(childNode){
                     var childData = self.getNodeData(childNode); 
                     if (childData && self.isCurrentSceneInstance(childData)) {
                        return true;
                     }
                     return false;
                 }); // byDescendantadd
                 this.setParentRelationShip(data);
                 this.translatePosition(data);
              }
            }
            callback&&callback(node);
            return;
        }
        this.loadLazyData(parentId);
        var node = this.getNodeByDataOrId(data); 
        if (!node) {
            this.loadOneData(data,null,callback);
        } else {
            var box = this.getDataBox();
            if (!box.contains(node)) {
                box.addByDescendant(node);
                this.setParentRelationShip(data);
                this.translatePosition(data);
            }
            callback&&callback(node);
        }
    },

    /**
     * dataloadChild
     * @param dataOrNode
     * @param onlyNotLazy
     */
    loadLazyChildren : function(dataOrNode,onlyNotLazy){
       onlyNotLazy = onlyNotLazy || false;
       var data =  dataOrNode;
       var root = dataOrNode;
       if(dataOrNode instanceof mono.Data){
          data = this.getNodeData(dataOrNode);
       }else{
          root = this.getNodeByDataOrId(data);
       }
        if(!(data instanceof it.Data)){
            return null;
        }
       var parentScene = this.getSceneFromData(data);
       var children = new mono.List();
        if(data instanceof $Data){
            children = data.getChildren();
        }//this.dataManager.getChildren(data);
       var i =0,length = children.size(),child,childType,node;
       for(;i < length;i ++){
           child = children.get(i);
           node = this.dataNodeMap[child.getId()];
           if (!node) {
               childType = this.dataManager.getDataTypeForData(child);
               if (!(childType.isLazyable() && onlyNotLazy)) {
                   //, 2017-10-25
                   // var dataScene = this.getSceneFromData(child);
                   // if ((parentScene != null || dataScene != null) && parentScene != dataScene) { 
                   //     continue;
                   // }
                   // if (this.isSceneInstance(parentScene,data,child)) {//2017-10-31 data
                   if (this.isCurrentSceneInstance(child)) { // 
                      this.loadOneData(child);
                      this.loadLazyChildren(child, true);
                   }
                   // this.loadOneData(child);
                   // var dataScene = this.getSceneFromData(child);
                   //, 2017-10-25
                   // if ((parentScene != null || dataScene != null) && parentScene != dataScene) { 
                   //     continue;
                   // }
                   // this.loadLazyChildren(child, true);
               }
           } else {
//             node.setParent(root);
               if (!this.isCurrentSceneInstance(child)) { // 2017-11-09 
                   continue;
               }
               var self = this;
               var childType = this.dataManager.getDataTypeForData(child);
               if (childType && !(childType.isLazyable() && onlyNotLazy)) {
               //parentDatalink
               // datarootData,loadLazyChildren
               if (!this.network3d.getDataBox().getDataById(node.getId())) { 
                   this.network3d.getDataBox().addByDescendant(node,function(childNode){ 
                   // filter
                   // datadataparentparentdata(showParentAndChildren)
                   //   parentchilddata
                   // 
                       // var nodeScene = self.getSceneFromData(child);
                       var rootNodeScene = self._currentScene;
                       var childNodeScene = self.getSceneFromData(self.getNodeData(childNode));
                       var childNodeData = self.getNodeData(childNode);
                       if(childNodeData == child){ // 
                          return true;
                       }
                       if (childNode instanceof mono.Billboard 
                        && childNode.getClient('_alarmBillboard')) { // 2017-11-06 
                          return true;
                       }
                       
                       // lazyLoadnodeloadadd
                       var complexNode = node.getClient('complexNode'),simpleNode = node.getClient('simpleNode');
                       if (complexNode 
                           && simpleNode 
                           && complexNode != 'unload' 
                           && complexNode.getParent() != node
                           && simpleNode.getParent() == node) {
                          return false;
                       }
                       if ((rootNodeScene != null || childNodeScene != null) 
                        && rootNodeScene != childNodeScene) {
                           return false;
                       }else{
                           return true;
                       }
                   });
               }
               var dataScene = this.getSceneFromData(child);
               if ((parentScene != null || dataScene != null) && parentScene != dataScene) {
                   continue;
                }
                this.loadLazyChildren(child, true);
               }
               
           }
       }
       // this.loadLinks();
    },

    $P : function(level,dataOrId){
       
    },

    loadLinks : function(){
       var dm = this.dataManager;
       var linkMap = dm.getLinkMap();
       for(var id in linkMap){
           this.loadLink(linkMap[id]);
       }
    },

    loadLink : function(link){
        var dm = this.dataManager;
        var fromId = link.getFromId();
        var toId = link.getToId();
        var fromSide = link.getFromSide();
        var toSide = link.getToSide();
        var fromNode = this.dataNodeMap[fromId];
        var toNode = this.dataNodeMap[toId];
        if (!fromNode || !toNode) {
            return;
        }
        // add 2016-12-06 /link
        var fromPort = null,toPort = null;
        if (link.getFromPortId()) {
            fromPort = this.postManager.loadPortByPortId(fromId,link.getFromPortId(),fromSide);
        }
        if (link.getToPortId()) {
            toPort = this.postManager.loadPortByPortId(toId,link.getToPortId(),toSide);
        }
        if (fromPort) {
            fromNode = fromPort;
        }
        if (toPort) {
            toNode = toPort;
        }

        if (this.linkMap[link.getId()]) {
            return;
        }
        var monoLink = null;
        var color = '#21CD43'; //00FFFF
        var radius = link.getRadius() || 2;
        var linkTemplate = null;
        var dataTypeId = link.getDataTypeId();
        var dataType = dm._dataTypeMap[dataTypeId];
        var imageFlow = 'data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4RDARXhpZgAATU0AKgAAAAgABQESAAMAAAABAAEAAAExAAIAAAAuAAAIVgEyAAIAAAAUAAAIhIdpAAQAAAABAAAImOocAAcAAAgMAAAASgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE1pY3Jvc29mdCBXaW5kb3dzIFBob3RvIFZpZXdlciA2LjEuNzYwMC4xNjM4NQAyMDE1OjA3OjMwIDE2OjU4OjA4AAAB6hwABwAACAwAAAiqAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4TG4aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+PHhtcDpDcmVhdG9yVG9vbD5NaWNyb3NvZnQgV2luZG93cyBQaG90byBWaWV3ZXIgNi4xLjc2MDAuMTYzODU8L3htcDpDcmVhdG9yVG9vbD48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSd3Jz8+/9sAQwACAQECAQECAgICAgICAgMFAwMDAwMGBAQDBQcGBwcHBgcHCAkLCQgICggHBwoNCgoLDAwMDAcJDg8NDA4LDAwM/9sAQwECAgIDAwMGAwMGDAgHCAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgBAAEAAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA//9k=';
        if(dataType != null){
            linkTemplate = this._linkTemplateMap[dataTypeId];
            if(!linkTemplate){
                linkTemplate = this.loadModel(dataType.getModel(),dataType.getModelParameters());
            }
        }

        if(link.getType() && link.getType() == 'link'){
            monoLink = new mono.Link(fromNode, toNode);
            if(linkTemplate && linkTemplate instanceof mono.PathNode){
                // monoLink.s(linkTemplate.styleMap); // linkstylelink 2017-06-23 Kevin
                for(var key in linkTemplate.styleMap){
                    monoLink.setStyle(key,linkTemplate.styleMap[key]);
                }
            }else{
                monoLink.s({ // 
                    'm.type':'phong',
                    'm.color':'cyan',
                    'm.ambient':'cyan',
                });
            }
            monoLink.setStyle('m.linewidth',5);
        }else{
            monoLink = new mono.PathLink(fromNode, toNode);
//            if(dataType != null){
               // if(linkTemplate && linkTemplate instanceof mono.PathNode){ // if exists template,use template style;
               //    monoLink.setStartCap(linkTemplate.getStartCap());
               //    monoLink.setEndCap(linkTemplate.getEndCap());
               //    monoLink.setRadius(linkTemplate.getRadius());
               //    monoLink.s(linkTemplate.styleMap);
               // }else{
                 monoLink.s({ // 
                  'm.type':'phong',
                  'm.color':'cyan',
                  'm.ambient':'cyan',
                  // 'm.texture.image':imageFlow,//'./images/pipeline/flow.jpg',
                  // 'm.texture.repeat':new mono.Vec2(200,1),
                 });
               // }
        }

        if(!(linkTemplate instanceof mono.PathNode) && (monoLink instanceof mono.PathNode)){
            monoLink.setStartCap('plain');
            monoLink.setEndCap('plain');
            monoLink.setRadius(radius);
            monoLink.s({
                'm.specularStrength': 30,
                'm.ambient': '#C6FEFA',
                'm.type': 'phong',
            });
        }
        monoLink._adjustTimes = 10;
        if (this.linkControlsFunction) {
            fromNode.updateWorldMatrix();
            toNode.updateWorldMatrix();
            var controls = this.linkControlsFunction(link, fromNode, toNode);
            monoLink.setLinkType('control');
            monoLink.setControls(controls);
        } else {
            var fromControls = monoLink.getFromControls();
            var toControls = monoLink.getToControls();
            var controls = [];
        }
        monoLink.setClient('id', link.getId());
        monoLink.setClient(it.SceneManager.CLIENT_IT_DATA, link);
        this.linkMap[link.getId()] = monoLink;
        monoLink.setVisible(false);  //it.Link
        this.network3d.getDataBox().add(monoLink);
    },

    _getControlPoint : function(dataOrId,exprObject){
       exprObject  = exprObject || {};
       var x = this._getControlNumber(dataOrId,exprObject.x,'x');
       var y = this._getControlNumber(dataOrId,exprObject.y,'y');
       var z = this._getControlNumber(dataOrId,exprObject.z,'z');
       return new mono.Vec3(x,y,z);
    },

    _getControlNumber : function (dataOrId,expr,axis) {
        if(!expr){
          return 0;
        }
        var data0 = dataOrId.getId ? dataOrId : this.dataManager.getDataById(dataOrId);
        var reg = /\$(p|P)\d/g;
        var $ps = expr.match(reg);
        var scope = {};
        var self = this;

        for(var i = 0;i < $ps.length;i ++){
           var $p = $ps[i];
           var num = $p.toLowerCase().replace("$p",'');
           var node = self.getNodeByDataOrId(getParent(num,data0));
           scope[$p] = self._wrapBoundingBox(node);
        }
        function getParent(level,data){
            if(level == 0){
               return data;
            }
            var parent = self.dataManager.getParent(data);
            if(!parent){
              return data;
            }else{
               return getParent(level - 1,parent);
            }
        }
        var text = " with (scope) {  return " + expr + "}";
        var myFunction = new Function('scope', text);  
        try{
          var value = myFunction(scope); 
          return value;
        }catch(e){
           console.error(e);
        }
        return 0;
    },

    _wrapBoundingBox : function(node){
        var boundingBox = node.getBoundingBox();
        boundingBox.front = function(value){
           value = value || 0;
           return node.frontWorldPosition(this.max.z + value).z;
        };
        boundingBox.top = function(value){
           value = value || 0;
           return node.worldPosition(new mono.Vec3(0,1,0),this.max.y + value).y;
        };
        return boundingBox
    },

    isLink : function(node){
        if(node && node.getClient(it.SceneManager.CLIENT_IT_DATA)
            && node.getClient(it.SceneManager.CLIENT_IT_DATA) instanceof $Link){
            return true;
        }
        return false;
    },

    getLinkNodeById : function (linkOrId){
        var linkId = linkOrId;
        if (linkOrId instanceof it.Link) {
            linkId = linkOrId.getId();
        }
        return this.linkMap[linkId];
    },

    dwRootScene: function(data, category) {  //datacenter  by--loda 2017-11-30
        var self = this;
        var children = data.getChildren()._as;
        if (!children.length) {
            return false;
        } else {
            for(var i=0;i<children.length;i++){
                var childCty = self.dataManager.getCategoryForData(children[i]);
                var childCtyId = childCty.getId();
                if(category == childCtyId)return false;
            }
            return true;
        }      
    },

    _loadRootScene : function(){
        var dm = this.dataManager;
        var rootScene = dm.getRootScene();
        var self = this;
        var callback = function(){
          var rootData = null;
          if (rootScene) {
             var rootCategoryId = rootScene.getCategoryId();
             var dataMap = dm.getDataMapByCategory(rootCategoryId);
             for (var id in dataMap) {
                rootData = dataMap[id];
                var bo = self.dwRootScene(rootData, rootCategoryId);
                if (!bo)continue;
                break;
             }
          }
           self._loadOneScene(rootScene, rootData);
           if (self._currentRootNode) {
             // self.viewManager3d.setFocusNode(self._currentRootNode);
             self.setFocusNode(self._currentRootNode); // 2017-08-11
           }
        }
        this.beforeLoadSceneAnimate(rootScene,null,null,null,callback,this);
    },

    clearCustomSceneView : function(){
      if (!this.sceneViewMap) {
         return ;
      }
      for(var cid in this.sceneViewMap){
        var sv = this.sceneViewMap[cid];
        if (sv && sv.getContainer() && this.mainView.contains(sv.getContainer())) {
           this.mainView.removeChild(sv.getContainer());
        } 
      }
    },

    /**
     * GPU
     * textutes
     */
    _saveTextures : function(){
        if(!this.isClearCache) {
          return ;
        }
        this._textures = {};
        var self = this;
        this.network3d.getDataBox().forEach(function (data) {
             data.material 
             && data.material.materials 
             && data.material.materials.forEach(function(material) {
               material.uniformsList && material.uniformsList.forEach(function(uniform) {
                  if (uniform[0].type === 't' && uniform[0].value) {
                      self._textures[uniform[0].value.id] = true;
                  } else if (uniform[0].type === 'tv' 
                          && uniform[0].value 
                          && uniform[0].value.length) {
                     console.log(uniform[0].value);
                  }
               });
           });
      });
    },
    
    /**
     * GPU
     * _saveTexturestextures
     */
    _clearTextures : function(){
        if(!this._textures || !this.isClearCache) {
          return ;
        }
        var self = this;
        Object.keys(this._textures).forEach(function(t) {
            self.network3d._gl.deleteTexture(self.network3d.pm.glTextureMap[t]);
            delete self.network3d.pm.glTextureMap[t];
        });
        Object.keys(this._textures).forEach(function(id) {
           self.network3d.pm.textureUpdateFlags[id] = true;
        });
    },
    
    
    _loadOneScene : function(scene,rootData,callback,clientMap){
        if (!this.beforeLoadScene(scene, rootData,clientMap)) {
            return;
        }
        this._saveTextures(); //textures
        this.setSceneCamera(scene); //
        this.setSceneNetworkAndLight(scene);
        var oldScene = this._currentScene;
        var oldRootData = this.getNodeData(this._currentRootNode);
        var dm = this.dataManager;
        var categoryId = scene.getCategoryId();
        var sceneType = scene.getSceneType(), level;
        var is2d = scene.getTwod();
        var withGis = scene.getWithGis();
        if (sceneType == "ShowSelf") {
            level = 0;
        } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
            level = 1;
        } else if(sceneType === "ShowThird"){
            level = 2;
        } else {
            level = 100;
        }
        if(this.earthScene){
          this.earthScene.clear();
        }
        this.clearCustomSceneView();
        this._currentScene = scene;
         var sceneView = this.sceneViewMap[scene.getId()];
        if (sceneView) { // 
            if (sceneView.getContainer()) {
                this.network3d.getRootView().style.display = 'none';
                this.viewManager2d.getContainer().style.display = 'node';
                this.mainView.appendChild(sceneView.getContainer());
                sceneView.show(rootData);
                callback && callback();
            } else {
                callback && callback();
                //view
                // onloadfinish(setAllParentRelationShiptranslateAllPositionloadLinksresetCamera)
                // viewView3D
                // 
            // this.afterLoadScene(scene, rootData, oldScene, oldRootData); //
            }
            this._currentRootData = rootData; 
            if (sceneView.isLoadData()) {
               this._loadSceneData(rootData, sceneType, level, is2d); //
            }
            if (is2d) {
                this._currentRootNode = this.dataNode2DMap[rootData.getId()];
            } else {
                this._currentRootNode = this.dataNodeMap[rootData.getId()];
            }
            this._onLoadFinish(scene, rootData, oldScene, oldRootData,clientMap);
            this.afterLoadScene(scene, rootData, oldScene, oldRootData,clientMap);
            return;
        } else if (this._currentScene.getTwod()) {
            if (!this.viewManager2d) {
               console.log('need install viewManager2d model!');
               return;
            }
            if (withGis) {
                this.viewManager2d.addGis(true, true);
            } else {
                this.viewManager2d.removeGis();
            }
            if (this._currentScene.zoomLevel) {
                this.viewManager2d.setZoomLevel(this._currentScene.zoomLevel);
            }
            if (this._currentScene.center) {
                this.viewManager2d.setCenter(this._currentScene.center);
            }
            this.network3d.getRootView().style.display = 'none';
            this.viewManager2d.getContainer().style.display = 'block';
        }else if(withGis){ //3Dwith GIS ,3D
            if(!this.earthScene){
                this.earthScene = this.createDefaultEarthScene(scene);
                if (!this.earthScene) {
                   return;
                }
                this._currentRootData = rootData; 
                setTimeout(function(){
                    if (self.earthScene && self._currentScene === self.earthScene.scene) { // 1
                      self.earthScene.doPlay();
                    }
                },1000);
            }else{
                this._currentRootData = rootData; 
                this.earthScene.refresh();
            }
            if (this.viewManager2d) {
               this.viewManager2d.getContainer().style.display = 'none';
            }
            this.network3d.getRootView().style.display = 'block';

            if(this.earthScene && this.earthScene.rootData){
               this._currentRootNode = this.dataNodeMap[this.earthScene.rootData.getId()];
            }else{
                this._currentRootNode = null;
            }
            this.viewManager3d.setFocusNode(null); // focusnull 2017-10-12
            
            if (callback) {
                callback();
            }
            this.resetCamera(scene, rootData,oldScene,oldRootData,clientMap);//--2016-10-27
            this.afterLoadScene(scene, rootData,oldScene,oldRootData,clientMap);
            // var self = this;
            /*  2017-07-13 data  */
            this.setAllParentRelationShip(scene,rootData);
            this.translateAllPosition();
            // if (this.viewManager2d) {
            //    this.viewManager2d.getContainer().style.display = 'none';
            // }
            // this.network3d.getRootView().style.display = 'block';
            
            return; // 3Dnetworkcamera --2016-05
            // positionrotationdata. -- 2017-07-13
        } else {
            if (this.viewManager2d) {
               this.viewManager2d.getContainer().style.display = 'none';
            }
            this.network3d.getRootView().style.display = 'block';
        }

        if (rootData == null) {
            var dataMap = dm.getDataMapByCategory(categoryId);
            this.network3d.getDataBox().startBatch();
            for (var id in dataMap) {
                this._currentRootData = dataMap[id]; //rootData3DNode
                this._loadSceneData(dataMap[id], sceneType, level, is2d);
                this._currentRootNode = this.dataNodeMap[id];
                // _loadSceneData nodechangerootData -- add By Kevin 2017-05-16
                // this._currentRootData = dataMap[id]; //rootData3DNode
            }
        } else {
            this._currentRootData = rootData; // showChild_currentRootNode
            this.network3d.getDataBox().startBatch();
            this._loadSceneData(rootData, sceneType, level, is2d);
            //2dlazyable3D
            //2DrootNodetwaver 2Dnode
            if (is2d) {
                this._currentRootNode = this.dataNode2DMap[rootData.getId()];
            } else {
                this._currentRootNode = this.dataNodeMap[rootData.getId()];
            }
            // _loadSceneData nodechangerootData -- add By Kevin 2017-05-16
            // this._currentRootData = rootData; // showChild_currentRootNode 
        }
        if (callback) {
            callback();
        }
        if (this._currentScene.getTwod() && this.viewManager2d) {
            this.viewManager2d.showTable(this._currentScene);
            this.viewManager2d.showTree(this._currentScene);
            this.network2d.zoomOverview();
        }
//      var oldScene = this._currentScene;
        //afterLoadScene,
        // sceneChangeloadFinishe
        // timeoutafterLoadScene
        this.network3d.getDataBox().endBatch();
        this._onLoadFinish(scene, rootData,oldScene,oldRootData,clientMap);
        this.afterLoadScene(scene, rootData,oldScene,oldRootData,clientMap);
    },

    afterCreateEarthScene : function(earthScene){

    },

    createDefaultEarthScene: function(scene) {
        if (!it.DefaultEarthScene) {
           console.log('  need include DefaultEarthScene!!!');
           return null;
        }
        var earthScene = new it.DefaultEarthScene(this, scene);
        earthScene.createDCBillboard = function(data) {
            return null
        };
        this.afterCreateEarthScene(earthScene);
        this._sceneManagerChangeDispatcher.fire({
               kind:'createDefaultEarthScene',
               data:earthScene
           });
        return earthScene;
    },

    // scenelazyLoad(floorlazyLoadfloor)
    _loadSceneData : function(data,sceneType,level,is2d){
        var getChildTime = 0;
        var dm = this.dataManager;
        if (sceneType === "ShowChildren" && level === 1) {
        } else if(sceneType === "ShowDescendant" && level === 100){
          
        }else if(sceneType === "ShowSelfAndDescendant" && level === 100){ // 2017-10-11lazy
           this.loadDataModel(data);
        }else {
            if (is2d) {  // 2D3D,2Dlazyload
                this.loadDataModel2D(data);
            } else {
                if (!dm.isLazyable(data)) {
                    this.loadDataModel(data);
                }
            }
        }
        if (level <= 0) {
            return;
        }
        var children = data.getChildren();//dm.getChildren(data);
        for (var i = 0; i < children.size(); i++){
            var child = children.get(i);
            if (this.isLoadChild(data,child,sceneType,level-1)) { // 2018-02-26 Kevin
               this._loadSceneData(child, sceneType, level - 1, is2d);
            }
        }
    },
 
    /**
     * Kevin
     * 2018-02-26 
     * loadScene 
     */
    isLoadChild : function(data,child,sceneType,level){
      return true;
    },

    _onLoadFinish : function(scene, rootData,oldScene,oldRootData,clientMap){
        this.setAllParentRelationShip(scene,rootData);
        this.translateAllPosition();
        this.loadLinks();
        this._clearTextures();// GPU
        this.resetCamera(scene, rootData,oldScene,oldRootData,clientMap);
        //3Dnetwork,
        //sceneChangeListenersetSceneNetworkAndLight
//        this.setSceneNetworkAndLight();
        this._loaded = true;
    },

    getSetMethod : function(key){
        var setMethod = 'set' + key.charAt(0).toUpperCase() + key.slice(1);
        return setMethod;
    },

    /**
     * network3dkeyvalue
     * @param key
     * @param value
     */
    setNetworkValue : function(network3d,key,value){
        if(!key){
            return ;
        }
        var setMethod = this.getSetMethod(key);
        // var network3d = this.network3d;
        // var currentScene = this._currentScene;
        // var sceneView = this.sceneViewMap[currentScene.getId()];
        // if (sceneView && sceneView.getNetwork3D()) {
            // network3d = sceneView.getNetwork3D();
        // }
        if(network3d[setMethod] && (typeof(network3d[setMethod]) === 'function')){
            network3d[setMethod](value);
        }else{
            network3d[key] = value;
        }
    },

    /**
     * scenedefaultInteraction
     */
    setDefaultInteractionValue: function(scene) {
        if(!scene){
            return;
        }
        var defaultInteractionParameters = scene.defaultInteractionParameters;
        if (!defaultInteractionParameters) {
            return;
        }
        // var currentScene  = this._currentScene;
        var network3d = this.network3d;
        if (scene && this.sceneViewMap[scene.getId()] && this.sceneViewMap[scene.getId()].getNetwork3D()) {
            network3d = this.sceneViewMap[scene.getId()].getNetwork3D();
        }
        var df = network3d.getDefaultInteraction();
        if (defaultInteractionParameters) {
            for (var key in defaultInteractionParameters) {
                var setMethod = this.getSetMethod(key);
                var value = defaultInteractionParameters[key];
                if (df[setMethod] && (typeof(df[setMethod]) === 'function')) {
                   df[setMethod](value);
                } else {
                    df[key] = value;
                }
            }
        }
    },

    setCameraValue : function(camera,key,value){
      if(!key || !camera){
            return ;
        }
        // var camera = this.network3d.getCamera();
        // var currentScene  = this._currentScene;
        // var sceneView = this.sceneViewMap[currentScene.getId()];
        // if (sceneView && sceneView.getCamera()) {
        //    camera = sceneView.getCamera();
        // } 
        var setMethod = this.getSetMethod(key);
        if(camera[setMethod] && (typeof(camera[setMethod]) === 'function')){
          if (value instanceof Array && value.length ===3 ) {
            camera[setMethod](value[0],value[1],value[2]);
          }else{
            camera[setMethod](value);
          }
        }else if(key == 'target'){
          if (value instanceof Array && value.length ===3 ) {
            camera['lookAt'](value[0],value[1],value[2]);
          }
        }else{
            camera[key] = value;
        }
    },

    clearSceneNodeMap : function(){
        this._sceneNodeMap = {}; //
        this._sceneNodes = [];
    },

    addToSceneNodeMap : function(data,node){
        if (!data || !node) {
            return  ;
        }
        this._sceneNodeMap[data.getId()] = node;
        this._sceneNodes.push(node);
    },

    /**
     * 3Dnetwork,
     * @param scene
     */
    setSceneNetworkAndLight : function(scene){
        if(!scene){
            return null;
        }
        if(scene.getTwod()){ //2D2Dnetwork
            return;
        }
        var networkParameters = scene.networkParameters;
        var lights = scene.lights;
        var animateParameters = scene.animateParameters;
        var network = this.network3d;
        var sceneView = this.sceneViewMap[scene.getId()];
        if (sceneView && sceneView.getNetwork3D()) {
          network = sceneView.getNetwork3D();
        } 
        this.viewManager3d.resetNetwork();//viewManager
        if(networkParameters){
            for(var pro in networkParameters){
               this.setNetworkValue(network,pro,networkParameters[pro]);
            }
        }
    },

    setSceneCamera : function(scene){
        this.viewManager3d.resetCamera();
        if(!scene){
            return null;
        }
        if(scene.getTwod()){ //2D2Dnetwork
            return;
        }
        var camera = this.network3d.getCamera();
        var sceneView = this.sceneViewMap[scene.getId()];
        if (sceneView && sceneView.getCamera()) {
           camera = sceneView.getCamera();
        } 
        var cameraParameters = scene.cameraParameters;
        if(cameraParameters){
            for(var pro in cameraParameters){
               this.setCameraValue(camera,pro,cameraParameters[pro]);
            }
        }
    },

    _loadDataMap : function(dataMap){
        var dm = this.dataManager;
        for (id in dataMap) {
            var data = dataMap[id];
            if (!dm.isLazyable(data)) {
                this.loadDataModel(dataMap[id]);
            }
        }
        // afterLoadScene,
        // sceneChangeloadFinishe
        // timeoutafterLoadScene
        this._onLoadFinish();
        this.afterLoadScene();
    },
    
    /**
     * 
     * 
     * moveCameraCallback 
     * CameraManager
     */
    resetCamera : function(scene, rootData,oldScene,oldRootData,moveCameraCallback){
//      this.network3d.zoomEstimateOverview(30); //LookAt
        if(this.resetCameraWhenSceneChange){
          if (this._currentRootNode) {
             this.viewManager3d.getDefaultEventHandler().lookAtNodeWithOutAnimate(this._currentRootNode);
          }else{
            this.network3d.zoomEstimateOverview(30);
          }
        }
        this.resetCameraWhenSceneChange = true; 
    },

    loadScene : function (){
        var dm = this.dataManager;
        var rootScene = dm.getRootScene();
        // if (!this.beforeLoadScene(rootScene)) {  // _loadRootScene
        //     return;
        // }
        if (rootScene) {
            this.loadPreRenderScene();
            return this._loadRootScene();
        }
        var dataMap = dm.getDataMap();
        this._loadDataMap(dataMap);
    },

    /**
     * 
     * 
     *   1rootScene
     *   2rootScene
     *   3rootSceneview(network)
     *   
     */
    loadPreRenderScene: function(callback) {
        var sceneMap = this.dataManager._sceneMap;
        var rootScene = this.dataManager.getRootScene();
        // var preLoadSceneMap = {};
        for (var id in sceneMap) {
            var scene = sceneMap[id];
            if (scene && scene != rootScene && scene.getPreRender() && !this.isSameView(scene, rootScene)) {
                // preLoadSceneMap[id] = scene;
                var level;
                var sceneType = scene.getSceneType();
                if (sceneType == "ShowSelf") {
                    level = 0;
                } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
                    level = 1;
                } else if (sceneType === "ShowThird") {
                    level = 2;
                } else {
                    level = 100;
                }
                var sceneView = this.sceneViewMap[scene.getId()]
                if(sceneView && sceneView.getContainer()){
                    scene.getContainer().style.display = 'none';
                }else{
                   this.network3d.getRootView().style.display = 'none';
                   this.viewManager2d.getContainer().style.display = 'node';
                }
                var dataMap = this.dataManager.getDataMapByCategory(scene.getCategoryId());
                for(var key in dataMap){
                    var data = dataMap[key];
                    if (!data) {
                       continue;
                    }
                    if (data && data.getParentId() && !this.dataManager.getDataById(data.getParentId())) {
                       continue;
                    }
                    if (data.getChildren() && data.getChildren().size() <= 0) {
                       continue;
                    }
                    this._loadSceneData(data, sceneType, level, scene.getTwod());
                    // sceneView
                    // this._onLoadFinish(scene, rootData,oldScene,oldRootData);
                    this.setFocusNode(this.getNodeByDataOrId(data)); // dcload
                    this.lookAt(this.getNodeByDataOrId(data));
                }
            }
        }
        callback && callback();
    },

    isSameView : function(scene1,scene2){
        if(!scene1 || !scene2){
            return true;
        }
        if (scene1 == scene2) {
            return true;
        }
        var s1View = this.sceneViewMap[scene1.getId()],s2View = this.sceneViewMap[scene2.getId()]; 
        if (scene1.getTwod()) {
            s1View = this.network2d;
        }else if(s1View && s1View.getContainer()){ //
            s1View = scene1.getContainer();
        }else{
            s1View = this.network3d;
        }

        if(scene2.getTwod()){
            s2View = this.network2d;
        }else if (s2View && s2View.getContainer()) { //
            s2View = s2View.getContainer();
        }else{
            s2View = this.network3d;
        }

        if (s1View != s2View) {
            return false;
        }
        return true;
    },

    /**
     * (category)
     */
    showAllInvisibleData : function(){
        // this.viewManager3d.removeVisibleFilter(this.invisibleFilter); // 
       var categoryMap = this.dataManager._categoryMap;
       if (!categoryMap) {
          return false;
       }
       for(var id in categoryMap){
          this.setInvisibleDataByCategoryId(id,true);
       }
    },

    /**
     * (category)
     */
    invisibleAllInvisibleData : function(){
       var categoryMap = this.dataManager._categoryMap;
       if (!categoryMap) {
          return false;
       }
       for(var id in categoryMap){
          this.setInvisibleDataByCategoryId(id,false);
       }
    },

    /**
     * categoryId/category(category)
     * categorycategory.isVisible() == false
     * data
     */
    setInvisibleDataByCategoryId : function(categoryId,visible){
       if (!categoryId) {
         return;
       }
       var category = this.dataManager._categoryMap[categoryId];
       if (!category || category.isVisible()) {
         return;
       }
       var datas = this.dataManager.getDataMapByCategory(categoryId);
       if (!datas) {
          return;
       }
       // this.viewManager3d.addVisibleFilter(this.invisibleFilter);
       for(var id in datas){
         var data = datas[id];
         // this.invisibleFilter.setVisible(data,visible);
         if(!this.dataNodeMap[id] 
           && this.isCurrentSceneInstance(data)){ //dataloadload
           this.loadOneData(data,true);//dataVisiblefalse
         }
         this.invisibleFilter.setVisible(data,visible); //loadDataMode
       }
       this.viewManager3d.clearVisibleMap();
       this.network3d.dirtyNetwork();
    },

    getAlarmManager:function(){
        return this._alarmManager;
    },

    addSceneManagerChangeListener : function(listener, scope, ahead) {
        this._sceneManagerChangeDispatcher.add(listener, scope, ahead);
    },
    removeSceneManagerChangeListener : function(listener, scope) {
        this._sceneManagerChangeDispatcher.remove(listener, scope);
    },

    addSeneChangeListener : function(listener, scope, ahead){
       this._sceneChangeDispather.add(listener,scope,ahead);
    },

    addSceneChangeListener : function(listener, scope, ahead){
        this._sceneChangeDispather.add(listener,scope,ahead);
    },

    removeSceneChangeListener : function(listener, scope){
       this._sceneChangeDispather.remove(listener,scope);
    },

    addSceneVirtualChangeListener : function(listener, scope, ahead){
        this._sceneVirtualChangeDispather.add(listener,scope,ahead);
    },

    removeSceneVirtualChangeListener : function(listener, scope){
       this._sceneVirtualChangeDispather.remove(listener,scope);
    },

    addSceneVisibleChangeListener : function(listener, scope, ahead){
        this._sceneVisibleChangeDispather.add(listener,scope,ahead);
    },

    removeSceneVisibleChangeListener : function(listener, scope){
       this._sceneVisibleChangeDispather.remove(listener,scope);
    },

    /**
     * billboard
     * @param {mono.Billboard} board
     */
    removeBillboard : function (board) {
        board.setParent(null);
        this.getDataBox().remove(board);
    },

    /**
     * billboard
     * @param dataId
     */
   /* removeAllBillboardByDataId:function(dataId){
        var data = this.dataManager.getDataById(dataId);
        this.removeAllBillboardByData(data);
    },
*/
    /**
     * billboard
     * @param {it.Data} data
     */
  /*  removeAllBillboardByData : function (data) {
        var boards = data.boards;
        if(boards){
            for(var i=0;i<boards.length;i++){
                this.removeBillboard(boards[i]);
            }
        }
    },
*/
    /**
     * billboard
     * @param dataId
     * @param {width: 256,height: 128,radius: 16,arrowWidth: 16,arrowHeight: 16,bgColor: '#5B85B5'} args
     */
   /* createBillboardById:function(dataId, board){
        var node = this.dataNodeMap[dataId];
        this.getDataBox().add(board);
        var data = this.dataManager.getDataById(dataId);
        if(!data.boards){
            data.boards = [];
        }
        data.boards.push(board);
        return board;
    },
    */

    /**
     * billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createBillboard : function (data, board) {
        return this.createTitleBillboardById(data.getId(),board);
    },

    /**
     * billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createTextBillboard : function (data, text, gbColor) {
        return this.createTextBillboardById(data.getId(),text, gbColor);
    },

    /**
     * billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createTextBillboardById : function (dataId, text, gbColor) {
        var node = this.dataNodeMap[dataId];
        var board = it.Util.createTextBillboardForNode(node, text, gbColor);
        this.getDataBox().add(board);
        return board;
    },

    /**
     * billboard
     * @param dataId
     * @param {width: 256,height: 128,radius: 16,arrowWidth: 16,arrowHeight: 16,bgColor: '#5B85B5'} args
     */
    createEmptyBillboardById:function(dataId, args){
        var node = this.dataNodeMap[dataId];
        var board = it.Util.createEmptyBillboardForNode(node, args);
        this.getDataBox().add(board);
        return board;
    },

    /**
     * billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createEmptyBillboard : function (data, text, gbColor) {
        return this.createEmptyBillboardById(data.getId(),text, gbColor);
    },

    /**
     * billboard
     * @param dataId
     * @param {width: 256,height: 128,radius: 16,arrowWidth: 16,arrowHeight: 16,bgColor: '#5B85B5'} args
     */
    createTitleBillboardById:function(dataId, args){
        var node = this.dataNodeMap[dataId];
        var board = it.Util.createTitleBillboardForNode(node, args);
        this.getDataBox().add(board);
        return board;
    },

    /**
     * billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createTitleBillboard : function (data, args) {
        return this.createTitleBillboardById(data.getId(),args);
    },

    /**
     * appObjorgObj
     * @param orgObj
     * @param appObj
     */
    margeObject : function(orgObj,appObj){
        orgObj = orgObj || {};
        if(!appObj){
            return orgObj;
        }
        if(appObj instanceof Array){
            for(var i = 0 ; i <  appObj.length ;i++){
                var data = appObj[i];
                if(data.getId()){
                    orgObj[data.getId()] = data;
                }
            }
        }else if(appObj instanceof mono.List){
            for(var i = 0 ; i <  appObj.size() ;i++){
                var data = appObj.get(i);
                if(data && data.getId()){
                    orgObj[data.getId()] = data;
                }
            }
        }
        else{
            for(var dataId in appObj){
                if(dataId && appObj[dataId]){
                    orgObj[dataId] = appObj[dataId];
                }
            }
        }
        return orgObj;
    },

    /**
     *  datalazyloaddata
     */
    getSceneDatas : function(rootData){
        rootData = rootData||this.getNodeData(this._currentRootNode);
        var rooDataAndScene = this.getSceneAndRootByData(rootData)||{};
        var scene = rooDataAndScene.scene || this._currentScene;
        var dm = this.dataManager;
        if (!scene) {
            return dm.getDataMap();
        }
        var categoryId = scene.getCategoryId();
        var sceneType = scene.getSceneType() || '';
        var datas = {};
        if (rootData) {
            datas[rootData.getId()] = rootData;
            if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
                var children = rootData.getChildren();
                this.margeObject(datas, children);
            } else { // data()
                var descendants = dm.getDescendants(rootData);
                this.margeObject(datas, descendants);
            }
        } else {
            var dataMap = dm.getDataMapByCategory(categoryId); // rootDataScene
            if (!dataMap || sceneType == "ShowSelf") {
                return dataMap;
            }
            for (var dataId in dataMap) {
                var data = dataMap[dataId];
                if (data) {
                    datas[dataId] = data;
                    if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
                        var children = data.getChildren();//dm.getChildren(data);
                        this.margeObject(datas, children);
                    } else { // data()
                        var descendants = dm.getDescendants(data);
                        this.margeObject(datas, descendants);
                    }
                }
            }
        }
        return datas;
    },

    getSceneDataTypes: function(rootData) {
        var dataTypes = {};
        var currentSceneDatas = this.getSceneDatas(rootData);
        if (currentSceneDatas) {
            for (var dataId in currentSceneDatas) {
                var data = currentSceneDatas[dataId];
                if (data) {
                    var dataType = this.dataManager.getDataTypeForData(data);
                    dataTypes[dataType.getId()] = dataType;
                }
            }
        }
        return dataTypes;
    },

    getDatasByAncestorId : function(){

    },

    /**
     * 2D3D
     * @returns {*|it.SceneManager._currentRootNode}
     */
    getCurrentRootNode : function(){
        return this._currentRootNode;
    },


    getLinkData : function(linkNode){
        if(!linkNode){
            return null;
        }
        var link = linkNode.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(link && (link instanceof $Link)){
            return link;
        }
        return null;
    },

     
    /**
     * dataIdnode 
     * add by Kevin 
     * 2016-10-09
     */
    removeDataNodeByDataOrId : function(dataOrId){
       if (!dataOrId) {
         return;
       }
       var dataId = dataOrId;
       if (dataOrId instanceof it.Data){
         dataId = dataOrId.getId();
       }
       var box = this.network3d.getDataBox();
       var dataNode = this.getNodeByDataOrId(dataOrId);
       if (dataNode) {
         dataNode.setParent(null);
         delete this.dataNodeMap[dataId];
         box.removeByDescendant(dataNode);
         this._sceneManagerChangeDispatcher.fire({
               kind:'remove',
               data:dataNode
         });

       }
    },

    /**
     * datadata3D
     * :()
     * add by Kevin 
     * 2016-10-11
     * data
     */
    createNodeByDataOrId : function(dataOrId){
       if (!dataOrId 
           || !this.isCurrentSceneInstance(dataOrId)) {
          return;
       }
       var data = dataOrId;
       if (!(dataOrId instanceof it.Data)){
          data = this.dataManager.getDataById(dataOrId);
       }
       if (data) {
         this.loadDataModel(data);
         this.setParentRelationShip(data); // add by Kevin 2016-11-17
         this.translatePosition(data);
       }
    },

    /**
     * ancestorIddata
     * @param dataOrId
     * @param ancestorId
     */
    isAncestor : function(dataOrId,ancestorId,scope){
        var self = scope || this;
        if(!dataOrId || !ancestorId){
            return false;
        }
        var data = null;
        if(dataOrId instanceof $Data){
            data = dataOrId;
        }else{
            data = this.dataManager.getDataById(dataOrId);
        }
        if(!data){
            return false;
        }
        var ancestor = null;
        if (ancestorId instanceof $Data) {
           ancestor = ancestorId;
           ancestorId = ancestor.getId();
        }else{
           ancestor = this.dataManager.getDataById(ancestorId);
        }
        if(!ancestor){
            return false;
        }
        if(ancestor.getParentId() && ancestor.getParentId() === data.getId()){ //
            return false;
        }
        if(data.getParentId()){
            if(data.getParentId() === ancestorId){
                return true;
            }else{
                return self.isAncestor(data.getParentId(),ancestorId,self);
            }
        }
        return false;
    },

    /**
     * SceneparentscenesceneType
     */

     lastSceneFilter : function(data){
        return true;
     },

    /**
     * data"Scene"(ScenerootData+Scene)
     * @param data
     * @param sceneMap
     * @param scope
     * @returns {*}
     */
    getLastSceneInstance : function(data,sceneMap,scope){
        var self = scope || this;
        sceneMap = sceneMap || self.dataManager._categorySceneMap;
        if(!data || !sceneMap){
            return null;
        }
        if (typeof(data) === 'string') { //dataid
           data = self.dataManager.getDataById(data);
        }
        if (!data) {
           return null;
        }
        var category = self.dataManager.getCategoryForData(data);
        if(category && sceneMap[category.getId()] && self.lastSceneFilter(data)){
            return {rootData:data , scene:sceneMap[category.getId()]};
        }else if(data && data.getParentId && data.getParentId()){
            var parent = self.dataManager.getDataById(data.getParentId());
            return self.getLastSceneInstance(parent,sceneMap,self);
        }
        return null;
    },

    /**
     * DataScene
     * @param data
     * @returns {*}
     */
    getSceneAndRootByData : function(data){
        if(!data){
            return null;
        }
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){
            return null;
        }
        return this.getLastSceneInstance(data,sceneMap);
    },

    /**
     * dataid
     * datatrue
     * @param dataOrId
     * @isNearestScene 
     * @returns {boolean}
     */
    isCurrentSceneInstance : function(dataOrId,isNearestScene){
        if(!dataOrId){
            return false;
        }
        var data = dataOrId;
        if(!(data instanceof $Data)){
            data = this.dataManager.getDataById(data);
        }
        if(!data){
            return false;
        }
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){
            return true;
        }
        var currentScene = this._currentScene;
        if(!currentScene){
            // return true;
            return false ; // turepreRender
        }
        var currentRootData = this._currentRootData||this.getNodeData(this._currentRootNode); //add By Kevin 2017-05-16
        if (!currentRootData) { // currentRootDatafalse
            return false;
        }
        if(data == currentRootData){
            return true;
        }
        if (isNearestScene) {
            var lastSceneAndRootData = this.getLastSceneInstance(data);
            if(lastSceneAndRootData 
                && lastSceneAndRootData.rootData == currentRootData 
                && lastSceneAndRootData.scene == currentScene){
                return true;
            }else{
                return false;
            }
        }
        if(currentRootData && !this.isAncestor(data,currentRootData.getId())){
            return false;
        }
        var sceneType = currentScene.getSceneType();
        if (sceneType === "ShowSelf") {
            if (currentRootData.getId() == data.getId()) {
                return true;
            }else{
                return false;
            } //20170329 earthdctruetruefalsefalseisNearestScene
        } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") { 
            if (currentRootData && (currentRootData.getId() == data.getId() 
                || currentRootData.getId() == data.getParentId())) {
                return true;
            }else{
                return false;
            }
        } else if(sceneType === "ShowThird"){
            if (currentRootData.getId() == data.getId() 
                || currentRootData.getId() == data.getParentId()) {
                return true;
            }
            var parentData = this.dataManager.getDataById(data.getParentId());
            if (parentData 
                && currentRootData.getId() == parentData.getParentId()) {
                return true;
            }
            return false;
        } else {
            return true;
        }
    },
    
    /**
     * data(scene,rootData)
     * 
     */
    isSceneInstance : function(scene,rootData,data){
        if(!scene || !rootData || !data){
           return false;
        }
        if(rootData != data && !this.isAncestor(data,rootData.getId())){
            return false;
        }
        var rdCategory = this.dataManager.getCategoryForData(rootData);
        var dCategoty = this.dataManager.getCategoryForData(data);
        if (rdCategory 
          && rdCategory.getId().toLowerCase() == 'datacenter' 
          && dCategoty 
          && dCategoty.getId() == 'floor'){
            return true;
        }
        var sceneType = scene.getSceneType();
        if (!sceneType) {
           return false;
        }
        if (sceneType === "ShowSelf") {
            if (rootData.getId() == data.getId()) {
                return true;
            }else{
                return false;
            } //20170329 earthdctruetruefalsefalseisNearestScene
        } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") { 
            if (rootData.getId() == data.getId() 
                || rootData.getId() == data.getParentId()) {
                return true;
            }else{
                return false;
            }
        } else if(sceneType === "ShowThird"){
            if (rootData.getId() == data.getId() 
                || rootData.getId() == data.getParentId()) {
                return true;
            }
            var parentData = this.dataManager.getDataById(data.getParentId());
            if (parentData 
                && rootData.getId() == parentData.getParentId()) {
                return true;
            }
            return false;
        } 
        return true;
    },

    /**
     * dataScene
     * @param data
     */
    isSceneRootData : function(data){
        if(!data){
            return false;
        }
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){
            return false;
        }
        var category = this.dataManager.getCategoryForData(data);
        if(category && sceneMap[category.getId()]){
            return true;
        }
    },

   /*
    isTheSameSceneInstance : function(data1,data2){
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){ //scenescene
            return true;
        }
    },
    */

    getAlarmManagerClass:function(){
        return it.AlarmManager;
    },

    registerCustomSceneView: function(sceneId, customSceneView) {
        if (!sceneId || !customSceneView) {
            return;
        }
        if (!this.sceneViewMap) {
            this.sceneViewMap = {};
        }
        this.sceneViewMap[sceneId] = customSceneView;
    },

    deregisterCustomSceneView : function(sceneId){
       if (sceneId && this.sceneViewMap && this.sceneViewMap[sceneId]) {
         delete this.sceneViewMap[sceneId];
       }
    },

    adjustCustomSceneViewBounds : function(w,h,left,top){
        for(var sceneId in this.sceneViewMap){
            var sceneView = this.sceneViewMap[sceneId];
            if (sceneView) {
                sceneView.adjustBounds(w,h,left,top);
            }
        }
    },

    getCurrentSceneView : function(){
       if (this._currentScene) {
         return this.sceneViewMap[this._currentScene.getId()];
       }
       return null;
    },

    /**
     * nodenode
     * 1nodenode
     *      2node
     */
    getSceneViewByNode : function(node){
        if (!node) {
            return null;
        }
        var scene = null;
        var data = this.getNodeData(node);
        if (this.isCurrentSceneInstance(data)) {
            scene = this._currentScene;
        }else {
            var sceneAndRootData = this.getSceneAndRootByData(data);
            if (sceneAndRootData && sceneAndRootData.scene) {
                scene = sceneAndRootData.scene;
            }
        }
        if (scene && this.sceneViewMap[scene.getId()]) {
            return this.sceneViewMap[scene.getId()];
        }else{
            return this.viewManager3d;
        }
    },

    getFocusNode : function(){
        return this._focusNode;
    },

    setFocusNode : function(node){
        this._focusNode = node;
        var sceneView = this.getSceneViewByNode(node);
        if (sceneView && sceneView.setFocusNode) {
            sceneView.setFocusNode(node);
        }
    },

    /**
     * 
     * 
     */
    getCurrentCamera : function(){
       var scene = this._currentScene ;
       var sceneView = null;
       if (scene) {
           sceneView = this.sceneViewMap[scene.getId()];
       }
       if (sceneView) {
           if ('upload' == sceneView.getCamera()) { //unloadnull
             return null;
           }else{
             return sceneView.getCamera();
           }
       }else{
           return this.network3d.getCamera();
       }
    },

    /**
     * lookAt
     * nodeview
     * 
     */
    lookAt : function(node, callback1) {
        var sceneView = this.getSceneViewByNode(node);
        if (sceneView) {
           this.viewManager3d.defaultEventHandler.lookAt(node,callback1);// sceneView
        }else{
           this.viewManager3d.defaultEventHandler.lookAt(node,callback1);
        }
    }
    
});
// 

var $MaterialFilter =  function  (argument) {
	
}; 
it.MaterialFilter = $MaterialFilter;
mono.extend($MaterialFilter,Object,{
	filterMaterial : function(originalMaterial,filterdMaterial,node){
        return originalMaterial;
	},
});

var $VisibleFilter = function(arguments){

};

mono.extend($VisibleFilter,Object,{
    isVisible: function(node,data,network){
        return true;
    }
});

it.VisibleFilter = $VisibleFilter;

/**
* 
*/
var $LightManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.sceneLights = {};
	this.init();
};

mono.extend($LightManager,Object,{

	init:  function(){
		var self = this;
		this.sceneManager.addSceneChangeListener(function(eve){
			var scene = eve.data;
            self.setUpLights(scene);
		});
	},

	getDefaultLights: function() {
		var lights = {};
		var ambientLight = new mono.AmbientLight(0xFFFFFF);
		lights['a'] = ambientLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(10000, 10000, 10000);
		lights['p1'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(-10000, 10000, -10000);
		lights['p2'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(10000, 10000, -10000);
		lights['p3'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(-10000, 10000, 10000);
		lights['p4'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(0, 0, 10000);
		lights['p5'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(0, 0, -10000);
		lights['p6'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(10000, 0, 0);
		lights['p7'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(0, 0, -10000);
		lights['p8'] = pointLight;
		return lights;
	},

	setUpLights : function(sceneOrId){
		var lights = {};
		var id = sceneOrId;
		this.clearLights();
		if (sceneOrId instanceof it.Scene) {
			id = sceneOrId.getId();
		}
		if (!id || !this.sceneLights[id]) { //
			lights = this.getDefaultLights();
		}else{
			lights = this.sceneLights[id];
		}
		var dataBox = this.sceneManager.network3d.getDataBox();
		for (var pro in lights) {
			var light = lights[pro];
			dataBox.add(light);
		}
	},

	clearLights : function(){
		var dataBox = this.sceneManager.network3d.getDataBox();
		var lights = [];
		for (var i = 0; i < dataBox.size(); i++) {
			var light = dataBox.getLights().get(i);
			if (light) {
				lights.push(light);
			};
		};
		for(var i = 0 ; i < lights.length ; i++){
			var light = lights[i];
			dataBox.remove(light);
		}
	},

	addSceneLight : function(light){ 
		if (!light) {
			return;
		}
		var sceneId = light.getSceneId();
		var lightId = light.getId();
		var lightObj = null;
		if (light.getType().toLowerCase().indexOf('am')>=0) {
			lightObj = new mono.AmbientLight(light.getColor());
		}else{
			lightObj = new mono.PointLight(light.getColor(),light.getIntensity()||1,light.getDistance()||0);
		    lightObj.setPosition(light.getPosition());
		}
		var allLights = this.sceneLights[sceneId];
		if (!allLights) {
           this.sceneLights[sceneId] = {lightId:lightObj}; 
		}else{
			allLights[lightId] = lightObj;
		}
	},

    /**
     * light
    */
	removeSceneLight : function(light){
        if (!light) {
			return;
		}
		var sceneId = light.geSceneId();
		var lightId = light.getId();
		var lights = this.sceneLights[sceneId];
		if (lights){
			delete lights[lightId];
			// disparch...
		} 
	},

	addLightsFromJson : function(json){
		var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       var i = 0,len = jsonObjects.length;

       for(i = 0;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var light = new $Light();
          light.fromJson(jsonObject);
          this.addSceneLight(light);
       }
	}


});


it.LightManager = $LightManager;
/**
 * 
 * @param value {number} 
 * @param name {string} ()
 * @param nickName {string} 
 * @param color {string} 
 * @param displayName {string} 
 * @constructor
 */
it.AlarmSeverity = function (value, name, nickName, color, displayName) {
    it.Base.call(this);
    this.value = value;
    this.name = name;
    this.nickName = nickName;
    this.color = color;
    this.displayName = displayName;
};
mono.extend(it.AlarmSeverity, it.Base, {
    IT_Alarm_Severity: true,
});
(function () {
    var s = it.AlarmSeverity;
    s.severities = new mono.List();
    s._vm = {};
    s._nm = {};
    s._cp = function (s1, s2) {
        if (s1 && s2) {
            var v = s1.value - s2.value;
            if (v > 0) return 1;
            if (v < 0) return -1;
            return 0;
        }
        if (s1 && !s2) return 1;
        if (!s1 && s2) return -1;
        return 0;
    };
    s.forEach = function (callbackFunction, scope) {
        s.severities.forEach(callbackFunction, scope)
    };
    s.getSortFunction = function () {
        return s._cp;
    };
    s.setSortFunction = function (sortFunction) {
        s._cp = sortFunction;
        s.severities.sort(sortFunction);
    }
    s.add = function (value, name, nickName, color, displayName) {
        var severity = new s(value, name, nickName, color, displayName);
        s._vm[value] = severity;
        s._nm[name] = severity;
        s.severities.add(severity);
        s.severities.sort(s._cp);
        return severity;
    };
    s.remove = function (name) {
        var severity = s._nm[name];
        if (severity) {
            delete s._nm[name];
            delete s._vm[severity.value];
            s.severities.remove(severity);
        }
        return severity;
    };
    s.CRITICAL = s.add(500, "Critical", "C", '#FF0000');
    s.MAJOR = s.add(400, "Major", "M", '#FFA000');
    s.MINOR = s.add(300, "Minor", "m", '#FFFF00');
    s.WARNING = s.add(200, "Warning", "W", '#00FFFF');
    s.INDETERMINATE = s.add(100, "Indeterminate", "N", '#C800FF');
    s.CLEARED = s.add(0, "Cleared", "R", '#00FF00');
    s.isClearedAlarmSeverity = function (severity) {
        return severity ? severity.value === 0 : false;
    };
    s.getByName = function (name) {
        return s._nm[name];
    };
    s.getByValue = function (value) {
        return s._vm[value];
    };
    s.clear = function () {
        s.severities.clear();
        s._vm = {};
        s._nm = {};
    };
    s.compare = function (severity1, severity2) {
        return s._cp(severity1, severity2);
    }
})();
/**
 * ,mono.Alarm,it.Alarmit.Data
 * @param id {string} id,
 * @param dataId {string} id
 * @param {it.AlarmSeverity} severity 
 * @param alarmType {it.AlarmType} 
 * @param description {string} 
 * @constructor
 */
it.Alarm = function (id, dataId, alarmSeverity, description, dateTime) {
    it.Base.call(this);
    this._id = id;
    this._dataId = dataId;
    this._alarmSeverity = alarmSeverity || it.AlarmSeverity.CRITICAL;
    this._dateTime = dateTime;
    this._description = description;
    if (!this._alarmSeverity.IT_Alarm_Severity) {
        throw 'alarmSeverity is not it.AlarmSeverity'
    }
};

mono.extend(it.Alarm, it.Base, {
    ___accessor: ['alarmSeverity', 'alarmType', 'description', 'dateTime'],

    IT_Alarm: true,

    getId: function () {
        return this._id;
    },

    getDataId: function () {
        return this._dataId;
    },

    fromJson: function (json) {
        json = json || "";
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._dataId = json.dataId;
        this._alarmSeverity = it.AlarmSeverity.getByName(json.level);
        this._dateTime = json.time;
        this._description = json.description;
    },

});
/**
 * 
 * :,
 * selfHighestAlarmSeverity - 
 * selfAlarmCount - 
 * propagateHighestAlarmSeverity - 
 * propagateAlarmCount - 
 * highestAlarmSeverity - , 
 * alarmCount - , 
 * @param data {it.Data} data
 * @constructor
 */
it.AlarmState = function (data) {
    it.Base.call(this);
    this._data = data;
    this._selfHighestAlarmSeverity = null;
    this._selfAlarmCount = 0;
    this._propagateHighestAlarmSeverity = null;
    this._propagateAlarmCount = 0;
    this._highestAlarmSeverity = null;
    this._alarmCount = 0;
};
mono.extend(it.AlarmState, it.Base, {

    ___accessor: ['selfHighestAlarmSeverity', 'selfAlarmCount', 'propagateHighestAlarmSeverity', 'propagateAlarmCount', 'highestAlarmSeverity', 'alarmCount'],
    IT_Alarm_Status: true,
    clear: function () {
        this._selfHighestAlarmSeverity = null;
        this._selfAlarmCount = 0;
        this._propagateHighestAlarmSeverity = null;
        this._propagateAlarmCount = 0;
        this._highestAlarmSeverity = null;
        this._alarmCount = 0;
    }
});

/**
 * 
 * :SDK,,:,SDK,
 * * :
 *  1,:  + billboard
 *  2,:  + billboard
 *  3,: () + () + billboard()
 * : scene -> category -> dataType -> data
 * it.DataManager, it.DataManager it.AlarmManager.
 * @extend Base
 * @param {it.DataManager} dataManager
 * @param {it.SceneManager} sceneManager
 * @constructor
 */
it.AlarmManager = function (dataManager, sceneManager) {
    it.Base.call(this);
    this._dataManager = dataManager;
    this._sceneManager = sceneManager;

    /**
     *
     * @type {mono.List} 
     * @private
     */
    this._alarmList = new mono.List();

    /**
     *
     * @type {{}} keyid, vlaue
     * @private
     */
    this._alarmMap = {};

    /**
     *
     * @type {{}} keydataid, value(mono.List),data
     * @private
     */
    this._dataAlarms = {};

    /**
     * 
     * @type {Array}
     * @private
     */
    this._dirtyDataAlarmState = [];

    /**
     *  billboard 
     * @type {{}}
     * @private
     */
    this._alarmBillboardMap = {};

    /**
     *  node 
     * @type {{}}
     * @private
     */
    this._alarmNodeMap = {};

    /**
     * 
     * @type {{}}
     * @private
     */
    this._alarmSmokeMap = {};

    /**
     * 
     * @type {mono.EventDispatcher}
     * @private
     */
    this._alarmManagerChangeDispatcher = new mono.EventDispatcher();

    /**
     * 
     * @type {mono.EventDispatcher}
     * @private
     */
    this._alarmPropertyChangeDispatcher = new mono.EventDispatcher();

    this.renderType = it.AlarmManager.RENDER_TYPE_DEFAULT;

    this._sceneManager.addSceneManagerChangeListener(this.handleSceneManagerChange, this, true);
    this._dataManager.addDataManagerChangeListener(this.handleDataManagerChange, this, true);
    this.addAlarmPropertyChangeListener(this.handleAlarmPropertyChange, this, true);
    this.addAlarmManagerChangeListener(this.handleAlarmManagerChange, this, true);

    this.intervalId = '';  //
};

it.AlarmManager.RENDER_TYPE_DEFAULT = 0; //, ,  billboard
it.AlarmManager.RENDER_TYPE_PAINT = 1; //, ,  billboard
it.AlarmManager.RENDER_TYPE_PAINT_BILLBOARD = 2; //, ,  billboard

/**
 *
 */
mono.extend(it.AlarmManager, it.Base, {
    __accessor: ['removeAlarmWhenDataIsRemoved'],

    _name: 'AlarmBox',

    /**
     * 
     * @param matchFunction , true,
     * @param scope 
     * @returns {mono.List} 
     */
    getAlarms: function (matchFunction, scope) {

        return this._alarmList.toList(matchFunction, scope);
    },

    /**
     * dirtydata
     * @private
     */
    _calculateDataPropagateAlarmState: function () {

        while (this._dirtyDataAlarmState.length > 0) {
            var data = this._dirtyDataAlarmState.pop();
            this.calculateDataPropagateAlarmState(data);
        }

    },

    _setDataAlarmStateDirty: function (data) {
        data['_alarmRenderDirty'] = true;
    },
    _clearDataAlarmStateDirty: function (data) {
        delete data['_alarmRenderDirty'];
    },
    _isDataAlarmStateDirty: function (data) {
        return data['_alarmRenderDirty'];
    },

    /**
     * datadirty,
     * @param data
     * @private
     */
    _dirtyParentDataAlarmState: function (data, isSkipRender) {

        var parent = this._dataManager.getParent(data);
        if (parent) {
            var self = this;
            var alarmState = parent.getAlarmState();
            var alarmCount = alarmState.getSelfAlarmCount();
            // 2017-10-27 parentparentskipparent
            if (alarmCount <= 0) {
                parent.isSkipRender = isSkipRender;
            }else{
                parent.isSkipRender = null;
            }
            clearTimeout(parent._dirtyParentTimerId);
            parent._dirtyParentTimerId = setTimeout(function() {
                self._dirtyDataAlarmState.push(parent);
                if (self._dirtyDataAlarmState) {
                    self._calculateDataPropagateAlarmState();
                }
            }, 10);
        } else if (this._dirtyDataAlarmState) {
            this._calculateDataPropagateAlarmState();
        }
    },

    /**
     * data,,parentData
     * @param data {it.Data} data
     */
    calculateDataAlarmState: function (data) {

        var alarmStateValue = this.getDataAlarmState(data);//
        var alarmState = data.getAlarmState();
        var alarmCount = alarmState.getSelfAlarmCount();
        var highestAlarmSeverity = alarmState.getSelfHighestAlarmSeverity();
        //, 
        if (alarmCount == alarmStateValue.alarmCount
            && it.AlarmSeverity.compare(alarmStateValue.highestAlarmSeverity, highestAlarmSeverity) == 0) {
            return;
        }
        alarmState.setSelfHighestAlarmSeverity(alarmStateValue.highestAlarmSeverity);
        alarmState.setSelfAlarmCount(alarmStateValue.alarmCount);
        //2017-10-27 parentparentskipchildparentskiprenderTRUE
        if (alarmStateValue.alarmCount > 0) {
            data.isSkipRender = null;
        }
        this._calculateDataAlarmState(data);
        
        
        // 
        var isSkipRender = this._dataManager.isStopAlarmPropagation(data) || data.isSkipRender;
        this._dirtyParentDataAlarmState(data, isSkipRender);

    },

    /**
     * data,, parentData
     * @param data
     */
    calculateDataPropagateAlarmState: function (data) {


        var children = this._dataManager.getChildren(data);
        var result = {
            highestAlarmSeverity: null,
            alarmCount: 0,
        };
        if (children) {
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                var alarmState = child.getAlarmState();
                result.alarmCount += alarmState.getAlarmCount();
                result.highestAlarmSeverity = this._getHighestAlarmSeverity(result.highestAlarmSeverity, alarmState.getHighestAlarmSeverity())
            }
        }
        var alarmState = data.getAlarmState();
        var alarmCount = alarmState.getPropagateAlarmCount();
        var highestAlarmSeverity = alarmState.getPropagateHighestAlarmSeverity();
        //if (alarmCount == result.alarmCount
        //    && it.AlarmSeverity.compare(result.highestAlarmSeverity, highestAlarmSeverity) == 0) {
        //    return;
        //}
        alarmState.setPropagateAlarmCount(result.alarmCount);
        alarmState.setPropagateHighestAlarmSeverity(result.highestAlarmSeverity);
        this._calculateDataAlarmState(data);

        
        // 
        var isSkipRender = this._dataManager.isStopAlarmPropagation(data) || data.isSkipRender;
        this._dirtyParentDataAlarmState(data, isSkipRender);
    },


    /**
     * 
     * 
     * 
     * @param alarmState
     * @private
     */
    _calculateDataAlarmState: function (data) {

        var alarmState = data.getAlarmState();
        var result = {
            highestAlarmSeverity: null,
            alarmCount: 0,
        };
        result.alarmCount = alarmState.getSelfAlarmCount() + alarmState.getPropagateAlarmCount();
        result.highestAlarmSeverity = this._getHighestAlarmSeverity(result.highestAlarmSeverity, alarmState.getSelfHighestAlarmSeverity())
        result.highestAlarmSeverity = this._getHighestAlarmSeverity(result.highestAlarmSeverity, alarmState.getPropagateHighestAlarmSeverity())
        alarmState.setAlarmCount(result.alarmCount);
        alarmState.setHighestAlarmSeverity(result.highestAlarmSeverity);
        this._setDataAlarmStateDirty(data);
        this.renderDataAlarm(data);
    },

    /**
     * 
     * @param severity1 {it.AlarmSeverity} severity1
     * @param severity2 {it.AlarmSeverity} severity2
     * @returns {it.AlarmSeverity} severity1severity2
     * @private
     */
    _getHighestAlarmSeverity: function (severity1, severity2) {
        return it.AlarmSeverity.compare(severity1, severity2) > 0 ? severity1 : severity2;
    },

    renderDataAlarm: function (data) {
        // isSkipRender=true, , 
        if (data.isSkipRender && !this.isForceRenderData(data)) {
            return;
        }
        if (!this._sceneManager.isCurrentSceneInstance(data)) {
            this._setDataAlarmStateDirty(data);
            return;
        }
        var node = this._sceneManager.getNodeByDataOrId(data);
        if (!node && this._sceneManager.earthScene && this._sceneManager.earthScene.dataCenterNodeMap) {
            node = this._sceneManager.earthScene.dataCenterNodeMap[data.getId()]
        }
        if (node && this._isDataAlarmStateDirty(data)) {
            this._renderAlarm(data, node);
        } else if (!node) {
            this._setDataAlarmStateDirty(data);
        }
    },

    /**
     *  data
     * @param data
     * @returns {boolean}
     */
    isForceRenderData: function (data) {
        return false;
    },

    /**
     * 
     * @param data {it.Data} data
     * @param node {mono.Data} node
     */
    _renderAlarm: function (data, node) {

        this._clearDataAlarmStateDirty(data);
        var scene = this._sceneManager.getCurrentScene();
        if (scene && scene.renderAlarm) {
            scene.renderAlarm(data, node);
            return;
        }
        var category = this._dataManager.getCategoryForData(data);
        if (category && category.renderAlarm) {
            category.renderAlarm(data, node);
            return;
        }
        var dataType = this._dataManager.getDataTypeForData(data);
        if (dataType && dataType.renderAlarm) {
            dataType.renderAlarm(data, node);
            return;
        }
        this.renderAlarm(data, node);
    },

    /**
     * 
     * @param data
     * @param node
     */
    renderAlarm: function (data, node) {

        if (this.renderType == it.AlarmManager.RENDER_TYPE_PAINT) {

            //, 
            var alarmState = data.getAlarmState();
            if (alarmState.getAlarmCount() > 0) {

                var alarmSeverity = alarmState.getHighestAlarmSeverity();
                this.paintDataColor(data, node, alarmSeverity);
            } else {

                this.clearDataColor(data, node);
            }
        } else if (this.renderType == it.AlarmManager.RENDER_TYPE_PAINT_BILLBOARD) {

            //, 
            var alarmState = data.getAlarmState();
            if (alarmState.getAlarmCount() > 0) {

                var alarmSeverity = alarmState.getHighestAlarmSeverity();
                this.paintDataColor(data, node, alarmSeverity);
            } else {

                this.clearDataColor(data, node);
            }

            //
            var parentData = this._dataManager.getParent(data);
            //parent,,0,billboard
            if (alarmState.getAlarmCount() > 0 && (!parentData || this._dataManager.isStopAlarmPropagation(data))) {

                this.showDataBillboard(data, node);
            } else if (this._alarmBillboardMap[data.getId()]) {
                this.hideDataBillboard(data, node);
            }
        } else {
            //
            var alarmState = data.getAlarmState();
            if (alarmState.getSelfAlarmCount() > 0) {

                this.paintDataColor(data, node);

                // -- yxk
                this.createSmokeAlarm(data, node); 
            } else {

                this.clearDataColor(data, node);
                this.removeSmokeAlarm(data, node);
            }

            //
            var parentData = this._dataManager.getParent(data);
            //parent,,0,billboard
            if (alarmState.getAlarmCount() > 0 && (!parentData || this._dataManager.isStopAlarmPropagation(data))) {

                this.showDataBillboard(data, node);
            } else if (this._alarmBillboardMap[data.getId()]) {
                this.hideDataBillboard(data, node);
            }
        }
    },

    createSmokeAlarm: function (data,node) {
        if (this._alarmSmokeMap[data.getId()]) {
            return;
        }
        var categoryId = this._dataManager.getCategoryForData(data).getId();
        if(categoryId != 'smoke')return;

        // var node = this._sceneManager.getNodeByDataOrId(data);
        var alarms = this.getAlarmsByDataOrId(data);
        if (alarms) {
            alarms = alarms._as;
            // var highest = -1, color, hasSmoke = false;
            for(var i=0; i<alarms.length;i++){
                alarm = alarms[i];
                if (alarm.alarmTypeId == 'smoke') {
                    var smokeNode = this.addSmoke(node, alarm._alarmSeverity.color);
                    smokeNode.setClient(it.SceneManager.CLIENT_IT_DATA, data);
                    smokeNode.setClient(it.SceneManager.CLIENT_IT_DATA_ID, data.getId());
                    this._alarmSmokeMap[data.getId()] = smokeNode;
                    this.startSmokeAnimation(this._alarmSmokeMap);
                    break;
                }
            }
            // alarms.forEach(function (alarm) {
            //     if (alarm.alarmTypeId == 'smoke') {
            //         hasSmoke = true;
            //         if(alarm._alarmSeverity.value>highest){
            //             highest = alarm._alarmSeverity.value;
            //             color = alarm._alarmSeverity.color;
            //         }
            //     }
            // }, this);
            // if(hasSmoke){
            //     var smokeNode = this.addSmoke(node, color);
            //     this._alarmSmokeMap[data.getId()] = smokeNode;
            //     this.startSmokeAnimation(data,smokeNode);
            // }
            
        }
    },
    //node
    createSmokeNode: function (color) {
        var smoke = new mono.Particle();
        var count = 200;
        for (var j = 0; j < count; j++) {
            smoke.vertices.push(new mono.Vec3());
        }
        smoke.verticesNeedUpdate = true;
        smoke.sortParticles = false;
        smoke.setStyle('m.size', 20);
        smoke.setStyle('m.color', color);
        smoke.setStyle('m.depthTest', false);
        smoke.setStyle('m.transparent', true);
        smoke.setStyle('m.opacity', 0.6);
        smoke.setClient('_alarmParticle', 'true');
        smoke.setStyle('m.texture.image', 'data:image/png;base64,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');
        return smoke;
    },

    //
    addSmoke: function (node, color) {
        var smoke = this.createSmokeNode(color);
        smoke.setParent(node);
        var bBox = node.getBoundingBox();
        var height = bBox.max.y - bBox.min.y;
        smoke.p(0, height * 3, 0);
        this._sceneManager.network3d.dataBox.add(smoke);
        return smoke;
    },
    updateSmoke: function (smokeNodeMap) {
        var network = this._sceneManager.network3d;
        return function () {
            for (var dataId in smokeNodeMap) {
                var smokeNode = smokeNodeMap[dataId];
                if (smokeNode.isVisible()) {
                    var count = smokeNode.vertices.length;
                    for (var i = 0; i < count; i++) {
                        var point = smokeNode.vertices[i];
                        point.y = Math.random() * 200;
                        point.x = Math.random() * point.y / 2 - point.y / 4;
                        point.z = Math.random() * point.y / 2 - point.y / 4;
                    }
                    smokeNode.verticesNeedUpdate = true;
                }
            }
            network.dirtyNetwork();
        }
    },
    startSmokeAnimation: function (smokeNodeMap) {
        this.removeSmokeAnimation();
        var arr = Object.keys(smokeNodeMap);
        if (arr.length == 0) {
            return;
        }
        var intervalId = setInterval(this.updateSmoke(smokeNodeMap), 100);
        this.intervalId = intervalId;
    },
    removeSmokeAlarm: function (data) {
        var smokeNode = this._alarmSmokeMap[data.getId()];
        if (!smokeNode) {
            return;
        }
        smokeNode.setParent(null);
        this._sceneManager.network3d.dataBox.remove(smokeNode);
        delete this._alarmSmokeMap[data.getId()];
        this.startSmokeAnimation(this._alarmSmokeMap);
    },
    removeSmokeAnimation: function () {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    },

    /**
     * 
     */
    paintDataColor: function (data, node, alarmSeverity) {

        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        var alarmState = data.getAlarmState();
        var alarmSeverity = alarmSeverity || alarmState.getSelfHighestAlarmSeverity();
        this._setNodeAlarmEffect(node, alarmSeverity);
        this._alarmNodeMap[node.getId()] = node;

        //, 
        var children = node.getChildren();
        var length = children.size();
        for (var i = 0; i < length; i++) {
            var childTemp = children.get(i);
            if (childTemp.getClient('modelParent')) {
                this._setNodeAlarmEffect(childTemp, alarmSeverity);
                this._alarmNodeMap[childTemp.getId()] = childTemp;
            }
        }
    },

    /**
     * 
     */
    clearDataColor: function (data, node) {

        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        //, , 
        if (!node.getStyle('alarm.m.ambient')) {
            return;
        }
        this._clearNodeAlarmEffect(node);
        delete this._alarmNodeMap[node.getId()];

        var children = node.getChildren();
        var length = children.size();
        for (var i = 0; i < length; i++) {
            var childTemp = children.get(i);
            if (childTemp.getClient('modelParent')) {
                this._clearNodeAlarmEffect(childTemp);
                delete this._alarmNodeMap[childTemp.getId()];
            }
        }
    },

    showDataBillboard: function (data, node) {

        var alarmState = data.getAlarmState();
        var alarmSeverity = alarmState.getHighestAlarmSeverity();
        var color = null;
        if (alarmSeverity) {
            color = alarmSeverity.color;
        }
        var alarmBillboard = null;
        if (this._alarmBillboardMap[data.getId()]) {
            alarmBillboard = this._alarmBillboardMap[data.getId()]
        } else {
            alarmBillboard = this._sceneManager.createEmptyBillboardById(data.getId());
            this.initAlarmBillboard(alarmBillboard, data);
            this._alarmBillboardMap[data.getId()] = alarmBillboard;
        }
        alarmBillboard.setStyle('m.texture.image', mono.ImageCache.AlarmBillboardImage);
        alarmBillboard.setStyle('m.color', color);
        alarmBillboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
        this._setAlarmBillboardPositionAndSize(node, alarmBillboard);
    },

    hideDataBillboard: function (data, node) {

        this._sceneManager.removeBillboard(this._alarmBillboardMap[data.getId()]);
        delete this._alarmBillboardMap[data.getId()];
    },

    /**
     *   billboard
     * @param billboard
     * @param data
     * @returns {*}
     */
    initAlarmBillboard: function (billboard, data) {
        billboard.setClient('_alarmBillboard', data);

        // billboardnode
        // 2017.12.29 add by lyz
        var node = this._sceneManager.getNodeByDataOrId(data);
        node.setClient('_alarmBillboard', billboard);
    },

    _setAlarmBillboardPositionAndSize: function (node, alarmBillboard) {
        var position = node.getStyle('alarm.billboard.position');
        var boundingBox = node.getBoundingBox();
        var min = boundingBox.min;
        var max = boundingBox.max;
        var center = boundingBox.center();
        var size = boundingBox.size();
        if (position === 'topLeft') {
            alarmBillboard._position.set(min.x, max.y, center.z + 1);
        } else if (position === 'topRight') {
            alarmBillboard._position.set(max.x, max.y, center.z + 1);
        } else if (position === 'topBack') {
            alarmBillboard._position.set(center.x, max.y, min.z - 1);
        } else if (position === 'topFront') {
            alarmBillboard._position.set(center.x, max.y, max.z + 1);
        } else {
            alarmBillboard._position.set(center.x, max.y, center.z + 1);
        }

        var scale = node.getStyle('alarm.billboard.scale');
        if (scale instanceof mono.Vec3) {
            alarmBillboard._scale.copy(scale);
        } else {
            alarmBillboard._scale.set(size.x / 2, size.x / 2, 1);
        }

        var vertical = node.getStyle('alarm.billboard.vertical');
        alarmBillboard.setStyle('m.vertical', vertical);
    },

    _setNodeAlarmEffect: function (node, alarmSeverity) {
        //
        var oldColor = node.getStyle('alarm.m.ambient') || node.getStyle('m.ambient');
        var color = alarmSeverity ? alarmSeverity.color : oldColor;
        node.setStyle('m.ambient', color);
        node.setStyle('m.color', color);
        node.setStyle('alarm.m.ambient', oldColor);
    },

    _clearNodeAlarmEffect: function (node) {
        var color = node.getStyle('alarm.m.ambient');
        node.setStyle('m.ambient', color);
        node.setStyle('m.color', color);
        node.setStyle('alarm.m.ambient', null);
    },

    /**************************  alarm begin *******************************/


    _add: function (alarm) {
        this._alarmList.add(alarm);
        this._alarmMap[alarm.getId()] = alarm;
        var alarms = this._dataAlarms[alarm.getDataId()];
        if (!alarms) {
            alarms = this._dataAlarms[alarm.getDataId()] = new mono.List();
        }
        alarms.add(alarm);
    },

    _remove: function (alarm) {
        this._alarmList.remove(alarm);
        delete this._alarmMap[alarm.getId()];
        var alarms = this._dataAlarms[alarm.getDataId()];
        if (alarms) {
            alarms.remove(alarm);
        }
        if (alarms.size() == 0) {
            delete this._dataAlarms[alarm.getDataId()];
        }
    },

    /**
     * 
     * @param alarmOrId {string|it.Alarm} id
     * @returns {it.Alarm}
     */
    getAlarm: function (alarmOrId) {
        if (!alarmOrId) {
            return null;
        }
        var alarm = null;
        if (alarmOrId.IT_Alarm) {
            alarm = this._alarmMap[alarmOrId.getId()];
        } else {
            alarm = this._alarmMap[alarmOrId];
        }
        return alarm;
    },


    /**
     * 
     * @param {it.Alarm} alarm 
     */
    add: function (alarm) {
        if (!alarm) {
            throw 'alarm is null or undefined'
        }
        if (!alarm.getId()) {
            throw 'alarm`s id is empty'
        }
        if (!alarm.getDataId()) {
            throw 'alarm`s dataId is empty'
        }
        if (!alarm.IT_Alarm) {
            throw "alarm`s class is not it.Alarm";
        }
        var a = this._alarmMap[alarm.getId()];
        if (a) {
            throw 'alarm`s id repeat';
        }
        //data,,data
        var d = this._dataManager.getDataById(alarm.getDataId())
        if (!d) {
            alarm.error = 'data is not exist';
            console.warn(alarm.error)
        }
        this._add(alarm);
        this._alarmManagerChangeDispatcher.fire({
            kind: 'add',
            data: alarm
        });
        alarm.addPropertyChangeListener(this.handleAlarmDataPropertyChange, this);
    },

    /**
     * jsonalarms
     * @param json
     */
    addAlarmFromJson: function (json) {

        var jsonObjects = $Util.toJsonArray(json);
        var i = 0, len = jsonObjects.length;
        for (; i < len; i++) {
            var jsonObject = jsonObjects[i];
            var alarm = new it.Alarm();
            alarm.fromJson(jsonObject);
            this.add(alarm);
        }
    },

    /**
     * 
     * @param {string|it.Alarm} alarmid
     * return alarm
     */
    remove: function (alarmOrId) {
        if (!alarmOrId) {
            throw 'alarmOrId is null or undefined'
        }
        var alarm = null;
        if (alarmOrId.IT_Alarm) {
            alarm = this._alarmMap[alarmOrId.getId()]
        } else {
            alarm = this._alarmMap[alarmOrId]
        }
        if (!alarm) {
            console.warn('alarm is not exist');
            return;
        }
        this._remove(alarm);
        alarm.removePropertyChangeListener(this.handleAlarmDataPropertyChange, this);
        this._alarmManagerChangeDispatcher.fire({
            kind: 'remove',
            data: alarm
        });
        return alarm;
    },

    clear: function () {
        var list = this._alarmList.toList();
        this._alarmList.clear();
        this._alarmMap = {};
        this._dataAlarms = {};
        this._dirtyDataAlarmState = [];
        this._alarmManagerChangeDispatcher.fire({
            kind: 'clear',
            datas: list
        });
        return list;
    },
    /**************************  alarm end *******************************/

    /**************************  data begin *******************************/

    /**
     * id
     * @param dataOrId id
     * @returns {*|mono.List}
     */
    getAlarmsByDataOrId: function (dataOrId) {

        if (!dataOrId) {
            return [];
        }
        var dataId = dataOrId;
        if (dataOrId.IT_Data) {
            dataId = dataOrId.getId();
        }
        return this._dataAlarms[dataId];
    },

    /**
     * id
     * @param dataOrId id
     */
    removeAlarmsByDataOrId: function (dataOrId) {

        var alarms = this.getAlarmsByDataOrId(dataOrId);
        if (alarms) {
            alarms = alarms.toList();
            alarms.forEach(this.remove, this);
        }
        return alarms;
    },

    /**
     * id
     * @param alarmOrId {string|it.Alarm}  id
     * @returns {it.Data}
     */
    getDataByAlarmOrId: function (alarmOrId) {

        var alarm = this.getAlarm(alarmOrId);
        if (!alarm) {
            return null;
        }
        var dataId = alarm.getDataId();
        return this._dataManager.getDataById(dataId);
    },

    /**
     *  , 
     * @param data
     * @returns {{highestAlarmSeverity: null, alarmCount: number}}
     */
    getDataAlarmState: function (data) {
        var result = {
            highestAlarmSeverity: null,
            alarmCount: 0,
        };
        var alarms = this.getAlarmsByDataOrId(data);
        if (alarms) {
            result.alarmCount = alarms.size();
            alarms.forEach(function (alarm) {
                if (!result.highestAlarmSeverity) {
                    result.highestAlarmSeverity = alarm.getAlarmSeverity();
                } else {
                    var severity = alarm.getAlarmSeverity();
                    if (it.AlarmSeverity.compare(severity, result.highestAlarmSeverity) > 0) {
                        result.highestAlarmSeverity = severity;
                    }
                }
            })
        }
        return result;
    },

    /**************************  data end *******************************/



    /**************************  alarm change handler begin *******************************/
    /**
     * data
     * @param e
     */
    handleAlarmManagerChange: function (e) {
        if (e.kind === 'add') {
            var alarm = e.data;
            var data = this._dataManager.getDataById(alarm.getDataId());
            if (data) {
                var self = this;
                clearTimeout(data._calculateTimerId);
                data._calculateTimerId = setTimeout(function () {
                  self.calculateDataAlarmState(data);
                },100);

            }
        } else if (e.kind === 'remove') {
            var alarm = e.data;
            var data = this._dataManager.getDataById(alarm.getDataId());
            if (data) {
                var self = this;
                // clearTimeout(data._calculateTimerId);
                // data._calculateTimerId = setTimeout(function () {
                self.calculateDataAlarmState(data);
                // })
            }
        } else if (e.kind === 'clear') {

            //
            var alarms = e.datas;
            if (alarms && alarms.size() > 0) {
                //dataId
                var dataArr = this._dataManager.getDatas();
                if (dataArr && dataArr.length > 0) {
                    var len = dataArr.length;
                    //
                    for (var i = 0; i < len; i++) {
                        var data = dataArr[i];
                        var state = data.getAlarmState();
                        if (state.getAlarmCount()) {
                            state.clear();
                        }
                    }
                }
                for (var id in this._alarmBillboardMap) {
                    this._sceneManager.removeBillboard(this._alarmBillboardMap[id]);
                }
                this._alarmBillboardMap = {};
                for (var id in this._alarmNodeMap) {
                    this._clearNodeAlarmEffect(this._alarmNodeMap[id]);
                }
                this._alarmNodeMap = {};
                for (var id in this._alarmSmokeMap) {
                    var data = this.sceneManager.dataManager.getDataById(id);
                    this.removeSmokeAlarm(data);
                }
                this._alarmSmokeMap = {};
            }
        }
    },


    /**
     *  FIXME
     * @param e
     */
    handleAlarmDataPropertyChange: function (e) {
        this._alarmPropertyChangeDispatcher.fire(e);
    },
    /**
     * 
     * @param e
     */
    handleAlarmPropertyChange: function (e) {
        var alarm = e.source;
        if (e.property === "alarmSeverity") {
            var data = this._dataManager.getDataById(alarm.getDataId());
            if (data) {
                this.calculateDataAlarmState(data);
            }
        }
    },
    /**************************  alarm change handler end *******************************/

    /**************************  data change handler begin *******************************/
    /**
     * 
     * node
     * @param e
     */
    handleDataManagerChange: function (e) {
        if (e.kind === 'add') {
            //,data,
            this.calculateDataAlarmState(e.data);
        } else if (e.kind === 'remove') {
            //data
            var data  = e.data
            this.removeAlarmsByDataOrId(data);
            //
            var isSkipRender = this._dataManager.isStopAlarmPropagation(data) || data.isSkipRender;
            this._dirtyParentDataAlarmState(data, isSkipRender);
        } else if (e.kind === 'clear') {
            //FIXME dataManager`clear`
            //for (var dataId in dataIds) {
            //    var data = this._dataManager.getDataById(dataId);
            //    if (data) {
            //        data.getAlarmState().clear();
            //    }
            //}
            ////
            //this.clear();
        }
    },

    /**************************  data change handler end *******************************/

    /**************************  scene change handler begin *******************************/
    /**
     * 
     * node
     * @param e
     */
    handleSceneManagerChange: function(e) {
        var self = this;
        if (e.kind === 'add') {
            var node = e.data;
            var data = this._sceneManager.getNodeData(node);
            // setTimeout(function () {
            self.renderDataAlarm(data);
            // }, 10)
        } else 
        if (e.kind === 'change') {
            var node = e.data;
            var data = this._sceneManager.getNodeData(node);
            // var data = e.rootData;
            if (data) {
                this._setDataAlarmStateDirty(data);
                this.renderDataAlarm(data);
            }
        }
    },

    /**************************  scene change handler end *******************************/



    addAlarmManagerChangeListener: function (listener, scope, ahead) {
        this._alarmManagerChangeDispatcher.add(listener, scope, ahead);
    },

    removeAlarmManagerChangeListener: function (listener, scope) {
        this._alarmManagerChangeDispatcher.remove(listener, scope);
    },
    addAlarmPropertyChangeListener: function (listener, scope, ahead) {
        this._alarmPropertyChangeDispatcher.add(listener, scope, ahead);
    },

    removeAlarmPropertyChangeListener: function (listener, scope) {
        this._alarmPropertyChangeDispatcher.remove(listener, scope);
    },


    /**
     * 
     * , ,.
     * @param data
     * @returns {number}
     */
    getAlarmCountNow: function (data) {


        if (!data) {
            return 0;
        }
        var result = this._dataManager.getDescendants(data);
        if (!result) {
            return 0;
        }
        var count = 0;
        result.forEach(function (item) {
            count += item.getAlarmState().getSelfAlarmCount();
        })
        return count;
    }
});
/**
 * .
 * dirty.,dirty,.
 * dirty,.
 * 
 * : ,,,
 * , - 
 *  - ,()
 *  - node,
 * @param {it.DataManager} dataManager
 * @param {it.SceneManager} sceneManager
 * @param {it.AlarmManager} alarmManager
 * @constructor
 *
 */
it.AlarmStatePropagator = function (dataManager, sceneManager, alarmManager) {
    this._dataManager = dataManager;
    this._sceneManager = sceneManager;
    this._alarmManager = alarmManager;
    this.dataBox = alarmManager.dataBox;
    this.alarmBox = alarmManager.alarmBox;
    mono.AlarmStatePropagator.call(this, this.dataBox, 'alarmState');
    this.dataBox.setAlarmStatePropagator(this);
    this.childrenAlarms = [];
};

mono.extend(it.AlarmStatePropagator, mono.AlarmStatePropagator, {

    propagateToTop: function (data) {
        //for (var i = 0; i < this.childrenAlarms.length; i++) {
        //    this.alarmBox.remove(this.childrenAlarms[i]);
        //}
        //this.childrenAlarms = [];
        var result = true;
        result = this.propagateToParent(null, data);
        while (data && data.getParent() && result !== false) {
            result = this.propagateToParent(data, data.getParent());
            data = data.getParent();
        }
    },

    propagateToParent: function (child, parent) {
        var childData = child == null ? null : it.SceneManager.getNodeData(child);
        var parentData = parent == null ? null : it.SceneManager.getNodeData(parent);
        if (!parentData) {
            return false;
        }
        return this.dataPropagateToParent(childData, parentData, child, parent);
    },


    dataPropagateToParent: function (childData, parentData, child, parent) {
        return this.dataPropagateToParentForRoom(childData, parentData, child, parent);
    },


    dataPropagateToParentForRoom: function (childData, parentData, child, parent) {
        //child
        if (this.isStop(childData)) {
            return false;
        }

        if (!parentData.getAlarmState) { // linkAlarmState
            return false;
        }

        if (parent.getClient('modelParent')) {
            parent = parent.getClient('modelParent')
        }

        //getHighestOverallAlarmSeverity
        parentData.getAlarmState().setPropagateSeverity(null);
        parent.getAlarmState().setPropagateSeverity(null);
        var result = parentData.getAlarmState().getHighestOverallAlarmSeverity();
        var children = parentData.getChildren();//this.dataManager.getChildren(parentData);
        var length = children.size();
        for (var i = 0; i < length; i++) {
            var childDataTemp = children.get(i);
            var severity = childDataTemp.getAlarmState().getHighestOverallAlarmSeverity();
            if (it.AlarmSeverity.compare(severity, result) > 0) {
                result = severity;
            }
        }
        //
        //,
        parentData.getAlarmState().setPropagateSeverity(result);
        if (parent.getClient('complexNode')) {
            var target = parent.getClient('complexNode')!='unload'&&parent.getClient('complexNode').getParent() ? parent.getClient('complexNode') : parent.getClient('simpleNode');
            target.getAlarmState().setPropagateSeverity(result);
        }


        this.modelChildAlarmSyn(childData, parentData, child, parent);

        //
        var parentDataType = parentData == null ? null : this.dataManager.getDataTypeForData(parentData);
        if (!parentDataType) {
            return false;
        }
        if (parentDataType.isStopAlarmPropagationable()) {
            return false;
        }
        var parentCategory = this.dataManager.getCategoryForData(parentData);
        if (!parentCategory) {
            return !parentDataType.isStopAlarmPropagationable();
        }
        if (parentCategory.isStopAlarmPropagationable()) {
            return false;
        }
        return true;
    },

    isStop: function (childData) {
        if (childData) {
            var childDataType = this.dataManager.getDataTypeForData(childData);
            if (childDataType) {

                if (childDataType.isStopAlarmPropagationable()) {
                    return true;
                }
                var childCategory = this.dataManager.getCategoryForData(childData);
                if (childCategory && childCategory.isStopAlarmPropagationable()) {
                    return true;
                }
            }
        }
        return false;
    },

    modelChildAlarmSyn: function (childData, parentData, child, parent) {
        if (parent.getClient('complexNode')) {
            parent = parent.getClient('complexNode')!='unload'&&parent.getClient('complexNode').getParent() ? parent.getClient('complexNode') : parent.getClient('simpleNode');
        }
        var children = parent.getChildren();
        var length = children.size();
        var parentNativeSeverity = parent.getAlarmState().getPropagateSeverity();
        for (var i = 0; i < length; i++) {
            var childTemp = children.get(i);
            if (childTemp.getClient('modelParent')) {
                var alarmId = 'child_alarm_' + childTemp.getId();
                if (parentNativeSeverity) {
                    var alarm = this.alarmBox.getDataById(alarmId);
                    if (!alarm) {
                        alarm = new mono.Alarm(alarmId, childTemp.getId(), parentNativeSeverity);
                        this.alarmBox.add(alarm);
                    } else {
                        alarm.setAlarmSeverity(parentNativeSeverity);
                    }
                    childTemp.getAlarmState().setPropagateSeverity(parentNativeSeverity);
                } else {
                    this.alarmBox.removeById(alarmId);
                    childTemp.getAlarmState().setPropagateSeverity(null);
                }
            }
        }
    }
});


/**
 * EventHandler
 * 1
 * 2
 * 3
 * 4
 * 5dblclick
 */

var $DefaultEventHandler = function (sceneManager){ // 
	$EventHandler.call(this);
    this.sceneManager = sceneManager;
    this.dataManager = sceneManager.dataManager;
    if(!sceneManager){
        console.log('sceneManager can not be null!');
    }
    this.mode = "lookat"; // lookat move,
    this.filterFunction = null;
    this.defaultPostion = null;
    this.defaultTarget = null;
    this.defaultLookAtDistance = 2000;
    this.lookAtDistanceFunction = null;
    this.isLookAtFunction = null;
    this.afterLookAtFunction = null;
    this.afterLookAtFinishedFunction = null;
    this._afterLookAtListener = []; //listerafterLookAtFunction
    this._afterLookAtFinishedListener = [];//,afterLookAtFinishedFunction
    this.box3d = sceneManager.network3d.getDataBox();
    this.withOutAnimate = false;
    this.lookAtWithOutMoveCamera = true; // lookAt()setFocus
    this.handleDoubleClickBackgroundFunction = null;
    this.cameraInfoStack = [];
};

mono.extend($DefaultEventHandler,$EventHandler,{
    
    setDefaultPositionAndTarget : function(position,target){
        this.defaultPostion = position;
        this.defaultTarget = target;
    },

    getDefaultVirtual : function(){
       return this.sceneManager.viewManager3d.getDefaultVirtualMaterialFilter();
    },

    setMode : function(mode){//lookat, move
        this.mode = mode;
    },

    getCamera : function(node){
        var sceneView = this.sceneManager.getSceneViewByNode(node);
        if (sceneView && sceneView.getCamera && sceneView.getCamera()) {
            return sceneView.getCamera();
        }else{
            return this.sceneManager.network3d.getCamera();
        }
    },

    /**
     * boundingBox1000
     * @param node
     * @returns {boolean}
     */
    isLookAtWithAngle : function(node){
        if (!node) {
            return false;
        }
        var bb = it.Util.getBoundingBox(node);
        // if(node && node.getBoundingBox()){
        //     var boundingBox = node.getBoundingBox();
        //     if(boundingBox.max.x - boundingBox.min.x > 500
        //         || boundingBox.max.y - boundingBox.min.y > 500
        //         || boundingBox.max.z - boundingBox.min.z > 500){
        //         return true;
        //     }
        // }
        var data = this.sceneManager.getNodeData(node);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId() == 'building') { //  -- 2017-07-06
            return true;
        }
        if (bb && (bb.size().x > 500 || bb.size().y > 500 || bb.size().z > 500)) {
            return true;
        }
        return false;
    },

    /**
     * lookAt3D
     * scalescaleboudingboxsizescale
     *  withOutScaletrueScalescale
     * fov
    */
    getElementPerfectDistance : function(node,withOutScale){
        if (!node) {
            return 100;
        }
        if(withOutScale == true){
            withOutScale = true;
        }else{
            withOutScale = false;
        }
        var camera = this.getCamera(node); // 17-08-11 this.sceneManager.network3d.getCamera();
        var h = 100;
        // var bb = node.getBoundingBox();//20160914
        var bb = it.Util.getBoundingBox(node); // update 2017-07-06 
        // var bb = node.getBoundingBoxWithChildren();
        if (bb) {
            var d_y = bb.max.y - bb.min.y;
            var d_x = bb.max.x - bb.min.x;
            var d_z = bb.max.z - bb.min.z; // Z add 2017-09-08 Kevin
            if(!withOutScale){
                d_y = d_y * node.getScaleY();
                d_x = d_x * node.getScaleX();
            }
            if (d_y > d_x) {
                h = d_y;
            } else {
                h = d_x;
            }
            if (d_z > h) {
                h = d_z;
            }
        }
        var l = h / (2 * Math.tan(camera.fov * Math.PI / 180 / 2));
        var offset = this.getElementPerfectDistanceOffset(node);
        l += offset;
        return l;
    },

    getElementPerfectDistanceOffset : function(node){
        return 50;
    },

    getElementPerfectFrontPositionOffsetY : function(node){
        var data = this.sceneManager.getNodeData(node);
        var category = this.dataManager.getCategoryForData(data);
        if (category && category.getId() == 'equipment') {
            return 0;
        }
        return 20;
    },

    getElementPerfectFrontPosition : function(node){
        if (!node) return null;
        var l = this.getElementPerfectDistance(node);
        if (l < 100) {
            l = 100;
        }

        // 2017-11-02 noderoonnode.frontWorldPositions
        // var perfectPosition = node.frontWorldPosition(l); //
        var nodeCenter = this.getNodeCenterPosition(node);
        var distance = l > 0 ? l : 1;
        var perfectPosition = nodeCenter.add(node.frontDirection().multiplyScalar(distance));
        var offsetY = this.getElementPerfectFrontPositionOffsetY(node) || 0;
        perfectPosition.y = perfectPosition.y + offsetY; 
        return perfectPosition;
    },

    /**
     * 3D
     * @param node
     * @param v 
     * @returns {*}
     */
    getElementPerfectFrontPositionForNodeCenterPosition : function(node,withAngle){
        if (!node) return null;
        var l = this.getElementPerfectDistance(node);
        if (l < 100) {
            l = 100;
        }
//        var perfectPosition = node.frontWorldPosition(l); //
//        perfectPosition.y = perfectPosition.y + 20;
//        return perfectPosition;
        var pos = this.getNodeCenterPosition(node);
        var v = null;
        if(withAngle == undefined){
            withAngle = true;
        }
        if(withAngle){
            v = new mono.Vec3(0, 1, 2); //30
        }
        if(v){
            return pos.add(node.direction(v).multiplyScalar(l));
        }else{
            return pos.add(node.frontDirection().multiplyScalar(l));
        }
    },

    /**
     * nodeposition
     * boundingBox*Scale
     * pathNodepath
     * @param node
     * @returns {position}
     */
    getNodeCenterPosition : function(node){
        if(!node) return null;
        // var boundingBox = node.getBoundingBox(); // update 20160914
        var boundingBox = it.Util.getBoundingBox(node);  // update 2017-07-06 
        // var boundingBox = node.getBoundingBoxWithChildren();
        var offx = 0;
        var offy = 0;
        var offz = 0;
        if (boundingBox && boundingBox.max && boundingBox.min) {
            offx = (boundingBox.max.x + boundingBox.min.x)/2*node.getScaleX();
            offy = (boundingBox.max.y + boundingBox.min.y)/2*node.getScaleY();
            offz = (boundingBox.max.z + boundingBox.min.z)/2*node.getScaleZ();
        }
        var position = node.getWorldPosition();
        position.setX(position.x + offx);
        position.setY(position.y + offy); 
        position.setZ(position.z + offz);
        return position;
    },

    getCameraPositionForLookAt: function(node) {
        var h = this.getElementPerfectDistance(node); 
        // 2017-11-02 node
        // return node.worldPosition(new mono.Vec3(0, 1, 2), h); 
        var nodeCenter = this.getNodeCenterPosition(node);
        return nodeCenter.add(node.direction(new mono.Vec3(0, 1, 2)).multiplyScalar(h));
    },

    getCameraTargetAndPositionByNode : function(node){
        return null;
    },

    /**
     * node
     */
    moveCameraForLookAtNode: function(node, callback, offset) {
        if (!node) return;
        var camera = this.getCamera(node); // 17-08-11 this.sceneManager.network3d.getCamera();
        var tarAngPos = this.getSavedCameraInfoByNode(node)||this.getCameraTargetAndPositionByNode(node);
        var target = null;
        var f_position = null;
        if (tarAngPos && tarAngPos.target && tarAngPos.position) {
            target = tarAngPos.target;
            f_position = tarAngPos.position;
        } else {
            var w_p = this.getNodeCenterPosition(node);
            if (!w_p) {
                w_p = new mono.Vec3(0, 0, 0);
            }
            var bb = it.Util.getBoundingBox(node); // update 2017-07-06
            target = new mono.Vec3(w_p.x, w_p.y, w_p.z);
            f_position = this.getElementPerfectFrontPosition(node);
            if (this.isLookAtWithAngle(node)) {
                var h = this.getElementPerfectDistance(node); //
                // f_position = node.worldPosition(new mono.Vec3(0, 1, 2), h); //4000
                f_position = this.getCameraPositionForLookAt(node);
                if (bb && (bb.max.y + bb.min.y) != 0) { //pathNode
                    f_position.y = f_position.y + (bb.max.y + bb.min.y) / 2
                }
                var datalX = 0,
                    datalZ = 0;
                if (node.getRotationY()) {
                    datalX = h * Math.sin(node.getRotationY());
                }
                f_position.x = target.x + datalX; // lookAt
            }
            if (offset) {
                f_position.x += offset.x;
                f_position.y += offset.y;
                f_position.z += offset.z;
            }
        }

        function callbackWrap() {
            // adjustBounds();
            if (callback) {
                callback();
            }
        };

        it.Util.playCameraAnimation(camera, f_position, target, 1500, callbackWrap);

    },

    /**
     * ()
     * @param node
     */
    lookAtNodeWithOutAnimate: function(node) {
        if (!node) return;
        if (!(node instanceof mono.Element)) {
            return;
        }
        var camera = this.getCamera(node); // 17-08-11 this.sceneManager.network3d.getCamera();
        var cameraTarAndPos = this.getSavedCameraInfoByNode(node) || this.getCameraTargetAndPositionByNode(node);
        if (cameraTarAndPos && cameraTarAndPos.target && cameraTarAndPos.position) {
            camera.setPosition(cameraTarAndPos.position.x, cameraTarAndPos.position.y, cameraTarAndPos.position.z);
            camera.lookAt(cameraTarAndPos.target.x, cameraTarAndPos.target.y, cameraTarAndPos.target.z);
        } else {
            var w_p = this.getNodeCenterPosition(node);
            if (!w_p) {
                w_p = new mono.Vec3(0, 0, 0);
            }
            var f_position = this.getElementPerfectFrontPosition(node);
            if (this.isLookAtWithAngle(node)) {
                var h = this.getElementPerfectDistance(node); //
                f_position = node.worldPosition(new mono.Vec3(0, 1, 1), h); //4000
                var datalX = 0,
                    datalZ = 0;
                if (node.getRotationY()) {
                    datalX = h * Math.sin(node.getRotationY());
                    datalZ = h * (1 - Math.cos(node.getRotationY()));
                }
                f_position.x = w_p.x + datalX; // lookAt
                f_position.z = f_position.z - datalZ;
            }
            camera.setPosition(f_position.x, f_position.y, f_position.z);
            camera.lookAt(w_p.x, w_p.y, w_p.z);
        }
    },

    /**
     * nodeselement
     * @param nodes
     * @returns {null}
     */
    lookAtElements : function(nodes,callback){
        if(!nodes || nodes.length < 1){
            return null;
        }
        if(nodes.length === 1){
            this.lookAt(nodes[0]);
            return;
        }
        this.sceneManager.viewManager3d.setCameraDistance(null,10000);
        var camera = this.getCamera(nodes[0]); // 17-08-11  this.sceneManager.network3d.getCamera();
        var minx,miny,minz,maxx,maxy,maxz;
        for(var i = 0 ; i < nodes.length ; i++){
            var node = nodes[i];
            if(!node){
                continue;
            }
            var bp = node.getBoundingBox()||{min:{x:0,y:0,z:0},max:{x:0,y:0,z:0}}; //boundingBox
            var wp = node.getWorldPosition();
            if(!minx || minx > (wp.x+bp.min.x)){
                minx = wp.x+bp.min.x;
            }
            if(!miny || miny > (wp.y + bp.min.y)){
                miny = wp.y + bp.min.y;
            }
            if(!minz || minz > (wp.z + bp.min.z)){
                minz = wp.z + bp.min.z;
            }
            if(!maxx || maxx < (wp.x + bp.max.x)){
                maxx = wp.x + bp.max.x;
            }
            if(!maxy || maxy < (wp.y + bp.max.y)){
                maxy = wp.y + bp.max.y;
            }
            if(!maxz || maxz < (wp.z + bp.max.z)){
                maxz = wp.z + bp.max.z;
            }
        }
        var target = new mono.Vec3(minx+(maxx-minx)/2,miny+(maxy-miny)/2,minz+(maxz-minz)/2);
        // var maxLen = maxx - minx; // 
        // if(maxLen < (maxy-miny)){
        //     maxLen = (maxy-miny);
        // }
        // if(maxLen < (maxz - minz)){
        //     maxLen = (maxz - minz);
        // }
        var maxLen = Math.sqrt((maxx - minx)*(maxx - minx) + (maxy-miny)*(maxy-miny));
        var length = maxLen / (2 * Math.tan(camera.fov * Math.PI / 180 / 2));
        var offset = 50;
        length+= offset;
        if(length < 500){
            length = 500;
        }
        var up = 50;
        if(maxy-miny < 300){ //300()200maxy
            up = length ;// up = 500; //45
        }
        var  f_position = new mono.Vec3(target.x, target.y+up, target.z+length);
        it.Util.playCameraAnimation(camera, f_position, target, 1500, callback);
    },

    getCameraTarAndPosForLookAtNodes: function(nodes, angle, offset) {
        if (!nodes || nodes.length < 1) {
            return null;
        }
        if (nodes.length == 1) {
            // this.moveCameraForLookAtNode(nodes[0], callback, offset);
            var w_p = this.getNodeCenterPosition(nodes[0]);
            if (!w_p) {
                w_p = new mono.Vec3(0, 0, 0);
            }
            // var bb = nodes[0].getBoundingBox();
            var bb =  it.Util.getBoundingBox(nodes[0]);// update 2017-07-06 
            var target = new mono.Vec3(w_p.x, w_p.y, w_p.z);
            var f_position = this.getElementPerfectFrontPosition(nodes[0]);
            if (this.isLookAtWithAngle(nodes[0])){
                var h = this.getElementPerfectDistance(nodes[0]); //
                f_position = this.getCameraPositionForLookAt(nodes[0]);
                if (bb && (bb.max.y + bb.min.y) != 0) { //pathNode
                    f_position.y = f_position.y + (bb.max.y + bb.min.y)/2
                }
                var datalX = 0,datalZ = 0;
                if (nodes[0].getRotationY()) {
                    datalX = h*Math.sin(nodes[0].getRotationY());
                }
                f_position.x = target.x + datalX; // lookAt
            }
            return {
                target: w_p,
                position: f_position
            };
        }
        var camera = this.getCamera(nodes[0]); // 17-08-11 this.sceneManager.network3d.getCamera();
        var bb = this.computeNodesBoundingBox(nodes);
        if (!bb) {
            return null;
        }
        var center = bb.center();
        var sub1 = new mono.Vec3(0, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
        var sub2 = new mono.Vec3(bb.max.x - bb.min.x, 0, 0, 0);
        var sub = sub1.clone();
        if (sub.length() < sub2.length()) {
            sub = sub2.clone();
        }
        var position;
        if (angle) {
            var l = sub1.length();
            sub1.y = sub1.z * Math.tan(angle / 180 * Math.PI);
            sub1.setLength(l);
        }
        position = new mono.Vec3().addVectors(center, sub1.multiplyScalar(0.5));
        var fov = camera.fov,
            aspect = camera.aspect;
        var length = sub.length() / 2 / Math.tan(fov * Math.PI / 180);
        length = length * 2; //
        position.add(sub1.normalize().multiplyScalar(length));
        return {
            target: center,
            position: position
        };
    },

    /**
     * nodes
     * add by Kevin 2016-11-01
     */
    moveCameraForLookAtNodes: function(nodes, callback, angle,offset) {
        if (!nodes || nodes.length < 1) {
            if (callback) {
                callback();
            }
            return;
        }
        var camera = this.getCamera(nodes[0]); // 17-08-11 this.sceneManager.network3d.getCamera();
        var targetAndPos = this.getCameraTarAndPosForLookAtNodes(nodes,angle,offset);
        if (targetAndPos) {
            var position = targetAndPos.position;
            var center = targetAndPos.target;
            it.Util.playCameraAnimation(camera, position, center, 1500, callback);
        }
    },
    
    /**
     * nodesboundingBox
     * nodemapboundingBox
     * lookAtnode
     * add by Kevin 2016-11-01
     */
    computeNodesBoundingBox: function(nodes) {
        if (!nodes || nodes.length < 1) {
            return;
        }
        var vertices = [];
        for (var i = 0; i < nodes.length; i++) {
            var data = nodes[i];
            if (data instanceof TGL.Node) {
                bb = data.getBoundingBox();
                matrix = data.worldMatrix;
                var min = bb.min,
                    max = bb.max;
                pushVertics(min.clone(), matrix);
                pushVertics(max.clone(), matrix);
                pushVertics(new mono.Vec3(min.x, min.y, max.z), matrix);
                pushVertics(new mono.Vec3(min.x, max.y, min.z), matrix);
                pushVertics(new mono.Vec3(max.x, min.y, min.z), matrix);
                pushVertics(new mono.Vec3(max.x, max.y, min.z), matrix);
                pushVertics(new mono.Vec3(max.x, min.y, max.z), matrix);
                pushVertics(new mono.Vec3(min.x, max.y, max.z), matrix);
            }
        }

        function pushVertics(vertex, matrix) {
            vertex.applyMatrix4(matrix);
            vertices.push(vertex);
        };
        if (vertices.length <= 1) {
            return null;
        }
        var boundingBox = new mono.BoundingBox();
        boundingBox.setFromPoints(vertices);
        return boundingBox;
    },

    getCenter : function(node1,node2){
        if(!node1 && !node2){
            return null;
        }else if(!node1 && node2){
            return node2.getWorldPosition();
        }else if(!node2 && node1){
            return node1.getWorldPosition();
        }else{
            var w_n1 = node1.getWorldPosition();
            var w_n2 = node2.getWorldPosition();
            var x = (w_n2.x - w_n1.x) > 0 ?w_n1.x + (w_n2.x - w_n1.x)/2 : w_n2.x + (w_n1.x - w_n2.x)/2;
            var y = (w_n2.y - w_n1.y) > 0 ?w_n1.y + (w_n2.y - w_n1.y)/2 : w_n2.y + (w_n1.y - w_n2.y)/2;
            var z = (w_n2.z - w_n1.z) > 0 ?w_n1.z + (w_n2.z - w_n1.z)/2 : w_n2.z + (w_n1.z - w_n2.z)/2;
            return new mono.Vec3(x,y+50,z);
        }
    },

    /**
     * length*frontDirection
     */
    getPerfectDistanceForNodes : function(node1,node2){
        var direction = 'z';
        var result = {direction:'x',length:0};
        if(!node1 && !node2){
            return null;
        }else if(!node1 && node2){
            // return this.getElementPerfectDistance(node2);
            var fd = 1;
            if (node2.frontDirection().z < 0) {
                fd = -1;
            }
            result = {direction:'x',length:this.getElementPerfectDistance(node2)*fd};
        }else if(!node2 && node1){
            // return this.getElementPerfectDistance(node1);
             var fd = 1;
             if (node1.frontDirection().z < 0) {
                fd = -1;
             }
             result = {direction:'x',length:this.getElementPerfectDistance(node1)*fd};
        }else{
            var camera = this.getCamera(node1); // 17-08-11 this.sceneManager.network3d.getCamera();
            var w_n1 = node1.getWorldPosition();
            var w_n2 = node2.getWorldPosition();
//            var x = (w_n2.x - w_n1.x) > 0 ? (w_n2.x - w_n1.x) :  (w_n1.x - w_n2.x);
//            var y = (w_n2.y - w_n1.y) > 0 ? (w_n2.y - w_n1.y) :(w_n1.y - w_n2.y);
//            var z = (w_n2.z - w_n1.z) > 0 ? (w_n2.z - w_n1.z) : (w_n1.z - w_n2.z);
            var x = Math.abs(w_n2.x - w_n1.x);
            var y = Math.abs(w_n2.y - w_n1.y);
            var z = Math.abs(w_n2.z - w_n1.z);
            var h = x;
            if(y>h){
                h = y;
            }
            if(z>h){ 
                h = z;
                direction = 'x'; //zx
            }
            var length = h / (2 * Math.tan(camera.fov * Math.PI / 180 / 2));
//            var length = h / (2 * Math.tan(camera.fov / 2));
            var offset = 50;
            length+= offset;
            if(length < 500){
                length = 500;
            }
            var fd = 1;
            if (node1.frontDirection().z < 0) {
              fd = -1;
            }
            result = {direction:direction,length:length*2*fd};
            // return length*2;
        }
        return result;
    },

    /**
     * lookAt link
     * link
     * @param linkNode
     * @param callback
     */
    moveCameraForLookAtLink : function(linkNode,callback,dur){
        if(!linkNode) return ;
        dur = dur||1500;
        var camera = this.getCamera(linkNode); // 17-08-11 this.sceneManager.network3d.getCamera();
        var link = this.sceneManager.getLinkData(linkNode);
        if(!link){
            this.moveCameraForLookAtNode(linkNode,callback);
            return;
        }
        var fromNodde = this.sceneManager.getNodeByDataOrId(link.getFromId());
        var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
        //fromNodetoNodefocuseNoderemovelookAt
        //link,add 2016-12-06
        if(fromNodde && !this.box3d.getDataById(fromNodde.getId())){
            this.box3d.add(fromNodde);
        }
        if(toNode && !this.box3d.getDataById(toNode.getId())){
            this.box3d.add(toNode);
        }
        var target = this.getCenter(fromNodde,toNode);
        var dirLength = this.getPerfectDistanceForNodes(fromNodde,toNode);
        var length = null;
        var direction = null;
        if (dirLength) {
            length = dirLength.length;
            direction = dirLength.direction;
        }
        var detalY = 0;//500;
        if(fromNodde && toNode){
            var fWPos = fromNodde.getWorldPosition();
            var tWPos = toNode.getWorldPosition();
            if(Math.abs(fWPos.y - tWPos.y) > 100){ //
                detalY = 0;
            }else{
                // detalY = detalY+ Math.round(Math.abs(fWPos.y - tWPos.y)/500) * 100;
                detalY = Math.abs(length) * Math.tan(Math.PI/6);
            }
        }
        var  f_position = new mono.Vec3(target.x, target.y+detalY, target.z);
        if (direction && direction == 'x' && length) {
            f_position.x = f_position.x + length;
        }else if (direction && direction == 'z' && length){
            f_position.z = f_position.z + length;
        }
        it.Util.playCameraAnimation(camera, f_position, target, dur, callback);
    },

    _isLookAt : function(node){
        if(this.isLookAtFunction != null){
            return this.isLookAtFunction(node);
        }
        var data = this.sceneManager.getNodeData(node);
        if(!data){ // 
            return false;
        }
        return true;
    },

    isDoLookAt : function(node){
        if(node && node.getClient('notLookAt')){
            return false;
        }
        return true;
    },

    /**
     * 
     * false
     */
    isUseCameraStackByNode : function(node){
         var nodeData = this.sceneManager.getNodeData(node);
         if (!nodeData) {
            return false;
         }
          var nCategory = this.dataManager.getCategoryForData(nodeData);
         if (nCategory 
            && (nCategory.getId().toLowerCase() == 'floor' 
                || nCategory.getId().toLowerCase() == 'room')) {
             return true;
         }
         return false;
    },
    
    /**
     * 
     * lookAtlookAtfocusNode
     * 
     */
    isPushCameraInfoBeforeLookAt : function(node){
         if(!node){
            return false;
         }
         var nodeData = this.sceneManager.getNodeData(node);
         if (!nodeData) {
            return false;
         }
         var oldFocusNode = this.sceneManager.viewManager3d.getFocusNode();
         var oldFocusData = this.sceneManager.getNodeData(oldFocusNode);
         if (nodeData != oldFocusData && this.dataManager.isAncestor(nodeData.getId(),oldFocusData)) {
             return false;
         }
         return this.isUseCameraStackByNode(node);
         // var nCategory = this.dataManager.getCategoryForData(nodeData);
         // if (nCategory 
         //    && (nCategory.getId().toLowerCase() == 'floor' 
         //        || nCategory.getId().toLowerCase() == 'room')) {
         //     return true;
         // }
         // return false;
    },

    /**
     * lookAt
     */
    pushCameraInfoByChildNode : function(childNode){ 
        //idlookAtlookAt
        //2017-11-29 by liyinzheng
        if (!childNode) {
            return ;
        }
        var cData = this.sceneManager.getNodeData(childNode);
        // if (!cData || !cData.getParentId()) {
        //     return ;
        // }
        // var parentNode = this.sceneManager.getNodeByDataOrId(cData.getParentId());
        var parentNode = this.sceneManager.viewManager3d.getFocusNode();//focuseNode,lookAt
        var data = this.sceneManager.getNodeData(parentNode);
        if (cData == data  // 2017-10-27 focus
            || !this.isPushCameraInfoBeforeLookAt(parentNode)) {
            return ;
        }
        var camera = this.getCamera();
        if (camera) {
            this.cameraInfoStack.push({id:data.getId(),target: camera.target,position:camera.getPosition()});
        }
    },
    
    /**
     * lookAt
     * node
     *      
     *  lookAtpop.
     *  popidpop
     *  
     */
    popCameraInfoByNode : function(node){
        var data = this.sceneManager.getNodeData(node);
        if (!data) {
            return false;
        }
        if (!this.isUseCameraStackByNode(node)) {
            return false;
        }
        return this.popToDataParentByData(data); //
    },

    /**
     * data
     */
    popToDataParentByData : function(data,scope){
        scope = scope || this;
        if(!data || !scope.cameraInfoStack || scope.cameraInfoStack.length < 1){
            return ;
        }
        //lookAtlookAtparent -- 2017-10-19
        if (!scope.cameraInfoStack[0] || scope.cameraInfoStack[0].id == data.getParentId() ) { 
            return ;
        }
        var pci = scope.cameraInfoStack.pop();
        if (pci && pci.id == data.getId()) {
            return true;
        }else {
            return scope.popToDataParentByData(data,scope);
        }
    },

    /**
     * 
     */
    clearCameraInfo : function(){
        this.cameraInfoStack = [];
    },

    getSavedCameraInfoByNode : function(node){
        var data = this.sceneManager.getNodeData(node);
        if (!node 
            || !data 
            || !this.cameraInfoStack 
            || this.cameraInfoStack.length < 1) {
            return null;
        }
        if (!this.isUseCameraStackByNode(node)) {
            return null;
        }
        for(var i = this.cameraInfoStack.length-1 ; i >=0 ; i--){
            var pci = this.cameraInfoStack[i];
            if (pci.id == data.getId()) {
                return pci;
            }
        }
        return null;
    },

    /**
     * 
     * falselookAtcallback
     */
    isDealWithVirtualBeforeMoveCamera : function(focusNode,oldFocusNode){
        var oldFocusData = this.sceneManager.getNodeData(oldFocusNode);
        var data = this.sceneManager.getNodeData(focusNode); 
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId().toLowerCase() == 'datacenter') { // floorfloorbuilding
            return false;
        }
        return this.sceneManager.isAncestor(oldFocusData,data);
    },

    /**
     * node
     * nodebox(lazyable)
     *
     * lookAt()earth()lookAt()lookAt
     *
     * @param node
     * @param callback1
     */
    lookAt : function(node, callback1) { //
        this.pushCameraInfoByChildNode(node);
        if (!node) {
            if (callback1) {
                callback1();
            }
            return;
        }
        if (!this.isDoLookAt(node)) {
            if (callback1) {
                callback1();
            }
            return;
        }
        var oldFocusNode = this.sceneManager.viewManager3d.getFocusNode();
        // var oldFocusData = this.sceneManager.getNodeData(oldFocusNode);
        var mainNode = this.sceneManager.getMainNode(node);
        if (!mainNode && !this.sceneManager.isLink(node)) { //2DNode
            return;
        }
        var data = this.sceneManager.getNodeData(mainNode);
        if (!mainNode && this.sceneManager.isLink(node)) { //Linklookatlink(fromIdtoId)
            mainNode = node;
        }else if (!this.box3d.getDataById(mainNode.getId())) {//load,building(childrenlookAt)
            this.sceneManager.loadLazyData(data);
        }
        var isDealWithVirtual = true;
        // setFocus
        if (this.isDealWithVirtualBeforeMoveCamera(mainNode,oldFocusNode)) {//Focus
            isDealWithVirtual = false;
        }
        this.sceneManager.viewManager3d.isDealWithVirtual = isDealWithVirtual; // 2017-10-20 setFocusNode
        this.sceneManager.viewManager3d.setFocusNode(mainNode,isDealWithVirtual);
        if (this.beforeLookAtFunction) { // setFocuse(setFocuse)
            this.beforeLookAtFunction(node,oldFocusNode);
        }
        if (!this.sceneManager.isLink(node)) {
             mainNode = this.sceneManager.getMainNode(node); // beforeLookAtFunction
        }
        if (!mainNode || !this.box3d.getDataById(mainNode.getId())) { // boxlookAt
            this.afterLookAt(mainNode, node,oldFocusNode); // 
            return;
        }
        var self = this;
        var callback = function(){ //callback
            // if (!isDealWithVirtual) {
            // 2017-10-20 setFocusview3Dview3DisDealWithVirtualtrue
            if (!isDealWithVirtual && self.sceneManager.viewManager3d.isDealWithVirtual) {
                self.sceneManager.viewManager3d.dealWithVirtual(mainNode);
            }
            self.popCameraInfoByNode(mainNode);
            self.openDoor(mainNode, callback1,oldFocusNode);
            self.afterLookAtFinished(mainNode, node,oldFocusNode);
        }
        if (this.lookAtWithOutMoveCamera) {
            if (this.sceneManager.isLink(node)) {
                this.moveCameraForLookAtLink(node, callback);
            } else {
                if (this.withOutAnimate) {
                    this.lookAtNodeWithOutAnimate(mainNode);
                    callback();
                    this.withOutAnimate = false;
                } else {
                    this.moveCameraForLookAtNode(mainNode, callback);
                }
            }
        } else {
            callback();
            this.lookAtWithOutMoveCamera = true;
        }
        this.afterLookAt(mainNode,node,oldFocusNode); //after lookAt,lookAtlookAtdcbreadpm
    },

    /**
     * lookAtcamera
     * @param mainNode
     * @param node
     * @param callback
     */
    afterLookAt : function(mainNode,node,oldFocusNode){
//        this.openDoor(mainNode,callback);
        if(this.afterLookAtFunction){
            this.afterLookAtFunction(mainNode,node,oldFocusNode);
        }
        for(var i = 0 ; i < this._afterLookAtListener.length ; i++){
            var l = this._afterLookAtListener[i];
            l.call(l.scope||this,mainNode,node,oldFocusNode);
        }
    },

    addAfterLookAtListener : function(l,scope){
        if(l){
            l.scope = scope;
            this._afterLookAtListener.push(l);
        }
    },

    removeAfterLookAtListener : function(l){
         var index = this._afterLookAtListener.indexOf(l);
        if(index !== -1){
           this._afterLookAtListener.splice(index,1);
        }
    },

    /**
     * lookAt
     * @param mainNode
     * @param node
     */
    afterLookAtFinished : function(mainNode,node){
        if(this.afterLookAtFinishedFunction){
            this.afterLookAtFinishedFunction(mainNode,node);
        }
        for(var i = 0 ; i < this._afterLookAtFinishedListener.length ; i++){
            var l = this._afterLookAtFinishedListener[i];
            l.call(l.scope||this,mainNode,node);
        }
    },

    addAfterLookFinishedAtListener : function(l,scope){
        if(l){
            l.scope = scope;
            this._afterLookAtFinishedListener.push(l);
        }
    },

    removeAfterLookAtFinishedListener : function(l){
         var index = this._afterLookAtFinishedListener.indexOf(l);
        if(index !== -1){
           this._afterLookAtFinishedListener.splice(index,1);
        }
    },

    findOidfromChildren : function (node, oid) {
        var result = [];
        if (node.getClient('type') == oid) {
            // return node; // 
            result.push(node);
        }
        var children = node.getChildren();
        for (var i = 0; i < children.size(); i++) {
            var child = children.get(i);
            if (child.getClient('it_data') == node.getClient('it_data')) {
                var cd = this.findOidfromChildren(child, oid, this);
                if (cd && cd.length > 0) {
                    // return cd;
                    for(var j = 0 ; j < cd.length ; j++){
                        result.push(cd[j]);
                    }
                }
            }
        }
        return result;
    },

    findAllOidDatafromChildren: function (node, oid) {
        var all = [];
        if (node.getClient('type') == oid) { //oid
            all.push(node);
            // return all;  //  add 2017-05-12 Kevin
        }
        var children = node.getChildren();
        for (var i = 0; i < children.size(); i++) {
            var child = children.get(i);
            if (child.getClient('it_data') == node.getClient('it_data')) {
                var cd = this.findOidfromChildren(child, oid);
                if (cd && cd.length > 0) {
                    // all.push(cd);
                    for(var j = 0 ; j < cd.length ; j++){
                        all.push(cd[j]);
                    }
                }
            }
        }
        return all;
    },

    findRackDoorElementAtRack: function (mainNode) {
        if (!mainNode) {
            return;
        }
        return this.findAllOidDatafromChildren(mainNode, 'rack_door'); //door
    },

    findChannelDoorElementAtChannel: function (mainNode) { //channeldoor  by--loda 2017-12-12
        if (!mainNode) {
            return;
        }
        return this.findAllOidDatafromChildren(mainNode, 'channel_door'); //channel_door
    },

    openDoor : function(mainNode,callback){
        var doors = this.findRackDoorElementAtRack(mainNode);
        var count = doors.length;
        var index = 0;
        var isPlay = false;
        if (doors && doors.length > 0) {
            doors.forEach(function (door) {
                if (door && door.getClient('animation') && !door.getClient('animated')) { //!door.__animated 
//                    console.log(door.getClient('animation'));
//                    var amin = 'rotation:right:-150:1000:0:Bounce.Out'; //door.getClient('animation')
                    // (element, animation, time, delay, easing, onCompleteCallback)
//                    mono.AniUtil.playAnimation(door, door.getClient('animation'), null, null, null, callback);
                    isPlay = true;
                    make.Default.playAnimation(door,door.getClient('animation'),function(){callback && callback(index++,count)});
                }
            });
        }
        if(!isPlay && callback){
            callback(0,0);
        }
    },

    closeDoor:function(mainNode,callback){
        var self = this;
        var doors = this.findRackDoorElementAtRack(mainNode);
        doors = doors.concat(this.findChannelDoorElementAtChannel(mainNode));
        var isPlay = false;
        if (doors && doors.length > 0) {
            doors.forEach(function (door) {
                if (door && door.getClient('animation') && door.getClient('animated')) { //door.__animated ()
//                    mono.AniUtil.playAnimation(door, door.getClient('animation'));
                    isPlay = true;
                    make.Default.playAnimation(door,door.getClient('animation'),callback);
                }
            });
        }
        var rackData = this.sceneManager.getNodeData(mainNode);
        var children = this.dataManager.getChildren(rackData);
        if(children && children.length>0){
            children.forEach(function(child){
                var childNode = self.sceneManager.getNodeByDataOrId(child);
                if (childNode && childNode.getClient('animation') && childNode.getClient('animated')) { //
                    make.Default.playAnimation(childNode,childNode.getClient('animation'),callback);
                }
            })
        }
        if(!isPlay && callback){
            callback();
        }
    },

    /**
     * Node
     * 500
     * add 2016-11-22dcboundingBoxsizecategory
     * @param node
     * @returns {boolean}
     */
    isFollow : function(node){
        if (node) {
            var data = this.sceneManager.getNodeData(node);
            var category = this.dataManager.getCategoryForData(data);
            if (category) {
                var cid = category.getId().toLowerCase() ;
                if (cid === 'datacenter' || cid === 'floor' || cid === 'room') {
                     return true;
                }
            }
        };
        return false;
    },

    /**
     * 
     * @param clickObj
     */
    moveToClickPoint : function(clickObj){
        if(!clickObj) return;
        var camera = this.getCamera();
        if(!camera) return;
        var newTarget=clickObj.point;
        var offset=camera.getPosition().sub(camera.getTarget());
        var f_position=new mono.Vec3().addVectors(offset, newTarget);
        it.Util.playCameraAnimation(camera,f_position,newTarget,1000);
    },

    /**
     * targetnode
     * offsetmoveSize
    */
    moveToClickNode : function(node,callback,moveSize){
        if(!node) return;
        if (!moveSize) {
            moveSize = 0;
        }
        var camera = this.getCamera();
        if(!camera) return;
        var newTarget=this.getNodeCenterPosition(node);
        var offset=camera.getPosition().sub(camera.getTarget());
        var f_position=new mono.Vec3().addVectors(offset, newTarget);
        var diffOff = new mono.Vec3().subVectors(newTarget,camera.getTarget());
        if (Math.abs(diffOff.x) > moveSize || Math.abs(diffOff.y)>moveSize || Math.abs(diffOff.z)>moveSize) {
            it.Util.playCameraAnimation(camera,f_position,newTarget,1000,callback);
        }else{
            if (callback) {
                callback();
            }
        }
    },

    getElementPerfectBackPosition : function(element){
        if(!element) return null;
        var h = this.getElementPerfectDistance(element);
        var  perfectPosition = element.worldPosition(new mono.Vec3(0,0,-1),h);
        if(perfectPosition){
            perfectPosition.y = perfectPosition.y+20;
        }
        return perfectPosition;
    },

    rotateElement : function(mainObj){
        // var mainObj = Util.getMainObject(element);
        if(!mainObj){
            return ;
        }
        if(!mainObj.isVisible() && mainObj.simpleRack){
            mainObj = mainObj.simpleRack;
        }
        var camera = this.getCamera(mainObj); // 17-08-11 this.sceneManager.network3d.getCamera();
        var perfectPosition = null;
        var w_p = mainObj.getWorldPosition();
        var rotate_flage = mainObj.getClient('rotate_flage');
        if(rotate_flage){
            perfectPosition = this.getElementPerfectFrontPosition(mainObj);
            mainObj.setClient('rotate_flage',false);
        }else{
            perfectPosition = this.getElementPerfectBackPosition(mainObj)
            mainObj.setClient('rotate_flage',true);
        }
        var target =  new mono.Vec3(w_p.x, w_p.y, w_p.z);
        it.Util.playCameraAnimation(camera,perfectPosition,target,1000);
    },

    shouldHandleDoubleClickElement : function(node,network,data,clickedObj){
        var lookAtNode = this.sceneManager.viewManager3d.getFocusNode();
         //viewManager3D
        // var virtualManager = this.getDefaultVirtual();
        // if(virtualManager && virtualManager.isVirtual(data||node)){
        //     return false;
        // }
        var root = node.getClient('modelParent') || node;
        var dataForRoot = this.sceneManager.getNodeData(root);
        var dataForLookAtNode = this.sceneManager.getNodeData(lookAtNode);
        // if(this._isLookAt(root) && lookAtNode != root){
        if(this._isLookAt(root) && dataForRoot != dataForLookAtNode){ //check data
            return true;
        }else if(node && (node.getClient('animation') || node.getClient('animated'))){
            return true;
        }else if(this.isFollow(node)){
            return true;
        }
       return false;
	},

  	shouldPropogateDoubleClickElement : function(node,network,data,clickedObj){
         return false;
  	},

  	shouldHandleDoubleClickBackground : function(network){
//  		 if(this.lookAtNode){
           return true;
//         }
//         return false;
  	},

  	shouldPropogateDoubleClickBackground : function(network){
         return false;
  	},

    /**
     * 
     * @param network
     */
  	handleDoubleClickBackground : function(network){
        var lookAtNode = this.sceneManager.viewManager3d.getFocusNode();
        if(lookAtNode){
            if(this.sceneManager.isLink(lookAtNode)){
//                var fromNode = lookAtNode.getFromNode();//
//                if(fromNode){
//                    lookAtNode =  fromNode;
//                }else{
                    var link = this.sceneManager.getNodeData(lookAtNode);
                    if(link){
                        if(link.getFromId() && this.sceneManager.isCurrentSceneInstance(link.getFromId())){
                            lookAtNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                        }else if(link.getToId()) {
                            lookAtNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                        }else{
                            lookAtNode = lookAtNode.getFromNode();//
                        }
                    }
//                }
//                lookAtNode = lookAtNode.getFromNode();
            }

            var parentNode = this.getParentFocusNode(lookAtNode);
            if(parentNode){
                this.lookAt(parentNode);
                return this.handleDoubleClickBackgroundFunction && this.handleDoubleClickBackgroundFunction(network);
            }
        }
        this.handleDoubleClickBackgroundFunction && this.handleDoubleClickBackgroundFunction(network);
  	},

    /**
     * lookAtparent.
     * buildingbuildingbuildingbuilding
     * @param lookAtNode
     * @returns {*}
     */
    getParentFocusNode : function(lookAtNode){
        var data = this.sceneManager.getNodeData(lookAtNode);
        if (data && data.getParentId()) {
            var parentData = this.sceneManager.dataManager.getDataById(data.getParentId());
            if (!parentData) {
                return null;
            }
            var parentNode = this.sceneManager.dataNodeMap[data.getParentId()]; //parentDataloadLazyData
            return parentNode
        }
    },
     
    /**
     * lookAtparent(parentroomchannel)
     */
    isLookAtParentFirst : function(node,network,data,clickedObj){
        return true;
    },

    isPlayAnimate : function(node){
        return true;
    },

    /**
     * 
     * lookAtlookAtlookAt,
     * 
     * @param node
     * @param network
     * @param clickedObj
     */
  	handleDoubleClickElement : function(node,network,data,clickedObj){
        var root = node.getClient('modelParent') || node;
        var self = this;
        var lookAtNode = this.sceneManager.viewManager3d.getFocusNode();
        if(data 
            && clickedObj.distance > 2500 
            && this.isLookAtParentFirst(node,network,data,clickedObj)){ // look(room add By Kevin 20161109)
            var parantData = this.sceneManager.dataManager.getDataById(data.getParentId());
            var parentNode = this.sceneManager.getNodeByDataOrId(data.getParentId());
            if(parantData && parentNode && parentNode != lookAtNode){
                var category = this.sceneManager.dataManager.getCategoryForData(parantData);
                if(category 
                    && (category.getId().indexOf('channel') >=0 
                        || category.getId().toLowerCase() === 'room')){
                    root = parentNode;
                }
            }
        }
        if(this._isLookAt(root) && lookAtNode != root){
            this.lookAt(root);
//            this.lookAtNode = root;
        }else if(node && (node.getClient('animation') || node.getClient('animated'))) { //door.__animated ()
            var animate = node.getClient('animate');
            if (this.isPlayAnimate(node)) {
                var callback = function(){
                    self.afterPlayAnimateFunction && self.afterPlayAnimateFunction(node,!!animate); 
                }
                make.Default.playAnimation(node,node.getClient('animation'),callback);
            }
        }else if(this.isFollow(node)){
            this.moveToClickPoint(clickedObj);
        }
  	},

    /**
     * 
     * @withStopCamera,true 
     */
    lookAtByData : function(data,callback,withStopCamera){
        if (!data) {
            callback&&callback();
            return;
        }
        if (typeof(data) == 'string' || typeof(data) == 'number') {
            data = this.sceneManager.dataManager.getDataById(data);
        }
        var node = this.sceneManager.getNodeByDataOrId(data);
        var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
        if (sceneAndRootData) {
            if (node 
                && sceneAndRootData.scene == this.sceneManager.getCurrentScene() 
                && sceneAndRootData.rootData == this.sceneManager._currentRootData
                ) {
                this.lookAt(node,callback);
                 return;
            }
            if(withStopCamera || withStopCamera == undefined || withStopCamera == null){
                withStopCamera = true;
            }else{
                withStopCamera = false;
            }
            if (withStopCamera) {
                this.sceneManager.cameraManager.setStopCamera(true);
            }
            var self = this;
            var afterGotoSceneCallback = function(){ 
                if (sceneAndRootData.rootData != data) {
                    node = self.sceneManager.dataNodeMap[data.getId()];
                    if (!node) {
                        self.sceneManager.loadLazyData(data, function () {
                            node = self.sceneManager.dataNodeMap[data.getId()];
                            self.lookAt(node, callback);
                        });
                        return;
                    }
                } else {
                    node = null;
                    // node = self.sceneManager.dataNodeMap[data.getId()]; // add 2017-05-08  gotoScenesetFocuselookAt
                }
                self.lookAt(node, callback);
            };
            // this.sceneManager.gotoScene(sceneAndRootData.scene, sceneAndRootData.rootData,afterGotoSceneCallback);
            if (sceneAndRootData.scene.getCategoryId() == 'earth') {
                //update 2017-07-07 beforeLoadSceneAnimatedcearthbeforplay
                this.sceneManager.gotoScene(sceneAndRootData.scene, sceneAndRootData.rootData,afterGotoSceneCallback);
            }else{
                if (sceneAndRootData.rootData != data) {
                    this.sceneManager.resetCameraWhenSceneChange = false;
                }
                this.sceneManager.gotoScene(sceneAndRootData.scene, sceneAndRootData.rootData);//callbacksetsetFocuse
                afterGotoSceneCallback(); //callback(CameraManager)
            }
           
            if (withStopCamera) {
                mono.Utils.stopAllAnimates(true);
            }
        }
    }

});

it.DefaultEventHandler = $DefaultEventHandler;

/**
 * 
 * 1
 * 
 *
 * 2setSelectTransparencyThreshold
 *
 *
 */

var $VirtualManager = function(sceneManager){
    $MaterialFilter.call(this);
    this.sceneManager = sceneManager;
    this.opacityValue = 0.26; //0.06;
    this.focusElement = null;
    this.virtualFilter = null; // TODO 
    this.materialMap = {};
    this.isDealWithFunction = null;

    this._global_tmap = {}; //tmap,it.Data
    this._global_linkTmap = {}; // it.Link
    this._tmap = {}; //  ,it.Data
    this._linkTmap = {}; // ,it.Link
    this._billboard_tmap = {}; //billboard
    this._link_tmap = {}; // mono.Linkclonemateralbillboard
    this.sceneManager.network3d.setSelectTransparencyThreshold(this.opacityValue + 0.1); // filter
    this.dealWithLinkFunction = null;
    this.virtualFunction = null;
    this.getOpacityValueFunction = null; //data
    this._particleMap = {};
};

mono.extend($VirtualManager,$MaterialFilter,{

    clearGlobal : function(){
        this._global_tmap = {};
        this._global_linkTmap = {};
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'clearGlobal'
        });
    },

    clear: function(){
        this._tmap = {};
        this._linkTmap = {};
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'clear'
        });
    },

    clearAll : function(){
        this._tmap = {};
        this._linkTmap = {};
        this._global_tmap = {};
        this._global_linkTmap = {};
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'clearAll'
        });
    },

    /**
     * 
     * datacenterbuilding
     * @param data
     * @returns {boolean}
     */
    isDealWith : function(data){
        if(this.isDealWithFunction != null){
            return this.isDealWithFunction(data);
        }
        return true;
    },

    isVirtualOther :function(data){
        var dataType = this.sceneManager.dataManager.getDataTypeForData(data);
        if(dataType && dataType._noVirtualOther){
            return false;
        }
        if(this.virtualFunction){
            return this.virtualFunction(data);
        }
        return true;
    },

    isDealWithLink : function(link){
        if(this.dealWithLinkFunction){
            return this.dealWithLinkFunction(link);
        }
        return false;
    },

    getBId : function(data){
        if(!data) {
            return null;
        }
        if(!this.isDealWith(data)){
            return null;
        }
        if (typeof(data) =='string') {
          return data;
        }
        return data.getId();
    },

    addGlobal : function(data){
        if(data instanceof it.Link){
            this.addGlobalLink(data);
            return ;
        }
        var id = this.getBId(data);
        if(id){
            this._global_tmap[id] = true;
        }
    },

    addGlobalLink : function(link){
        var id = this.getBId(link);
        if(id){
//            this._global_linkTmap[id] = true; //linkvirture
        }
    },

    addGlobalByDescendant : function(data){
        if(!data){
            return ;
        }
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.addGlobal(data);
        var node = this.sceneManager.dataNodeMap[data.getId()];
        var children = node.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childData = this.getDataByNode(child);
                if(childData
                    && this.getBId(childData) != this.getBId(data)){
                    this.addGlobalByDescendant(child,this);
                }
            }
        }

    },

    removeGlobal : function(data){
        var id = this.getBId(data);
        if (id) {
            if (data instanceof it.Link) {
                delete this._global_linkTmap[id];
            } else {
                delete this._global_tmap[id];
            }
        }
    },

    removeGlobalByDescendant : function(data){
        if(!data){
            return;
        }
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.removeGlobal(data);
        var node = this.sceneManager.dataNodeMap[data.getId()];
        var children = node.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childData = this.getDataByNode(child);
                if(childData
                    && this.getBId(childData) != this.getBId(data)){
                    this.removeGlobalByDescendant(child,this);
                }
            }
        }
    },
    
    /**
     * 
     */
    beforeAdd : function(data){

    },

    add : function(data){
        this.beforeAdd(data);
        var id = this.getBId(data);
        if(id){
            if(data instanceof it.Link){
//                this._linkTmap[id] = true; //linkvirture
            }else{
                this._tmap[id] = true;
            }
        }
    },

    addLink : function(link){
        if(!link) return;
        var id = this.getBId(link);
        if(id){
//            this._linkTmap[id] = true; //linkvirture
        }
    },

    getDataByNode : function(node){
        if(!node){
            return null;
        }
        return node.getClient(it.SceneManager.CLIENT_IT_DATA);
    },

    addByDescendant : function(data){
        if(!data) return;
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.add(data);
        /** data3D  update 2017-06-28
        var node = this.sceneManager.dataNodeMap[data.getId()];
        var children = node.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childData = this.getDataByNode(child);
                if(childData
                    && this.getBId(childData) != this.getBId(data)){
                    this.addByDescendant(child,this);
                }
            }
        }*/
        var children = data.getChildren();
        if (!children || children.size() < 1) {
            return;
        }
        for(var i = 0 ;i < children.size() ; i++){
             var childData = children.get(i);
             if(childData){
                this.addByDescendant(childData,this);
             }
        }
    },

    remove : function(data){
        var id = this.getBId(data);
        if(id){
            if(data instanceof it.Link){
                delete this._linkTmap[id];
            }else{
                if(data.getAllLinks){ // datalink
                    var links = data.getAllLinks();
                    if(links){
                        for(var linkId in links){
                            delete this._linkTmap[linkId];
                        }
                    }
                }
                delete this._tmap[id];
            }
        }
    },

    /**
     *
     * @param data dataElement
     */
    removeByDescendant : function(dataOrElement){
        var data = dataOrElement;
        if(!data) return ;
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.remove(data);
        var node = this.sceneManager.dataNodeMap[data.getId()];
        if(data instanceof it.Link){
            node = this.sceneManager.linkMap[data.getId()];
        }
        var self = this;
        if(!node || !node.getChildren){
//            console.log('Stop!');
        }
//        var children = node.getChildren();
//        if(children && children.size() > 0){
//            for(var i = 0 ; i < children.size(); i++){
//                var child = children.get(i);
//                var childData = self.getDataByNode(child);
//                if(childData
//                    && self.getBId(childData) != self.getBId(data)){
//                    self.removeByDescendant(child,self);
//                }
//            }
//        }
        var children = null;
        if(data.getChildren){ //it.link
            children = data.getChildren(); //datachildren3Dparentparentnull
            if(children && children.size() > 0){
                for(var i = 0 ; i < children.size(); i++){
                    var child = children.get(i);
//                var childData = self.getDataByNode(child);
                    if(child
                        && self.getBId(child) != self.getBId(data)){
                        self.removeByDescendant(child,self);
                    }
                }
            }
        }

    },

    /**
     * 
     * it.Link
     */
    addAll:function(){
        this.addAllData();
        this.addAllLink();
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'addAll'
        });
    },

    addAllData : function(){
        var dataMap = this.sceneManager.dataManager.getDataMap();
        if(!dataMap) return ;
        for(var id in dataMap){
            var data = dataMap[id];
            if(data){
                this.add(data);
            }
        }
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'addAllData'
        });
    },

    addAllLink : function(){
        var linkMap = this.sceneManager.dataManager.getLinkMap();
        if(!linkMap) return ;
        for(var id in linkMap){
            var link = linkMap[id];
            if(link){
                this.addLink(link);
            }
        }
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'addAllLink'
        });
    },

    isDealWithBillboard : function(node){
        return true;
    },

    isDealWithParticle : function(node){
        return true;
    },

    isVirtual : function(node){
        var data = node;
        if(node instanceof mono.Element){
            data = this.getDataByNode(node);
        }
        if(!(data instanceof it.Data) && !(data instanceof it.Link)) {
           // return true;
           return false; //
        }
        var dataNode = this.sceneManager.getNodeByDataOrId(data);
        if (dataNode && dataNode.getClient(it.SceneManager.CLIENT_EXT_VITUAL)) { //
            return false;
        }
        var id = this.getBId(data);
        var transFlag = false;
        if(id){
            if(node instanceof mono.Link){
                if(this._global_linkTmap[id]){ // global
                    transFlag = this._global_linkTmap[id];
                }else if(this._linkTmap[id]){
                    transFlag = this._linkTmap[id];
                }
            }else{
                if(this._global_tmap[id]){ // global
                    transFlag = this._global_tmap[id];
                }else if(this._tmap[id]){
                    transFlag = this._tmap[id];
                }
            }
        }
        return transFlag;
    },

    isLink : function(node){
        if(node
            && node.getClient(it.SceneManager.CLIENT_IT_DATA)
            && node.getClient(it.SceneManager.CLIENT_IT_DATA) instanceof it.Link){
            return true;
        }
        return false;
    },

    /**
     * billboardbillboard
     * @param node
     */
    isHideVirtualBillboard : function(node){
        if(node
            &&node instanceof mono.Billboard
            && node.getParent()){
            // var parent = node.getParent();
            // if(parent._alarmBillboard == node){// billboardbillboard
            //     return true;
            // }
            if (node.getClient('_alarmBillboard')) {
                return true;
            }
        }
        return false;
    },

    isHideVirtualParticle : function(node){
        if(node
            &&node instanceof mono.Particle
            && node.getParent()){
            // var parent = node.getParent();
            // if(parent._alarmBillboard == node){
            //     return true;
            // }
            if (node.getClient('_alarmParticle')) {
                return true;
            }
        }
        return false;
    },

      setFocusElement : function(element){
//          this.focusElement = element;
//          this.sceneManager.viewManager3d.network.dirtyNetwork();
      },

    setOpacityValue : function(opacityValue){
        if(opacityValue){
            this.opacityValue = opacityValue;
        }
    },

    getOpacityValue : function(data){
        if (this.getOpacityValueFunction && this.getOpacityValueFunction(data)) {
            return this.getOpacityValueFunction(data);
        }
        return this.opacityValue;
    },

    /**
     * billboardFilter
     * transparentopacity
     * removehandlebillboard
     */
    destoryBillboard : function(){
        if(!this._billboard_tmap) return;
        for(var id in this._billboard_tmap){
            var billboard = this._billboard_tmap[id];
            if(billboard.hasOwnProperty('orig_opacity')){
                var orig_opacity = billboard.orig_opacity;
                if(orig_opacity == undefined){
                    orig_opacity = 1;
                }
                billboard.setStyle('m.opacity',orig_opacity);
                if(this.isHideVirtualBillboard(billboard)){
                    billboard.setVisible(true);
                }
                delete billboard.orig_opacity;
                billboard.renderDepth = 0;
                delete this._billboard_tmap[billboard.getId()];
            }
        }
    },

    destoryParticle : function(){
        if(!this._particleMap) return;
        for(var id in this._particleMap){
            var particle = this._particleMap[id];
            if(particle.hasOwnProperty('smoke_opacity')){
                var smoke_opacity = particle.smoke_opacity;
                if(this.isHideVirtualParticle(particle)){
                    particle.setStyle('m.opacity',smoke_opacity);
                }
                delete particle.smoke_opacity;
                particle.renderDepth = 0;
                delete this._particleMap[particle.getId()];
            }
        }
    },

    getParentDataByNode : function(node,scope){
      if (!node) {
        return null;
      }
      if (!scope) {
        scope = this;
      }
      var data = scope.getDataByNode(node);
      if (data) {
        return data;
      }else{
         var parentNode = node.getParent();
         return arguments.callee(parentNode,scope);
      }
    },

    filterMaterial : function(originalMaterial,filterdMaterial,node){
        if (!(this.isLink(node)) && node instanceof mono.Line) {
            return originalMaterial;
        }
        if (node && node.getClient(it.SceneManager.CLIENT_EXT_VITUAL)) { // 
          return originalMaterial;
        }
        var materialMap = this.materialMap;
        var material = filterdMaterial ? filterdMaterial : originalMaterial;
        var data = this.getDataByNode(node);
        if (!data
            && (node instanceof mono.Billboard)
            && node.getParent()) { //billboarddata(board)
            data = this.getDataByNode(node.getParent());
        }
          // datanodedata -- add by Kevin 2016-11-04
        if (!data) {
           data = this.getParentDataByNode(node);
        }
        // var opacityValue = this.opacityValue;
        var opacityValue = this.getOpacityValue(data);
        if(opacityValue == 1){
            // return originalMaterial;
            return material; // originalMaterial,update by Kevin 2017-07-04
        }
        var id = "";
        var transFlag = false;
        if (data && data instanceof it.Link && this.isDealWithLink()){
            id = this.getBId(data);
            if (id) {
                if (this._global_linkTmap[id]) { // global
                      transFlag = this._global_linkTmap[id];
                } else if (this._linkTmap[id]) {
                    transFlag = this._linkTmap[id];
                }
            }
            if (transFlag) {
                this._link_tmap[node.getId()] = node.isVisible();
                node.setVisible(false);
            } else {
                if(this._link_tmap[node.getId()] != null || !(this._link_tmap[node.getId()] === undefined)){
                    node.setVisible(this._link_tmap[node.getId()]);
                    delete this._link_tmap[node.getId()];
                }
            }
            return material;
        } else {
            if (data && data instanceof it.Data) {
//                  id = data.getId();
                id = this.getBId(data);
            }
              if (id) {
                  if (this._global_tmap[id]) { // global
                      transFlag = this._global_tmap[id];
                  } else if (this._tmap[id]) {
                      transFlag = this._tmap[id];
                  }
              }
          }

          if (node instanceof mono.Billboard && this.isDealWithBillboard(node)) {
              if (transFlag) { // billboard
                  node.renderDepth = 10000;
                  if (!node.hasOwnProperty("orig_opacity")) { // 
                      node.orig_opacity = node.getStyle('m.opacity');
                  }
                  this._billboard_tmap[node.getId()] = node;
                  node.setStyle('m.opacity', opacityValue);
                  if (this.isHideVirtualBillboard(node)) {
                      node.setVisible(false); //
                  }
              } else { // 
                  if (node.hasOwnProperty('orig_opacity')
                      && this._billboard_tmap[node.getId()]) { //newfilter,map
                      var orig_opacity = node.orig_opacity;
                      if (orig_opacity == undefined) {
                          orig_opacity = 1;
                      }
                      node.setStyle('m.opacity', orig_opacity);
                      if (this.isHideVirtualBillboard(node)) {
                          node.setVisible(true);
                      }
                      delete node.orig_opacity;
                      node.renderDepth = 0;
                      delete this._billboard_tmap[node.getId()];
                  }
              }
              return material;
          }

          //
          if (node instanceof mono.Particle && this.isDealWithParticle(node)) {
            if (transFlag) {
                node.renderDepth = 10000;
                if (!node.hasOwnProperty("smoke_opacity")) { // 
                    node.smoke_opacity = node.getStyle('m.opacity');
                }
                this._particleMap[node.getId()] = node;
                if (this.isHideVirtualParticle(node)) {
                    node.setStyle('m.opacity', 0.001);
                }            
            } else {
                if (this._particleMap[node.getId()] && node.hasOwnProperty('smoke_opacity')) {
                    var smoke_opacity = node.smoke_opacity;
                    if (this.isHideVirtualParticle(node)) {
                        node.setStyle('m.opacity', smoke_opacity);
                    }
                    delete this._particleMap[node.getId()];
                    node.renderDepth = 0;
                    delete node.smoke_opacity;
                }
            }
            return material;
        }

          if (!transFlag) {
              return material;
          }

          var key = filterdMaterial ? filterdMaterial.getUniqueCode() : originalMaterial.getUniqueCode();
          if (materialMap[key] == null) {
              var m = filterdMaterial ? filterdMaterial.clone() : originalMaterial.clone();
              m.transparent = true;
              if( m.opacity > opacityValue){ // materialFilteropacityValue -- Kevin 2017-06-29 
                 m.opacity = opacityValue;
              }
              materialMap[key] = m;
              return m;
          } else {
              return materialMap[key];
          }
    }

});

it.VirtualManager = $VirtualManager;

var $SelectableFilter = function(){

};

mono.extend($SelectableFilter,Object, {

    isSelectable : function(node,network){
        return true;
    }
});

it.SelectableFilter = $SelectableFilter;

var $SelectableManager = function(virtualManager){
    this.virtualManager = virtualManager;
};

mono.extend($SelectableManager,$SelectableFilter,{

    isSelectable : function(node,network){
       if(this.virtualManager.isVirtual(node)){
           return false;
       }
       if(node instanceof mono.Line){
       	 return false;
       }
        return true;
    }
});

it.SelectableManager = $SelectableManager;

/**
 * 
 * 1sceneManager.resetCamera();
 * 2dc
 * 3target
 **/

$CameraManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.onloadFinishFunction = null;
	this.doAnimateFunction = null;
	this.finalCameraFunction = null;
    this.beforeSceneChangeCameraFunction = null;
    this._afterPlayCameraListener = []; // sceneChangerListenerlistener
	this.initCamera();
	this.callback = this.afterPlayCamera;
    this._stopCamera = false;
};

mono.extend($CameraManager,Object,{

     /**
      * 
      */
     initCamera : function(){
     	var self = this;
        // resetCameramoveCameraCallback
     	this.sceneManager.resetCamera = function(scene, rootData,oldScene,oldRootData,clientMap){
            if (!self.sceneManager.resetCameraWhenSceneChange) {
                self.sceneManager.resetCameraWhenSceneChange = true;
                return ;
            }
            if (self._stopCamera) {
                self._stopCamera = false;
                return;
            }
     		self.setCameraForOnloadFinish(scene, rootData,oldScene,oldRootData,clientMap);
     	}

        this.sceneManager.beforeLoadSceneAnimate = function(scene, rootData,oldScene,oldRootData,callback,scope){
            if (self.beforeSceneChangeCameraFunction) {
                self.beforeSceneChangeCameraFunction(scene, rootData,oldScene,oldRootData,callback,scope)
            }else{
                if (callback) {
                  callback.call(scope);
                }
            }
        }

     },

     setStopCamera : function(stopCamera){
        this._stopCamera = (stopCamera === true);
     },

     /**
      * 
      */
     beforePlaySceneChangeAnimate : function(scene, rootData,oldScene,oldRootData,clientMap){
        return true;
     },

    /**
     * 
     */
	setCameraForOnloadFinish : function(scene, rootData,oldScene,oldRootData,clientMap){
        if (!this.beforePlaySceneChangeAnimate(scene, rootData,oldScene,oldRootData,clientMap)){
            return;
        }
		var scope = this;
		var callback = function(){
			scope.doAnimate(scene, rootData,oldScene,oldRootData,clientMap);
		}
		// var callback = this.doAnimate;
		if (this.onloadFinishFunction) {
			this.onloadFinishFunction(scene, rootData,oldScene,oldRootData,callback);
			return;
		}
		var sm = this.sceneManager;
		if(sm.resetCameraWhenSceneChange){
           if (sm._currentRootNode) {
              sm.viewManager3d.getDefaultEventHandler().lookAtNodeWithOutAnimate(sm._currentRootNode);
           }else{
              sm.network3d.zoomEstimateOverview(30);
           }
        }
        sm.resetCameraWhenSceneChange = true; 
        callback.call(this,scene, rootData,oldScene,oldRootData);
	},

    /***
     * doAnimate
     * 
     * floorDatacenter
     */
    isDoAnimate : function(scene,rootData,oldScene,oldRootData,clientMap){
        return true;
    },

    /**
     * loaddc
     */
    doAnimate : function(scene, rootData,oldScene,oldRootData,clientMap){
    	var scope = this;
    	var callback = function(){
    		scope.setFinalCamera(scene, rootData,oldScene,oldRootData,clientMap);
    	}
    	if (this.isDoAnimate(scene, rootData,oldScene,oldRootData,clientMap) && this.doAnimateFunction) {
    		this.doAnimateFunction.call(this,scene, rootData,oldScene,oldRootData,callback,clientMap);
    		return;
    	}
    	callback(scene, rootData,oldScene,oldRootData,clientMap);
    },

    /***
     * setFinalCamera
     * 
     * floorDatacenter
     */
    isDoFinalCamera : function(scene,rootData,oldScene,oldRootData,clientMap){
        return true;
    },

    /**
     * ,scene
     * scene
     */
	setFinalCamera : function(scene, rootData,oldScene,oldRootData,clientMap){
		var scope = this;
		var callback = function(){
            if(scope.callback){
                scope.callback(scene, rootData,oldScene,oldRootData,clientMap);
            }  
        }
		// this.sceneManager.setSceneCamera(scene); // remove 2017-08-28,scenefov
		if (this.finalCameraFunction) {
			this.finalCameraFunction(scene, rootData,oldScene,oldRootData,callback,clientMap);
			return;
		}
        callback();
	},

    addAfterPlayCameraListener : function(listener,scope){
        listener.scope = scope;
        this._afterPlayCameraListener.push(listener);
    },

    removeAfterPlayCameraListener : function(listener){
        var index = this._afterPlayCameraListener.indexOf(listener);
        if(index !== -1){
            this._afterPlayCameraListener.splice(index,1);
        }
    },

    afterPlayCamera : function(scene, rootData,oldScene,oldRootData,clientMap){
        if (!this._afterPlayCameraListener) {
            return ;
        }
        for(var i = 0 ; i < this._afterPlayCameraListener.length ; i++){
            var l = this._afterPlayCameraListener[i];
            l.call(l.scope||this,scene, rootData,oldScene,oldRootData,clientMap);
        }
    },

    // getFinalCameraTargetAndPosition : function(scene, rootData,oldScene,oldRootData){
       
    // }

});

it.CameraManager = $CameraManager;



// 
var $DataFinder = function (dataManager) {
	this.dataManager = dataManager;
	this.descentdantMap = {};
    this.ancesstorIdsMap = {};
    this.init();
};

mono.extend($DataFinder,Object,{

    /**
     * 
     */ 
    init : function(){
    },

    getGetMethod : function(key){
       var getMethod = 'get' + key.charAt(0).toUpperCase() + key.slice(1);
       return getMethod;
    },

    /**
     * 
     * @returns {*}
     */
    getDatas : function(){
        return this.dataManager.getDatas();
    },

    /**
     * 
     * @param id
     * @returns {*}
     */
    getDataById : function(id){
        return this.dataManager.getDataById(id);
    },

    /**
     * ,
     * keyClientdatadata.obj
     */
     /*
    getDataByKey : function(key,value){
       if(!key && !value){
          return null;
       }
       var searchUserData = false;
       var searchCategory = false;
       var searchDataType = false;
       if(key.toUpperCase().startsWith('U:')){
         searchUserData = true;
         key = key.slice(2);
       }else if (key.toUpperCase().startsWith('C:')) { // category
          searchCategory = true;
          key = key.slice(2);
       }else if(key.toUpperCase().startsWith('D:')){ // dataType
          searchDataType = true;
          key = key.slice(2);
       }
       var getMethod = this.getGetMethod(key);
       var i = 0,datas = this.getDatas(),data;
       for(;i < datas.length;i ++){
          data =datas[i];
          if(searchUserData){
             var userData = data.getUserData(key);
             if(userData == value){
                return data;
             }
          }else if(searchCategory){
            var category = this.dataManager.getCategoryForData(data);
            if(category[getMethod] == null){
                var userData = category.getUserData(key);
                if(userData == value){
                  return data;
                }
            }
            if(category[getMethod]() == value){
               return data;
            }
          }else if(searchDataType){
            var dataType = this.dataManager.getDataTypeForData(data);
            if(dataType[getMethod] == null){
                var userData = dataType.getUserData(key);
                if(userData == value){
                  return data;
                }
            }
            if(dataType[getMethod]() == value){
               return data;
            }
          }else if(data[getMethod] == null){
             var userData = data.getUserData(key);
             if(userData == value){
                return data;
             }
          }
          if(data[getMethod]() == value){
             return data;
          }
          if(key === 'ancestor'){//
             if(this.isChild(data,value,this)){
                 return data;
             }
          }
       }
       return null;
    },
    */

    isChild : function(data,ancestorId,scope){
        if(!data || !ancestorId){
            return false;
        }
        if(data.getId() == ancestorId){
            return true;
        }else if(data.getParentId() == ancestorId){
            return true;
        }else if(!data.getParentId()){
            return false;
        }else{
            var parentData = this.dataManager.getDataById(data.getParentId());
            var scope = scope||this;
            return scope.isChild(parentData,ancestorId,scope);
        }
    },

    /**
     * data
     * @param data
     * @returns {boolean}
     */
    filter : function(data){
        return true;
    },
    
    isVisible : function(data){
        if (data) {
            var category = this.dataManager.getCategoryForData(data);
            if (category && !category.isVisible()) {
                return false;
            }
        }
        return true;
    },

    /** 
     *  json like {key : "id,name", value: "xxx",type : 'string',operation : 'equal'|'like'|'between','descentdantOf'} operation,
     *  descentdantOf 
     */
    find : function(conditions) {
        var datas = this.getDatas();
        if (!datas || datas.length < 1) {
            return [];
        }
        var results = [];
        if (!conditions || conditions.length < 1) {
//            return datas; // ,
            for(var i = 0 ; i < datas.length; i++){
                if(this.isVisible(datas[i]) &&
                   this.filter(datas[i])){
                     results.push(datas[i]);
                }
            }
            return results;
        }
        var data, i = 0, len = datas.length;
        for (; i < len; i++) {
            data = datas[i];
            if(!this.isVisible(data)
                ||!this.filter(data)){
                continue;
            }
            if (this.isDataConformConditions(data, conditions)) {
                results.push(data);
            }
        }
        return results;
    },

    /**
     * conditions:[{dataType:"string",key:"id,description",operation:"like", value:"rack,1"},{dataType:'',key''..},...]
     */
    isDataConformConditions : function(data,conditions){
       var conform = true;
       for(var p in conditions){
          if(!this.isDataConformCondition(data,conditions[p])){
            conform = false;
            break;
          }
       }
       return conform;
    },

    isDataConformCondition : function(data,condition,key){
        if(condition.value == '' || condition.value == null){
            return true;
        }
        var key = key || condition.key;
        var dataType = condition.dataType || 'string'; 
        if(key.indexOf(',') > 0){
            var splitKeys = key.split(',');
            for(var i = 0;i < splitKeys.length;i ++){
                if(this.isDataConformCondition(data,condition,splitKeys[i])){
                    return true;
                }
            }
            return false;
        }
        var searchUserData = false;
        var searchCategory = false;
        var searchDataType = false;
        if(key.toUpperCase().startsWith('U:')){
            searchUserData = true;
            key = key.slice(2);
        }else if (key.toUpperCase().startsWith('C:')) { // category
          searchCategory = true;
          key = key.slice(2);
        }else if(key.toUpperCase().startsWith('D:')){ // dataType
          searchDataType = true;
          key = key.slice(2);
        }
        var getMethod = this.getGetMethod(key);
        // if(data[getMethod] == null){
        //    searchUserData = true;
        // }
        var operation = condition.operation;
        var value = condition.value;
        var dataValue = null;
        // if(searchUserData || data[getMethod] == null){
        //     dataValue = data.getUserData(key);
        // }else{
        //     var getMethod = this.getGetMethod(key);
        //     dataValue = data[getMethod]();
        // }
        if(searchUserData){
            dataValue = data.getUserData(key);
        } else if (searchCategory) {
            var category = this.dataManager.getCategoryForData(data);
            if(category[getMethod] == null){
                dataValue = category.getUserData(key);
            }else {
                dataValue = category[getMethod]();
            }
        }else if(searchDataType){
            var dataType = this.dataManager.getDataTypeForData(data);
            if(dataType[getMethod] == null){
                dataValue = dataType.getUserData(key);
            }else {
                dataValue = dataType[getMethod]();
            }
        }else{
            var getMethod = this.getGetMethod(key);
            dataValue = data[getMethod]&&data[getMethod]();
        }
        if(!dataValue && key==='ancestor'){
            if(this.isChild(data,condition.value,this)){
                return true;
            }
        }
        var compareMethod = this[operation];
        if(typeof compareMethod === 'function'){
           return this[operation](value,dataValue,key); 
        }else{
           return this.other(value,dataValue,key,operation,dataType);
        }
    },
    
    /**
     * 
     */
    equal : function(value,dataValue,key){
        if(value && dataValue){
            return value.toLowerCase() == dataValue.toLowerCase();
        }
       return dataValue == value;
    },

    like : function(value,dataValue,key){
        dataValue = dataValue + '';
        if (dataValue.trim) {
            dataValue = dataValue.trim();
        }
        if (value.trim) {
            value = value.trim();
        }
        // if(dataValue.startsWith){
        //     if(value){
        //         return dataValue.toLowerCase().startsWith(value.toLowerCase());
        //     }
        //    return dataValue.startsWith(value); 
        // }
        value = value.toLowerCase();
        dataValue = dataValue.toLowerCase();
        if (dataValue.indexOf) {
            if (dataValue.indexOf(value) >= 0) {
                return true;
            }
        }
        return false;
    },

    /**
     * 
     */
    between : function(value,dataValue,key){
       if(value[0] || value[1]){
          if(value[0] == null) return dataValue <= value[1];
          if(value[1] == null) return dataValue >= value[0];
          return dataValue >= value[0] && dataValue<= value[1];
       }
       return false;
    },

    /**
     * ><<=>=<> 
     * @param value
     * @param dataValue
     * @param key
     */
    other : function(value,dataValue,key,operation,dataType){
        if(!operation){
            return this.like(value,dataValue,key);
        }
        dataType = dataType||'string';
        // 0true  2018-1-23 add by lyz
        if ((value || value == 0) && (dataValue || dataValue == 0)) {
        // if(value && dataValue){
            if(dataType == 'number'){
                dataValue = parseFloat(dataValue);
                value = parseFloat(value);
            }else{
                if(typeof(dataValue) === 'number'){
                   dataValue += '';
                }
            }
            var operation = operation.trim();
            if(operation == '>'){
                return dataValue > value;
            }else if(operation == '<'){
                return dataValue < value;
            }else if(operation == '<='){
                return dataValue <= value;
            }else if(operation == '>='){
                return dataValue >= value;
            }else if(operation == '='){
                if(typeof(dataValue)=='number' || typeof(value)=='number'){
                     return (dataValue === value);
                }else{
                    return dataValue.toLowerCase() == value.toLowerCase();
                }
            }
        }
        return this.like(value,dataValue,key);
    },

    descentdantOf : function(value,dataValue,key){
        if(key !== 'id'){
            throw 'Only id support descentdantOf';
        }
        var data1 = this.getDataById(value);
        var data2 = this.getDataById(dataValue);
        if(data1 == null || data2 == null){
            return false;
        }
        var ancestors = this.dataManager.getAncestors(data2) || [];
        return ancestors.indexOf(data1) !== -1;
    },

});

it.DataFinder = $DataFinder;


var $BuildingToFloorHandle = function(bfAdapter) {
	this.bfAdapter = bfAdapter;
	this.sceneManager = this.bfAdapter.sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	this.beforeDoubleClickFloorFunction = null;
	// this.animates = []; // 
};

mono.extend($BuildingToFloorHandle, Object, {

	/**
     * dcbuilding(doubliClick):
      floor,floors
    */
	doubliClickFloorNode: function(element, network, data, clickedObj, callback) {
		if (this.beforeDoubleClickFloorFunction) {
			this.beforeDoubleClickFloorFunction(element);
		}
		if (!data) {
			return;
		}
		var parentData = this.dataManager.getDataById(data.getParentId());
		if (!parentData) {
			return;
		}
		var deHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
		var category = this.dataManager.getCategoryForData(data);
		var scene = this.dataManager.getSceneByCategory(category);
		var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
		if (this.sceneManager._currentScene == scene && sceneAndRootData && this.sceneManager._currentRootData == sceneAndRootData.rootData) {
			deHandler.moveToClickPoint(clickedObj);
			return;
		}
		if (!scene) {
			return;
		}
		if (this.doubleClickFloorNodeFlag) {
			return;
		}
		this.sceneManager.viewManager3d.enableDBLClick = false;
		var virFilter = new it.VirtualManager(this.sceneManager);
		virFilter.opacityValue = 1;
		virFilter.addByDescendant(this.sceneManager._currentRootData);
		virFilter.removeByDescendant(data);
		this.sceneManager.viewManager3d.addMaterialFilter(virFilter);
		this.doubleClickFloorNodeFlag = true; //
		var floorNodes = [];
		var self = this;
		var children = parentData.getChildren();
		var lookAtFloorNode = this.sceneManager.dataNodeMap[data.getId()];
		for (var i = children.size() - 1; i >= 0; i--) {
			var child = children.get(i);
			var childCategory = this.dataManager.getCategoryForData(child);
			if (childCategory &&
				childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
				var floorNode = this.sceneManager.dataNodeMap[child.getId()];
				if (floorNode && floorNode.getY() > lookAtFloorNode.getY()) {
					floorNodes.push(floorNode);
				}
			}
		}
		var camera = this.sceneManager.network3d.getCamera();
		if (network) {
			camera = network.getCamera();
		}

		var focusNode1 = this.sceneManager.viewManager3d.getFocusNode();

		var palyLookAtFun = function() {
			//()focusNode
			var focusNode2 = self.sceneManager.viewManager3d.getFocusNode();
			if (focusNode2 != focusNode1) {
				this.doubleClickFloorNodeFlag = false;
				self.sceneManager.viewManager3d.enableDBLClick = true;
				return;
			}
			var callback1 = function() {
				camera.fov = 60; //resetCamer
				/* 
				 *  // update By Kevin 2017-06-21 
				 * toScenedataBox_loadOneScenedataBox
				 * dcbuildingfloor
				 */
				// self.sceneManager.toScene(scene, data,callback);
				// self.removeDcAndBuilding(data);
				var oldScene = self.sceneManager.getCurrentScene();
				var oldRootData = self.sceneManager._currentRootData;
				// self.sceneManager.resetCameraWhenSceneChange = false;//-- 2017-09-07 Kevin
																		//false -- 2018-02-23 jay
				// floorparent loadOneScenenode
				self.sceneManager._loadOneScene(scene, data, callback); 
				//_loadOneScene
				if (data) {
					var dataNode = self.sceneManager.dataNodeMap[data.getId()];
					dataNode && dataNode.setParent(null);
					self.sceneManager.viewManager3d.setFocusNode(dataNode);
				}
				self.doubleClickFloorNodeFlag = false;
				self.sceneManager.viewManager3d.enableDBLClick = true;
				//2017-10-26 cameraManagercallback
				//2018-3-1 AfterPlayCamer
				// if(self.sceneManager.cameraManager.callback){ 
				// 	self.sceneManager.cameraManager.callback(scene, data,oldScene,oldRootData);
				// } 
			};
			callback1();
		};

		var dataPosition = data.getPosition();
		var oldPosition = lookAtFloorNode.getWorldPosition().clone();
		var nScale = lookAtFloorNode.getScale();

		var getAbsoluteRotationByNode = function(node) {
			if (!node) {
				return null;
			}
			var rot = node.getRotation().clone();
			var parentNode = node.getParent();
			if (parentNode) {
				var pRot = getAbsoluteRotationByNode.call(this, parentNode);
				if (pRot) {
					rot.x = rot.x + pRot.x;
					rot.y = rot.y + pRot.y;
					rot.z = rot.z + pRot.z;
				}
			}
			return rot;
		}

		var rotation = getAbsoluteRotationByNode(lookAtFloorNode);
		/**
		 * floorScaleposition
		 * Camera
		 */
		var restorePosScaleAndRotationCallback = function() {
			var fBb = lookAtFloorNode.getBoundingBox();
			var oldDistance = camera.getDistance();
			var distance = fBb.size().z > fBb.size().x ? fBb.size().x : fBb.size().z;
			distance = distance * 2;
			var angles = mono.Utils.getVectorAngles(camera.target, camera.getPosition());
			var dataRotation = data.getRotation() || new mono.Vec3();
			var restorePosAndScaleAnimate = new mono.Animate({
				from: 0,
				to: 1,
				dur: 1000,
				onUpdate: function(value) {
					var pos = new mono.Vec3().lerpVectors(oldPosition, dataPosition, value);
					lookAtFloorNode.setPosition(pos);
					if (lookAtFloorNode.orgScale) {
						var oScale = lookAtFloorNode.orgScale.clone();
						lookAtFloorNode.setScaleX(nScale.x + (oScale.x - nScale.x) * value);
						lookAtFloorNode.setScaleY(nScale.y + (oScale.y - nScale.y) * value);
						lookAtFloorNode.setScaleZ(nScale.z + (oScale.z - nScale.z) * value);
					}
					lookAtFloorNode.setRotationX(rotation.x + (dataRotation.x * mono.Utils.DEGREES_TO_RADIANS - rotation.x) * value);
					lookAtFloorNode.setRotationY(rotation.y + (dataRotation.y * mono.Utils.DEGREES_TO_RADIANS - rotation.y) * value);
					lookAtFloorNode.setRotationZ(rotation.z + (dataRotation.z * mono.Utils.DEGREES_TO_RADIANS - rotation.z) * value);

					var d = (oldDistance + (distance - oldDistance) * value); // 400moveCameraToCloseFloor()
					
					var cPos = new mono.Vec3(); 
					// pos.x = camera.target.x + d * Math.sin(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					// pos.z = camera.target.z + d * Math.cos(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					// pos.y = camera.target.y + d * Math.sin(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					// add floorpositionfloor update 2017-07-11
					var target = pos.clone();
					cPos.x = target.x + d * Math.sin(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					cPos.z = target.z + d * Math.cos(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					cPos.y = target.y + d * Math.sin(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					camera.setPosition(cPos);
					camera.lookAt(target);
				},
				onStop: function() {
					// playFinalCamera();
					palyLookAtFun();
				}
			});
            // self.animates.push(restorePosAndScaleAnimate); //  2017-10-12
			restorePosAndScaleAnimate.play();
		}

		/**
		 * 1floor
		 * 2floorbuilding
		 * restorePosAndScaleAnimate
		 */
		var moveCameraToFocusFloorAndRemoveRelactionShipAnimate = function() {
			var callback = function() {
				self.removeDcAndBuilding(data);
				if (lookAtFloorNode.orgScale) {
					lookAtFloorNode.setScaleX(nScale.x);
					lookAtFloorNode.setScaleY(nScale.y);
					lookAtFloorNode.setScaleZ(nScale.z);
				}
				lookAtFloorNode.setRotationX(rotation.x);
				lookAtFloorNode.setRotationY(rotation.y);
				lookAtFloorNode.setRotationZ(rotation.z);
				lookAtFloorNode.setPosition(oldPosition);
				self.sceneManager.viewManager3d.removeMaterialFilter(virFilter);
				restorePosScaleAndRotationCallback();
			}
			// callback(); 
			// floor 
			var distance = camera.getDistance();
			var cTarget = camera.target;
			var cPos = camera.getPosition();
			var angles= mono.Utils.getVectorAngles(cTarget, cPos);
			var vAngle = angles[1],hAngle = angles[0];
			var endTarget = lookAtFloorNode.getWorldPosition();
            // mono.Animatetwaver.Animate
            // lookAtByData 2017-12-12 add by lyz
			var animate = new twaver.Animate({
				from: 0,
				to: 1,
				dur: 1000,
				onUpdate: function(value) {
					var t = new mono.Vec3().lerpVectors(cTarget,endTarget, value); 
					var newPos = new mono.Vec3();
					newPos.x = t.x + distance * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
					newPos.z = t.z + distance * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
					newPos.y = t.y + distance * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
					camera.p(newPos);
					camera.lookAt(t);
				},
				onStop: function() {
					callback();
				}
			});
			animate.play();
		}

		/**
		 * 
		 */
		var doubliClickFloorNodeAnimate = new mono.Animate({
			from: 0,
			to: 1,
			dur: 1000,
			easing: 'easeOut',
			onUpdate: function(value) {
				for (var i = floorNodes.length - 1; i >= 0; i--) {
					var floor = floorNodes[i];
					var floorData = self.sceneManager.getNodeData(floor);
					var y = parseFloat(floorData.getPosition().y / 10);
					floor.setY(y + 50 + 200 * value);
				}
				virFilter.opacityValue = (1 - value);
				virFilter.materialMap = {};
			},
			// onDone: function() { //stop
			onStop: function() {
				moveCameraToFocusFloorAndRemoveRelactionShipAnimate();
			}
		});
		doubliClickFloorNodeAnimate.play();

	},

	/**
	 * DataBox3DexceptData
	 * exceptData(floor)
	 */
	removeDcAndBuilding: function(exceptData) {
		if (!exceptData) {
			return;
		}
		var exceptNode = this.sceneManager.getNodeByDataOrId(exceptData);
		for (var id in this.sceneManager.dataNodeMap) {
			var node = this.sceneManager.dataNodeMap[id];
			if (node && !this.sceneManager.isAncestor(id,exceptData.getId())) {//idexceptData
				node.setParent(null);
			}
		}
		for (var id in this.sceneManager.dataNodeMap) {
			var node = this.sceneManager.dataNodeMap[id];
			if (node && id != exceptData.getId() && !this.sceneManager.isAncestor(id,exceptData.getId())) {
				this.sceneManager.network3d.dataBox.removeByDescendant(node);
			}
		}
	},



});
/**
 * 
 * 
 * 1opacityValue0()dcfloor
 * 2loadloadloadfocusNodebuilding
 * 3floorbuildingscalerotation3
 * 41opacityValue3
 * 51databoxfloor
 * 
 * 1floor
 * 2FloorDC(floordcdc)
 * 
 */
var $FloorToBuildingHandle = function(bfAdapter) {
	this.bfAdapter = bfAdapter;
	this.sceneManager = bfAdapter.sceneManager;
	this.virFilter = new it.VirtualManager(this.sceneManager);
	this.virFilter.opacityValue = 0.01;
	// virFilter.addByDescendant(this.sceneManager._currentRootData);
	// virFilter.removeByDescendant(data);
	// this.oldIsNeedSetParent = this.sceneManager.isNeedSetParent; //3d
	// this.oldTranslatePosition = this.sceneManager.translatePosition;
	this.oldResetCamera = this.sceneManager.resetCamera;
	this.defaultEventHandler = this.sceneManager.viewManager3d.defaultEventHandler;
	this.animates = [];
	this.init();
};

mono.extend($FloorToBuildingHandle, Object, {

	init: function() {
		var self = this;
        
        /*
		var oldGotoUpLevelSceneFor3D = this.sceneManager.gotoUpLevelSceneFor3D;
		this.sceneManager.gotoUpLevelSceneFor3D = function() { //
			var scene = self.sceneManager._currentScene;
			if (!scene) {
				return false;
			}
			var rootNode = self.sceneManager._currentRootNode;
			var rootData = self.sceneManager._currentRootData;
			if (!rootNode && !rootData) {
				return false;
			}
			var data = self.sceneManager.getNodeData(rootNode);
			if (!data) {
				data = rootData;
			}
			var parentData = self.sceneManager.getUpLevelDataByData(data);
			if (!parentData) {
				return false;
			}
			var parentScene = self.sceneManager.getSceneAndRootByData(parentData);
			if (!parentScene || !parentScene.scene) {
				return false;
			}
			if (parentScene.scene.getId().toLowerCase() == 'datacenter' && scene.getId() == 'floor') {
				self.doFloorToDatacenter(parentScene.scene, parentScene.rootData, scene, data);
			} else {
				oldGotoUpLevelSceneFor3D.call(self.sceneManager);
			}
		}
		*/
	},
     
    /**
     * floor-dc
     */
	destroy: function(){

	},

	// floorbuildinggotoSceneCallbackfloordcdcbuildinggotoScenebuildingdc
	// 2017-12-12 add by lyz
	doFloorToDatacenter: function(dcScene, dc, floorScene, floor, gotoSceneCallback) {
		var self = this;
		/**
		 * floorloadfloorrotation 
		 */
		this.oldIsNeedSetParent = this.sceneManager.isNeedSetParent; 
		this.sceneManager.isNeedSetParent = function(data, node) {
			if (data == floor) {
				return false;
			} else {
				return self.oldIsNeedSetParent.call(self.sceneManager, data, node);
			}
		}
		this.oldTranslatePosition = this.sceneManager.translatePosition;
		this.sceneManager.translatePosition = function(data) {
			if (data == floor) {
				return null;
			} else {
				return self.oldTranslatePosition.call(self.sceneManager, data);
			}
		}
        //
        var oldResetCamera = this.sceneManager.resetCamera;
		this.sceneManager.resetCamera = function() {
			return null;
		}

        this.sceneManager.viewManager3d.enableDBLClick = false;
		var floorNode = this.sceneManager.getNodeByDataOrId(floor);
		/**
		 * load0floor
		 */
		this.sceneManager.viewManager3d.addMaterialFilter(this.virFilter);
		this.virFilter.opacityValue = 0;
		this.virFilter.materialMap = {};
		this.virFilter.addByDescendant(dc);
		this.virFilter.removeByDescendant(floor);
		var defaultHandler = this.sceneManager.viewManager3d.defaultEventHandler;

		// this.bfAdapter.bindingBuildingAndFloorVisibleManager.setVisible(floor, true);//floor 
		var callback = function(endCallback) {
			var buildingNode = self.sceneManager.getNodeByDataOrId(floor.getParentId());
			var bData = self.sceneManager.dataManager.getDataById(floor.getParentId());
			// var floorNodes = self.getFloorsByBuildingNode(buildingNode);
			var dcNode = self.sceneManager.getNodeByDataOrId(bData.getParentId());
			if (dcNode) {
				// self.sceneManager.viewManager3d.setFocusNode(dcNode); // dc
				//switchBuildingffloorscale
				self.sceneManager.viewManager3d.defaultMaterialFilter.addAll();
                self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(dcNode);
			}
			self.sceneManager.viewManager3d.setFocusNode(buildingNode);
			var floorNodes = self.getFloorsByBuildingNode(buildingNode); // setFocus 2017-10-11floor
			// if (floorNodes && floorNodes.length > 1) { 
			// 	defaultHandler.moveCameraForLookAtNodes(floorNodes, null, 30);
			// } else {
			// 	defaultHandler.moveCameraForLookAtNode(buildingNode, callback1);
			// }
			self.sceneManager.viewManager3d.defaultMaterialFilter.clear(); // BuidingAndFloorChangeAdapter
			// self.sceneManager.viewManager3d.defaultMaterialFilter.add(bData);
			// dcfloorbuildingfloorfloor
			self.sceneManager.viewManager3d.defaultMaterialFilter.addByDescendant(bData); //floor
			for (var i = 0; i < floorNodes.length; i++) {
				var fNode = floorNodes[i];
				var fData = self.sceneManager.getNodeData(fNode);
				self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(fData);
				// self.bfAdapter.bindingBuildingAndFloorVisibleManager.setVisible(fData, true); //sceneChangefloor
				if (fData != floor) {
					fNode.setParent(buildingNode);
					fNode.setY(fData.getPosition().y / 10 + 50); // +50
					self.sceneManager.computeRotation(fData, bData, fNode, buildingNode);
					var fScale = self.getFloorScaleInDc(fNode, buildingNode) || new mono.Vec3(1, 1, 1);
					fNode.setScale(fScale);
				}
			}
			setTimeout(function() {
				self.removeChildrenByFloorNode(floorNode);
				self.doFloorPRSAnimate(floorNode,endCallback);
			}, 500);
		}
		//loadbug
		//2017-10-20 _loadOneScenenodeit_data_idit_datafloorfloor
		// this.clearOtherFloorParentRelaction(floor); 
		this.clearOtherFloorParentRelaction(); 
		this.animates = [];
		var oldScene = self.sceneManager.getCurrentScene();
		var oldRootData = self.sceneManager._currentRootData;
		this.sceneManager._loadOneScene(dcScene, dc);
		// this.setBrotherFloorPositionY(floor);
		this.sceneManager.resetCamera = oldResetCamera; // 
		var endCallback = function(){
			if(self.sceneManager.cameraManager.callback){ 
				self.sceneManager.cameraManager.callback(dcScene, dc,oldScene,oldRootData);
			}
			gotoSceneCallback&&gotoSceneCallback();
		};
		callback(endCallback);
		this.sceneManager.isNeedSetParent = this.oldIsNeedSetParent;
		this.sceneManager.translatePosition = this.oldTranslatePosition;
	},

    /**
     * 50
     */
    /*
	setBrotherFloorPositionY : function(floor){
		if (!floor) {
			return ;
		}
		var parent = this.sceneManager.dataManager.getDataById(floor.getParentId());
		var children = parent.getChildren();
		if (children && children.size() > 1) {
			for(var i = 0 ; i < children.size() ; i++){
				var child = children.get(i);
				var cCategory = this.sceneManager.dataManager.getCategoryForData(child);
				if (cCategory 
					&& cCategory.getId() == 'floor' 
					&& child != floor) {
					var childNode = this.sceneManager.getNodeByDataOrId(child);
				    childNode.setY(childNode.getY() + 50);
				}
			}
		}
	},
	*/

    /**
     * 
     * dc
     */
	clearOtherFloorParentRelaction: function(floor){
		var floors = this.sceneManager.dataManager._categoryDatas['floor'];
		if (!floors) {
			return ;
		}
		var self = this;
		for(var id in floors){
			var fData = this.sceneManager.dataManager.getDataById(id);
			if (fData && fData != floor 
				&& fData.getChildren() 
				&& fData.getChildren().size() > 0) {
				// fData.getChildren().forEach(function(child){
				// 	var childNode = self.sceneManager.getNodeByDataOrId(child);
				// 	if (childNode) {
				// 		childNode.setParent(null);
				// 	}
				// });
                this.clearRelactionByParentData(fData);
			}
		}
	},

	/**
	 *
	 * floorpositionrotationscale,
	 * CameralookAtfloorbuilding
	 *
	 */
	doFloorPRSAnimate: function(floor,endCallback) {
		if(!floor){
			this.sceneManager.viewManager3d.enableDBLClick = false;
			return;
		}
		var self = this;
		var buildingNode = this.getBuildingNodeByFloor(floor);
		var floorNodes = this.getFloorsByBuildingNode(buildingNode);
		var endPos = this.getFloorPositionInDc(floor,buildingNode) || new mono.Vec3();
		var endRot = this.getFloorRotationInDc(floor,buildingNode) || new mono.Vec3();
		var endScale = this.getFloorScaleInDc(floor,buildingNode)  || new mono.Vec3(1,1,1);
		var camera = this.sceneManager.network3d.getCamera();
		var oldTarget = camera.target.clone();
		// targetposfloorNodesfloorbuilding(bb)
		var tarAndPos = null;
		if (floorNodes.length == 1) {
			tarAndPos = this.defaultEventHandler.getCameraTarAndPosForLookAtNodes([buildingNode],30);
		}else{
			 var endingFloors = this.getEndingFloorsByFloors(floorNodes,buildingNode,floor);
			 tarAndPos = this.defaultEventHandler.getCameraTarAndPosForLookAtNodes(endingFloors,30);
		}
		// var tarAndPos = this.defaultEventHandler.getCameraTarAndPosForLookArNodes([buildingNode],30);
		var angles = mono.Utils.getVectorAngles(tarAndPos.target, tarAndPos.position);
		
		var oldDistance = camera.getDistance();
		var newDistance = tarAndPos.position.distanceTo(tarAndPos.target);
		var fPos = floor.getWorldPosition();
		var fRot = floor.getRotation();
		var fScale = floor.getScale();
		var animate = new mono.Animate({
			from: 0,
			to: 1,
			dur: 2000,
			onUpdate: function(value) {
				var pos = new mono.Vec3().lerpVectors(fPos, endPos, value);
				floor.setPosition(pos);
				floor.setScaleX(fScale.x + (endScale.x - fScale.x) * value);
				floor.setScaleY(fScale.y + (endScale.y - fScale.y) * value);
				floor.setScaleZ(fScale.z + (endScale.z - fScale.z) * value);
				floor.setRotationX(fRot.x + (endRot.x - fRot.x) * value);
				floor.setRotationY(fRot.y + (endRot.y - fRot.y) * value);
				floor.setRotationZ(fRot.z + (endRot.z - fRot.z) * value);
                
                var target = new mono.Vec3().lerpVectors(oldTarget, tarAndPos.target, value);
				var d = (oldDistance + (newDistance - oldDistance) * value); // 400moveCameraToCloseFloor()
				var cameraPos = new mono.Vec3();
				cameraPos.x = target.x + d * Math.sin(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
				cameraPos.z = target.z + d * Math.cos(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
				cameraPos.y = target.y + d * Math.sin(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
				camera.setPosition(cameraPos);
				camera.lookAt(target);
			},
			onStop: function() {
				self.setFloorRelationShipAndPosition(floor,buildingNode);
				self.doFadeOutAnimate(floor,floorNodes,endCallback);
				self.animates = [];//  2017-10-12
			}
		});
        this.animates.push(animate);
		animate.play();
	},

	/**
	 * 
	 */
	doFadeOutAnimate: function(floorNode,floorNodes,endCallback) {
		var self = this;
		var oldSortNodes = this.sceneManager.network3d.sortNodes;
		this.sceneManager.network3d.sortNodes = false;
		var animate = new mono.Animate({
			from: 0,
			to: 1,
			dur: 2000,
			onUpdate: function(value) {
				self.virFilter.opacityValue = 0.16 + (1-0.16) * value ; //
                self.virFilter.materialMap = {};
                self.sceneManager.network3d.dirtyNetwork();
			},
			onStop: function() {
				self.sceneManager.viewManager3d.removeMaterialFilter(self.virFilter);
				self.sceneManager.viewManager3d.enableDBLClick = true;
				// self.removeChildrenByFloorNode(floorNode);
				if (!floorNodes || floorNodes.length <= 1) {
					self.sceneManager.viewManager3d.setFocusNode(self.sceneManager.getCurrentRootNode());
				}
				self.animates = [];// 2017-10-12
				endCallback && endCallback();
				self.sceneManager.network3d.sortNodes = oldSortNodes;
			}
		});
		this.animates.push(animate);
		animate.play();
	},

	stopAllAnimate : function(){
		if (this.animates && this.animates.length > 0) {
			for(var i = 0 ; i < this.animates.length ; i++){
				var animate = this.animates[i];
				animate.stop();
			}
		}
		this.animates = [];
	},

	setFloorRelationShipAndPosition: function(floorNode, buildingNode) {
		if (!floorNode || !buildingNode) {
			return;
		}
		var fData = this.sceneManager.getNodeData(floorNode);
		var bData = this.sceneManager.getNodeData(buildingNode);
		var pos = new mono.Vec3();
		var rot = new mono.Vec3();
		if (fData.getPosition()) {
			pos.setY(fData.getPosition().y / 10 + 50); //+50
			pos.setX(fData.getPosition().x);
			pos.setZ(fData.getPosition().z);
		}
		this.sceneManager.computeRotation(fData,bData,floorNode,buildingNode);
		floorNode.setPosition(pos);
		// floorNode.setRotation(rot);
		floorNode.setParent(buildingNode);
	},

    /**
     * 
     * 
     *  floor01floor02dc
     */
	removeChildrenByFloorNode : function(floorNode){
		if (!floorNode) {
			return;
		}
		var floorData = this.sceneManager.getNodeData(floorNode);
		this.sceneManager.network3d.dataBox.removeByDescendant(floorNode);
		this.clearRelactionByParentData(floorData);
		this.sceneManager.network3d.dataBox.addByDescendant(floorNode);
		if (this.sceneManager.isClearCache) {
			this.sceneManager.clearCache();
		}
	},

	clearRelactionByParentData : function(parentData){
		if (!parentData) {
			return;
		}
		var children = parentData.getChildren();
		if (!children || children.size() < 1) {
			return ;
		}
		for(var i = 0 ; i < children.size() ; i++){
			var child = children.get(i);
			var childNode = this.sceneManager.getNodeByDataOrId(child);
			if (childNode) {
				childNode.setParent(null);
			}
			this.clearRelactionByParentData.call(this,child);
		}
	},

	getBuildingNodeByFloor : function(floor){
		if (!floor) {
			return null;
		}
		var fData = this.sceneManager.getNodeData(floor);
		var parentId = fData.getParentId();
		var pCategory = this.sceneManager.dataManager.getCategoryForData(parentId);
		if (pCategory && pCategory.getId().toLowerCase() == 'building') {
			return this.sceneManager.getNodeByDataOrId(parentId);
		}
		return null;
	},

	getFloorsByBuildingNode: function(buildingNode) {
		var bData = this.sceneManager.getNodeData(buildingNode);
		var children = bData.getChildren();
		var floors = [];
		for (var i = 0; i < children.size(); i++) {
			var child = children.get(i);
			var childCategory = this.sceneManager.dataManager.getCategoryForData(child);
			if (childCategory &&
				childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
				var floorNode = this.sceneManager.dataNodeMap[child.getId()];
			    floors.push(floorNode);
			}
		}
		return floors;
	},

	getEndingFloorsByFloors : function(floorNodes,buildingNode,currentloor){
		if (!floorNodes) {
			return null;
		}
		var cloneFloors = [];
		for (var i = 0; i < floorNodes.length; i++) {
			var fn = floorNodes[i];
			var cfn = fn.clonePrefab();
			if (fn == currentloor) {
				var scale = this.getFloorScaleInDc(currentloor,buildingNode);
				if(scale){
					cfn.setScale(scale);
				}
				var fnPos = fn.p().clone();
				fnPos.setY(fnPos.y/10);
				cfn.setPosition(buildingNode.p().clone().add(fnPos));//floor
			}else{
				cfn.setPosition(fn.getWorldPosition());
			}
			cloneFloors.push(cfn);
		}
		return cloneFloors;
	},
    
    /**
     * floordc
     * y10
     * x,z0000
     */
	getFloorPositionInDc: function(floor,buildingNode) {
		if (!floor || !buildingNode) {
			return null;
		}
		var fData = this.sceneManager.getNodeData(floor);
		if (buildingNode) {
			var pos = buildingNode.getWorldPosition().clone();
			if (fData.getPosition() && fData.getPosition().y) {
				pos.setY(pos.y+fData.getPosition().y/10 +  50); //+50
				pos.setX(pos.x+fData.getPosition().x);
				pos.setZ(pos.z+fData.getPosition().z);
			}
			return pos;
		}
		return null;
	},

    /**
     * floordc
     */
	getFloorRotationInDc: function(floor,buildingNode) {
		if (!floor || !buildingNode) {
			return null;
		}
		var rotation = new mono.Vec3();
		if (floor) {
			rotation = floor.getRotation().clone();
		}
		var bRot = buildingNode.getRotation().clone();
		if (bRot) {
			rotation = rotation.add(bRot);
		}
		return rotation;
	},

	getFloorScaleInDc: function(floor, buildingNode) {
		if (!floor || !buildingNode) {
			return null;
		}
		var bData = this.sceneManager.getNodeData(buildingNode);
		var bSacle = buildingNode.getScale();
		// var buildingBoundingBox = buildingNode.getBoundingBox();
		var buildingBoundingBox = it.Util.getBoundingBox(buildingNode);
		var children = bData.getChildren();
		var minScaleX = 10,
			minScaleZ = 10; // floor,floor
		for (var i = 0; i < children.size(); i++) {
			var child = children.get(i);
			var childCategory = this.sceneManager.dataManager.getCategoryForData(child);
			if (childCategory &&
				childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
				var floorNode = this.sceneManager.dataNodeMap[child.getId()];
				if (floorNode) {
					if (!floorNode.orgScale) {
						floorNode.orgScale = floorNode.getScale().clone();
					}
					if (!floorNode.orgPosY) {
						floorNode.orgPosY = floorNode.getPositionY();
					}
					var floorNodeBoundingBox = floorNode.getBoundingBox();
					if (buildingBoundingBox && floorNodeBoundingBox) {
						var bbSize = buildingBoundingBox.size();
						var fSize = floorNodeBoundingBox.size();
						var scaleX = 0.1,
							scaleZ = 0.1;
						if (bbSize && fSize) {
							if (bbSize.x != -Infinity && bbSize.x != Infinity && fSize.x != -Infinity && fSize.x != Infinity) {
								scaleX = bbSize.x / fSize.x;
							}
							if (bbSize.z != -Infinity && bbSize.z != Infinity && fSize.z != -Infinity && fSize.z != Infinity) {
								scaleZ = bbSize.z / fSize.z;
							}
						}
						if (scaleX < minScaleX) {
							minScaleX = scaleX;
						}
						if (scaleZ < minScaleZ) {
							minScaleZ = scaleZ;
						}
					}
				}
			}
		}
		// return new mono.Vec3(minScaleX * bSacle.x, 0.1, minScaleZ * bSacle.z);
		var scale = minScaleX>minScaleZ ? minScaleZ : minScaleX;
		return new mono.Vec3(scale * bSacle.x, scale>0.1?scale:0.1, scale * bSacle.z);
	}
});

/**
 * 
 * 
 *
 * 
 *   1
 *        1
 *        2
 *   2
 */
$BaseFocuseChangeAdapeter = function(sceneManager){
	this.sceneManager = sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	this.box = this.sceneManager.network3d.getDataBox();
};

mono.extend($BaseFocuseChangeAdapeter,Object,{

 //    //bug 2016-11-21 dc-building(),dc
 //    /*add  by Kevin 2016-12-01
 //    
 //       complexNodeAndSimpleNodeChangeAdaptercomplexNodesimpleNode
 //       ,realToFake  fakeToReal
 //     realToFakefakeToRealfocusNodeChangeBaseFocuseChangeAdapeter,
 //          BaseFocuseChangeAdapeternodeoldNode(:,box)
 //          
 //          (PropertyChangeAdaperManager)
 //    */
	// focusChange: function(event) {
	// 	var self = this;
	// 	if (event && event.property == "focusNode") {
	// 		var oldNode = event.oldValue;
	// 		var node = event.newValue;
	// 		if (oldNode) {
	// 			var simpleNode = oldNode.getClient('simpleNode');
	// 			//   ,(lookAt  lookAt)
	// 			if (simpleNode && simpleNode.getParent() != oldNode && !self.isChild(oldNode, node)) {
	// 				self.realToFake(oldNode, node);
	// 			}
	// 		}

	// 		if (node) {
	// 			var complexNode = node.getClient('complexNode');
	// 			if (complexNode && complexNode.getParent() != node) { //    
	// 				var simpleNode = node.getClient('simpleNode');
	// 				self.fakeToReal(oldNode, node);
	// 			}
	// 		}

	// 		self.focusNodeChange(oldNode, node);
	// 	}
	// },

	// isChild : function(parentNode,childNode,scope){
	// 	scope = scope || this;
 //        if(!parentNode || !childNode){
 //            return false;
 //        }
 //        var pdata = parentNode;
 //        if (parentNode instanceof mono.Element) {
 //        	pdata = scope.sceneManager.getNodeData(parentNode);
 //        }
 //        if(!pdata) {
 //            return false;
 //        }
 //        var cdata = childNode;
 //        if (childNode instanceof mono.Element) {
 //        	cdata = scope.sceneManager.getNodeData(childNode);
 //        }
 //        if(!cdata || !(cdata instanceof $Data)){
 //            return false;
 //        }
 //        var pDataScene = scope.sceneManager.getSceneFromData(pdata);
 //        var cDataScene = scope.sceneManager.getSceneFromData(cdata);
 //        if ((!pDataScene && cDataScene) 
 //        	|| (pDataScene && !cDataScene)
 //        	|| (pDataScene != cDataScene)) {
 //        	return false;
 //        }
 //        if(cdata.getParentId() && cdata.getParentId() === pdata.getId()){
 //            return true;
 //        }else{
 //        	var cdataParent = scope.sceneManager.dataManager.getDataById(cdata.getParentId());
 //        	return scope.isChild(pdata,cdataParent,scope);
 //        }
 //        // return false;
 //    },
    
    /**
     * /[""]
     */
    realToFake :function(oldNode,node){

    },

    /**
     * (/)
     */
    fakeToReal : function(oldNode,node){

    },

    /**
     * 
     */
    focusNodeChange :function(oldNode,node){

    },

    startInit : function(){

    },

    destroy : function(){

    }


});

it.BaseFocuseChangeAdapeter = $BaseFocuseChangeAdapeter;



/**
 * 
 *   ()
 * add 2017-07-14:building
 *   buildingdcdcbuilding
 *   dc
 *   lookAtgrant
 *      fakeToRealparent()
 *   AdapterManager
 */
$ComplexNodeAndSimpleNodeChangeAdapter = function(sceneManager){
	$BaseFocuseChangeAdapeter.call(this,sceneManager);
};

mono.extend($ComplexNodeAndSimpleNodeChangeAdapter,$BaseFocuseChangeAdapeter,{
	/**
     * 
     * oldlinklink:oldNode(link)node
     */
	realToFake: function(oldNode, node) {
		if (!oldNode) { //
			return null;
		}
		var self = this;
		var complexNode = oldNode.getClient('complexNode');
		var simpleNode = oldNode.getClient('simpleNode');
		var data = this.sceneManager.getNodeData(oldNode);
		complexNode.setParent(null);
		simpleNode.setParent(oldNode);
		if (this.box.getDataById(oldNode.getId())) { //clear,dc
			var fromNode = null,toNode = null;
			var nodeData = this.sceneManager.getNodeData(node);
			if (nodeData && nodeData instanceof it.Link) {
				fromNode = this.sceneManager.getNodeByDataOrId(nodeData.getFromId());
				toNode =  this.sceneManager.getNodeByDataOrId(nodeData.getToId());
			}
			// filter
			this.box.removeByDescendant(oldNode, false, function(child) {
				var childData = self.sceneManager.getNodeData(child);
				var childType = self.dataManager.getDataTypeForData(childData);
				if (childType && !childType.isLazyable()) {
					return false;
				}
				if (fromNode && (fromNode == child || child.getParent() == fromNode)) { //
					return false;
				}
				if (toNode && (toNode == child || child.getParent() == toNode)) {
					return false;
				}
				if (childData && data && childData.getParentId && childData.getParentId() === data.getId()) {
					return true;
				}
				return false;
			});
			this.box.removeByDescendant(complexNode);
			this.box.addByDescendant(simpleNode, function(node) {
				return true;
			});
			this.sceneManager._sceneManagerChangeDispatcher.fire({
				kind: 'change',
				data: oldNode
			});
		}
		// 
		this.sceneManager.viewManager3d.getDefaultEventHandler().closeDoor(complexNode);
	},

    /**
     * 
     */
	fakeToReal: function(oldNode, node) {
		if (!node) {
			return;
		}
		var simpleNode = node.getClient('simpleNode');
		var complexNode = node.getClient('complexNode');
		simpleNode.setParent(null);
		complexNode.setParent(node);
		this.box.addByDescendant(complexNode, function(node) {
			return true;
		});
		this.box.removeByDescendant(simpleNode);
		this.sceneManager._sceneManagerChangeDispatcher.fire({
			kind: 'change',
			data: node
		});
	},
	
	/**
	 * rackrackrack
	 */
	getRackByData: function(curData){
		if(!curData) return null;
		var curDataId = this.sceneManager.dataManager.getCategoryForData(curData).getId();
		if(curDataId == 'rack'){
			return curData;
		}else{
			if(curDataId == 'earth'){
				return null;
			}
			curData = this.sceneManager.dataManager.getParent(curData);
			return this.getRackByData(curData);
		}
	},
	/*
	* nodecardnode
	*/
	clearNodeState: function(node){
		if(!node) return;
		//card
		if(this.sceneManager.viewManager3d.getDefaultEventHandler().isPlayAnimate(node)){
			if(node.getClient('animation') && (node.getClient('animated') === true)){
				make.Default.playAnimation(node,node.getClient('animation'),null);
			}   
		}
	},


	/*	
	*	rack
    *	
	*	rackoldNode
	*   -- add Yaphets 2017-11-23
	*/
	focusNodeChange: function (oldNode, node) {
		if (!oldNode) {
			return;
		}
		var oldData = this.sceneManager.getNodeData(oldNode),
		oldDataCategory = this.sceneManager.dataManager.getCategoryForData(oldData),
		oldCategoryId = oldDataCategory.getId(),
		data = this.sceneManager.getNodeData(node),
		oldRackData = this.getRackByData(oldData),
		newRackData = this.getRackByData(data);
		if (oldDataCategory && oldCategoryId != 'rack' && oldRackData && !newRackData) {
			var oldParentData = this.sceneManager.dataManager.getDataById(oldData.getParentId());
			if (oldParentData && data != oldParentData &&
				(!data.getParentId //link
					||
					data.getParentId() != oldParentData.getId())) { //focusparent

				oldRackNode = this.sceneManager.getNodeByDataOrId(oldRackData);
				this.clearNodeState(oldNode);
				this.realToFake(oldRackNode);                   
			}
		}
	},

    
});
  /**
   * buidlingfloordatacenterScene
   * buildingbuilding
   */
  var $BuidingAndFloorChangeAdapter = function(sceneManager) {
    it.BaseFocuseChangeAdapeter.call(this, sceneManager);
    this.isMoveCameraBeforeLaunchFloor = true; //buildingfalse
    this.animates = [];
    this.init();
  };

mono.extend($BuidingAndFloorChangeAdapter,it.BaseFocuseChangeAdapeter,{
	
    init: function() {
       // this.sceneManager.switchToRealNode = this.switchToRealNode;
       var self = this;
       this.f2BHandle = new $FloorToBuildingHandle(this); //
       this.b2fHandle = new $BuildingToFloorHandle(this);

       this.sceneChangeListener = function(eve) {
          self.bindingBuildingAndFloor(eve.data,eve.rootData,eve.oldData,eve.oldRootData);
       };
       this.sceneManager.addSceneChangeListener(this.sceneChangeListener,this);

       // floorbuidingfloor-building1floor-dc2dcbuilding
       // tree
       this.orgChangeAnimate = this.sceneManager.cameraManager.beforePlaySceneChangeAnimate;
       this.newChangeAnimate = function(scene, rootData,oldScene,oldRootData){
           var oldCategory = self.dataManager.getCategoryForData(oldRootData);
           var category = self.dataManager.getCategoryForData(rootData);
           if (oldCategory && category 
               && oldCategory.getId().toLowerCase() ==='floor' 
               && category.getId().toLowerCase() === 'datacenter') {
               return false;
           }
           return self.orgChangeAnimate.call(self.sceneManager.cameraManager,scene, rootData,oldScene,oldRootData);
       }

       this.bindingBuildingAndFloorVisibleManager = new it.VisibleManager(this.sceneManager);
       this.sceneManager.viewManager3d.addVisibleFilter(this.bindingBuildingAndFloorVisibleManager);

       var defaultHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
       this.oldlookAtFun = defaultHandler.lookAt;
       this.newLookAtfun = function(node, callback){
           var data = self.sceneManager.getNodeData(node);
           var category = self.sceneManager.dataManager.getCategoryForData(data);
           if (category && category.getId() == 'building') {
              var mainNode = self.sceneManager.getNodeByDataOrId(data);
              self.sceneManager.viewManager3d.setFocusNode(mainNode);
              defaultHandler.afterLookAt(mainNode,node);
              callback && callback();
              return ;
           }else{
              self.oldlookAtFun.call(defaultHandler,node,callback);
           }
       }

    this.oldGotoScene = this.sceneManager.gotoScene;
    this.newGotoScene = function(scene, data, callback) {
        var currentScene = self.sceneManager.getCurrentScene();
        var currentRootData = self.sceneManager.getNodeData(self.sceneManager.getCurrentRootNode());
        var dataNode = self.sceneManager.getNodeByDataOrId(data);
        var oldFocusNode = self.sceneManager.viewManager3d.getFocusNode();
        var oldFocusData = self.sceneManager.getNodeData(oldFocusNode);
        if (oldFocusData 
            && oldFocusData.getId() == data.getParentId() //focuse(tree)
            // lookAtByDatab2f
            // lookAtByDataself.sceneManager.resetCameraWhenSceneChangefalse
            // lookAtByData oldScenefalse  2017-12-12 add by lyz
            && self.sceneManager.resetCameraWhenSceneChange
            && dataNode && dataNode.doubliClick) {
           dataNode.doubliClick(dataNode, self.sceneManager.network3d, data, null, callback);
           return;
        }
        if (currentScene 
             && currentScene.getId() == 'floor' 
             && scene 
             && scene.getId().toLowerCase() == 'datacenter') {
            self.f2BHandle.doFloorToDatacenter(scene, data, currentScene, currentRootData, callback);
        } else {
            self.oldGotoScene.call(self.sceneManager, scene, data, callback);
        }
     }

       var defaultMF = this.sceneManager.viewManager3d.defaultMaterialFilter;
       this.oldGetOpacityValue = defaultMF.getOpacityValue;
       this.newGetOpacityValue = function(data){
          if (self.sceneManager.getCurrentScene() 
            && self.sceneManager.getCurrentScene().getCategoryId()
            && self.sceneManager.getCurrentScene().getCategoryId().toLowerCase() == 'datacenter') {
              return 0.01;
          }
          return self.oldGetOpacityValue.call(defaultMF,data);
       } 

    },

    startInit : function(){
        if (this.bindingBuildingAndFloorVisibleManager) {
            this.sceneManager.viewManager3d.addVisibleFilter(this.bindingBuildingAndFloorVisibleManager);
        }
        if (this.sceneChangeListener) {
          this.sceneManager.removeSceneChangeListener(this.sceneChangeListener,this); //
          this.sceneManager.addSceneChangeListener(this.sceneChangeListener,this);
        }
        this.sceneManager.viewManager3d.getDefaultEventHandler().lookAt = this.newLookAtfun;
        this.sceneManager.gotoScene  = this.newGotoScene;
        this.sceneManager.cameraManager.beforePlaySceneChangeAnimate = this.newChangeAnimate;
        this.sceneManager.viewManager3d.defaultMaterialFilter.getOpacityValue = this.newGetOpacityValue;
    },

    destroy : function(){
       if (this.bindingBuildingAndFloorVisibleManager) {
            this.bindingBuildingAndFloorVisibleManager.clear();
            this.sceneManager.viewManager3d.removeVisibleFilter(this.bindingBuildingAndFloorVisibleManager);
        }
        if (this.sceneChangeListener) {
           this.sceneManager.removeSceneChangeListener(this.sceneChangeListener,this);
        }
        this.sceneManager.viewManager3d.getDefaultEventHandler().lookAt = this.oldlookAtFun;
        this.sceneManager.gotoScene = this.oldGotoScene;
        this.sceneManager.cameraManager.beforePlaySceneChangeAnimate = this.orgChangeAnimate;
        this.sceneManager.viewManager3d.defaultMaterialFilter.getOpacityValue = this.oldGetOpacityValue;
    },

    stopAllAnimate : function(){
        if (this.animates && this.animates.length > 0) {
          for(var i = 0 ; i < this.animates.length > 0 ; i++){
             var animate = this.animates[i];
            animate.stop();
          }
        }
        this.animates = [];
    },

	  /**
     * (setFocus)1
     * 2-
     *
     * building(building)
     * floor(focus)
     *
     * building  floors
     * floors  building
     *
     * @param node
     * @param oldNode
     */
    // switchToRealNode : function(node,oldNode){
     focusNodeChange: function(oldNode, node) {
        if(!node){
            return;
        }
        var sceneMap = this.dataManager._sceneMap;
        for (var sId in sceneMap) {
           var sceneObj = sceneMap[sId];
           if(sceneObj && sceneObj.getCategoryId() && sceneObj.getCategoryId().toLowerCase().indexOf('building')>=0){
              return ;
           }
        };
        var self = this;
        var data = this.sceneManager.getNodeData(node);
        var category = this.dataManager.getCategoryForData(data);
        var oldData =  oldNode?this.sceneManager.getNodeData(oldNode):null;
        var oldCategory = this.dataManager.getCategoryForData(oldData);
        // 2017-05-02 Kevin
        if(category && category.getId().toLowerCase().indexOf('datacenter') >=0
          && oldCategory && oldCategory.getId() == 'floor'){ //dc-floorgotoUpLevelSceneFor3DafterGotoUpLevelScene
           return;
        }
        // var box = this.network3d.getDataBox();
        // lookAtbuilding
        // floorsbuildingbuildingbuidlingbuilding
        // oldNodebuilding
       if (category 
            && category.getId() 
            && category.getId().toLowerCase().indexOf('building') >= 0 
            && oldCategory 
            && oldCategory.getId()
            && oldCategory.getId().toLowerCase().indexOf('building') >= 0) { // building - building
            var oldDataChildren = oldData.getChildren();
            if(oldDataChildren && oldDataChildren.size() > 0) {
                for (var i = 0; i < oldDataChildren.size(); i++) {
                    var child = oldDataChildren.get(i);
                    var childCategory = this.dataManager.getCategoryForData(child);
                    if (childCategory &&
                        childCategory.getId()
                       && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
                           var floorNode = self.sceneManager.dataNodeMap[child.getId()];
                           if (floorNode && self.box.getDataById(floorNode.getId())) {
                                self.box.removeByDescendant(floorNode);
                                 //add 2017-07-06 Kevin focusfilterscenechangeremove
                                // self.bindingBuildingAndFloorVisibleManager.setVisible(child, false); 
                                 self.bindingBuildingAndFloorVisibleManager.setVisibleByDescendant(child, false); // 2017-07-19
                          }
                    }
                }
            }
            this.switchToBuilding(node,oldNode,this.switchToBuildingFinished);
        }else if(category 
           && category.getId() 
           && category.getId().toLowerCase().indexOf('building') >= 0){ // dc-building or floor-building(floorbuilding)
            if (oldCategory 
            && oldCategory.getId() == 'floor') { // floor-buildingFloorToBuildingHandle
               return;
            }
            this.switchToBuilding(node,oldNode,this.switchToBuildingFinished);
        }
        // else if(oldNode){ //clickBackground
           // 1building-dc2building-DC(floor)
           // 1
            // var oldData =  this.getNodeData(oldNode);
            // var oldCategory = this.dataManager.getCategoryForData(oldData);
       else if(oldCategory 
                && oldCategory.getId()
                && oldCategory.getId().toLowerCase().indexOf('building') >= 0
                ){  // building-dc,or other
                var children = oldData.getChildren();
                if(children && children.size() > 0) {
                  var floorNodes = [];
                    for (var i = 0; i < children.size(); i++) {
                        var child = children.get(i);
                        var childCategory = this.dataManager.getCategoryForData(child);
                        if (childCategory &&
                            childCategory.getId()
                            && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
                              var floorNode = this.sceneManager.dataNodeMap[child.getId()];
                              floorNodes.push(floorNode);
                        }
                    }
                   var callback = function(){ // building
                        for(var j = 0 ; j < floorNodes.length; j++){
                            var floorNode = floorNodes[j];
                            var child =self.sceneManager.getNodeData(floorNode);
                            if (data != child //building
                                && floorNode
                                && self.box.getDataById(floorNode.getId())) {
                                self.box.removeByDescendant(floorNode);
                              //add 2017-07-06 Kevin focusfilterscenechangeremove
                                self.bindingBuildingAndFloorVisibleManager.setVisible(child, false); 
                            }
                        }
                    };
                    if(category && category.getId().toLowerCase().indexOf('datacenter') >= 0){ // dc
                        this.hideFloorAnimate(floorNodes,oldNode,callback);
                        // this.sceneManager.viewManager3d.defaultMaterialFilter.clearAll(); //clearAll
                    }else{
                        callback();
                        this.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(oldData);
                    }
                    // this.sceneManager.viewManager3d.defaultMaterialFilter.clearAll(); //clearAll
                }
        }
    },

	 /**
     * buildingfloor"":
     * buildingfloors(earth)floorsbuildingdc
     * dcfloors
    */
    bindingBuildingAndFloor : function(scene,rootData,oldScene,oldRootData){
      this.stopAllAnimate();
        var floors = this.dataManager._categoryDatas['floor']; //floorfloor
        // urlparentScenedatanull
        if (scene 
          && scene.getCategoryId() 
          && scene.getCategoryId().toLowerCase() == 'datacenter') {
              if (floors) {
                for (var id in floors) {
                    var floor = floors[id];
                    //floorFloorToBuildingHandle,buildingfloor
                    // Add 2017-07-10 dc
                    if (!oldRootData  //url
                        || (floor 
                            && floor != oldRootData 
                            && floor.getParentId() != oldRootData.getParentId())) { 
                        // this.bindingBuildingAndFloorVisibleManager.setVisible(floor, false); 
                        this.bindingBuildingAndFloorVisibleManager.setVisibleByDescendant(floor,false);
                    }
                }
              }
        } else {
            this.bindingBuildingAndFloorVisibleManager.clear();
            // floorscale
            if (floors) {
                for (var id in floors) {
                    var floor = floors[id];
                    var floorNode = this.sceneManager.getNodeByDataOrId(floor);
                    if (floorNode){
                        if( floorNode.orgScale) {
                            floorNode.setScale(floorNode.orgScale.clone());
                            if(floorNode == this.sceneManager._currentRootNode){
                              if (this.afterLoadFloor) {
                                  this.afterLoadFloor(floorNode);
                              }
                            }
                        }
                        if(floorNode.orgPosY){ //stop
                            floorNode.setPositionY(floorNode.orgPosY);
                            // delete floorNode.doubliClick; // 
                        }
                    }
                }
            }
        }
    },

  /**
   * dcbuilding
   * 
   * floor(oldNodefloor)buildingfloor
  */
  showFloorAnimate: function(floors, buildingNode, oldNode,finishedCallback,afterLookAtCallback) {
    if (!floors && floors.length < 1) {
      return;
    }
    var self = this;
    var data = this.sceneManager.getNodeData(buildingNode);
    var defaultHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
    var oldFocusData = this.sceneManager.getNodeData(oldNode);
    var oldSceneAndRoot = null;
    if (oldFocusData) {
      oldSceneAndRoot = this.sceneManager.getSceneAndRootByData(oldFocusData);
    }
    if (oldSceneAndRoot && oldSceneAndRoot.scene 
        && oldSceneAndRoot.scene.getCategoryId().toLowerCase().indexOf('floor') >= 0) { //floorbuilding
      /*
        FloorToBuildingHandle.js
      */
    } else {
      // defaultHandler.lookAtWithOutMoveCamera = false;
    var moveUpFloorsAnimate = new mono.Animate({
        from: 0,
        to: 1,
        dur: 1000,
        // delay: 1000,
         delay: 0,
        easing: 'elasticOut',
        onUpdate: function(value) {
          // floor.setY(value);
          for (var i = floors.length - 1; i >= 0; i--) {
            var floor = floors[i];
            var data = self.sceneManager.getNodeData(floor);
            var y = parseFloat(data.getPosition().y / 10);
            floor.setY(y + 50 * value);
          }
        },
        onStop:function(){
           if (self.animates && self.animates.length > 0) {
              self.animates = []; // --2017-10-10
           }
           finishedCallback && finishedCallback(buildingNode);
        }
      });

      var callback1 = function() {
        afterLookAtCallback && afterLookAtCallback();
        if (!self.sceneChangeWithOutAnimate) {
           // self.moveUpFloorsAnimate.play();
           moveUpFloorsAnimate.play();
        } else {
          for (var i = floors.length - 1; i >= 0; i--) {
            var floor = floors[i];
            var data = self.sceneManager.getNodeData(floor);
            var y = parseFloat(data.getPosition().y / 10);
            floor.setY(y + 50);
          }
        }
      };
      this.animates.push(moveUpFloorsAnimate);
      //defaultHandler.moveToClickNode(buildingNode,callback,200);
       // defaultHandler.moveCameraForLookAtNode(buildingNode,callback1);
       if (floors && floors.length > 1) { // update 2016-11-01 Kevin
           if(this.isMoveCameraBeforeLaunchFloor){
              defaultHandler.moveCameraForLookAtNodes(floors,callback1,30);
              this.sceneManager.viewManager3d.clearVisibleMap();
           }else{
              setTimeout(function(){
                  callback1();
              },100);
           }
       }else{
           defaultHandler.moveCameraForLookAtNode(buildingNode,callback1);
       }
    }
  },

    /**
      * floors
      *
      * setFocusNode
    */
    hideFloorAnimate : function(floors,buildingNode,callback){
        if (!floors && floors.length < 1) {
            if(callback){
                callback();
            }
            return;
        }
        if(this.doubliClickFloorNodeAnimate){
          this.doubliClickFloorNodeAnimate.stop();
        }
        // this.viewManager3d.getDefaultEventHandler().withOutAnimate = true;
        this.sceneManager.viewManager3d.getDefaultEventHandler().lookAtWithOutMoveCamera = false;
        var buildingData = this.sceneManager.getNodeData(buildingNode);
        if (buildingData) {
            // buildingNode.setStyle('m.transparent', true);
            // buildingNode.setStyle('m.opacity', 0.06);
            this.sceneManager.viewManager3d.defaultMaterialFilter.add(buildingData);
            this.sceneManager.network3d.dirtyNetwork();
        }
        var self = this;
        var moveDownFloorsAnimate = new mono.Animate({
            from: 0,
            to: 1,
            dur: 1000,
            // delay: 1000,
            easing: 'easeOut',
            onUpdate: function (value) {
                // floor.setY(value);
                for (var i = floors.length - 1; i >= 0; i--) {
                    var floor = floors[i];
                    var data = self.sceneManager.getNodeData(floor);
                    if (!data) {
                       return; // 2017-10-11
                    }
                    var y = parseFloat(data.getPosition().y/10) + 50;
                    // var y = parseFloat(floor.getPositionY());
                    floor.setY(y - 50 * value);
                }
            },
            onStop : function(){ //stop
              if(callback){
                    callback();
                }
                self.sceneManager.viewManager3d.defaultMaterialFilter.clearAll();
                self.sceneManager.network3d.dirtyNetwork();
                // var index = self.animates.indexOf(moveDownFloorsAnimate);
                // if(index !== -1){
                //    self.animates.splice(index,1);
                // }
                if (self.animates && self.animates.length > 0) {
                   self.animates = []; // --2017-10-12
                }
            }
        });
        this.animates.push(moveDownFloorsAnimate);
        moveDownFloorsAnimate.play();
    },

    /**
     * buildingfloorfloorscale
     */
  getFloorScaleByBuildingNodeAndFloorNode: function(buildingNode, floorNode) {
    if (!buildingNode || !floorNode) {
       return null;
    }
     // var minScaleX = 10,
     //    minScaleZ = 10; // floor
    // var buildingBoundingBox = buildingNode.getBoundingBox();
    var buildingBoundingBox = it.Util.getBoundingBox(buildingNode);
    // var floorNodeBoundingBox = floorNode.getBoundingBox();
    var floorNodeBoundingBox = it.Util.getBoundingBox(floorNode);
    var scaleX = 0.1,
        scaleZ = 0.1;
    if (buildingBoundingBox && floorNodeBoundingBox) {
      var bbSize = buildingBoundingBox.size();
      var fSize = floorNodeBoundingBox.size();
      // var scaleX = 0.1,
      //     scaleZ = 0.1; // 0.1,1000
      if (bbSize && fSize) {
        if (bbSize.x && bbSize.x != -Infinity && bbSize.x != Infinity && fSize.x != -Infinity && fSize.x != Infinity) {
          scaleX = bbSize.x / fSize.x;
        }
        if (bbSize.z && bbSize.z != -Infinity && bbSize.z != Infinity && fSize.z != -Infinity && fSize.z != Infinity) {
          scaleZ = bbSize.z / fSize.z;
        }
      }
      // if (scaleX < minScaleX) {
      //   minScaleX = scaleX;
      // }
      // if (scaleZ < minScaleZ) {
      //   minScaleZ = scaleZ;
      // }
    }
    var scale = scaleX > scaleZ ? scaleZ:scaleX;
    return new mono.Vec3(scale, 1, scale);
  },

  /**
   * building
   */
  isIntoFloor : function(){
    return true;
  },
  
  /**
   * 
   */
  shouldDoubliClickFloorNode : function(data){
    return true;
  },

  /**
   * building
   * 1lookAt Building
   * 2building
   * 3building
   * 4buildingbuildingfloor
   */
  switchToBuilding: function(node, oldNode, callback) {
    if (!node) return;
    var data = this.sceneManager.getNodeData(node);
    if (!data) return;
    // var buildingBoundingBox = node.getBoundingBox();
    // var buildingBoundingBox = it.Util.getBoundingBox(node);
    var wPos = node.getWorldPosition();
    var bSacle = node.getScale();
    var children = data.getChildren();
    if (!children || children.size() < 1) {
      return;
    }
    var self = this;
    var floorNodes = [];
    var minScaleZ = 1;
    var minScaleX = 1;
    if (children && children.size() > 0) {
      for (var i = 0; i < children.size(); i++) {
        var child = children.get(i);
        var childCategory = this.sceneManager.dataManager.getCategoryForData(child);
        if (childCategory &&
          childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
          var floorNode = this.sceneManager.dataNodeMap[child.getId()];
          if (floorNode) {
            if (!floorNode.orgScale) {
              floorNode.orgScale = floorNode.getScale().clone();
            }
            if (!floorNode.orgPosY) {
              floorNode.orgPosY = floorNode.getPositionY();
            }
            var fMinScale = this.getFloorScaleByBuildingNodeAndFloorNode(node,floorNode)||new mono.Vec3(0.1,0.1,0.1);
            if(minScaleZ > fMinScale.z){
               minScaleZ = fMinScale.z;
            }
            if (minScaleX > fMinScale.x) {
               minScaleX = fMinScale.x;
            }
            floorNode.setPositionY(child.getPosition().y / 10);
            this.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(child);
            delete this.doubleClickFloorNodeFlag; //
            floorNode.doubliClick = function(element, network, data, clickedObj, callback) {
                // self.doubliClickFloorNode(element, network, data, clickedObj, callback);
                if(self.shouldDoubliClickFloorNode(data)){
                    self.b2fHandle.doubliClickFloorNode(element, network, data, clickedObj, callback);
                }
            }
            floorNodes.push(floorNode);
          }
        }
      }
      if(floorNodes.length  < 1){ //buildingfloor
         this.sceneManager.viewManager3d.defaultMaterialFilter.clear(); // building
         return ;
      }
      // building  update by Kevin 2017-07-04
      for (var i = floorNodes.length - 1; i >= 0; i--) {
          floorNodes[i].setScale(minScaleX * bSacle.x, Math.min(minScaleX * bSacle.x,minScaleZ * bSacle.z), minScaleZ * bSacle.z); //boundingboxbuildingboundingbox
      }

      /**
       * floor
       */
      var aftrLookAtCallback = function() {

        self.sceneManager.viewManager3d.defaultMaterialFilter.addByDescendant(data); //floor
        for (var i = 0; i < floorNodes.length; i++) {
           var fData = self.sceneManager.getNodeData(floorNodes[i]);
           self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(fData);
        }
        self.sceneManager.network3d.dirtyNetwork();

        if (self.bindingBuildingAndFloorVisibleManager && floorNodes.length > 0) {
            for(var i = 0 ; i < floorNodes.length ; i++){
               var floor = self.sceneManager.getNodeData(floorNodes[i]);
               // self.bindingBuildingAndFloorVisibleManager.setVisible(floor, true);
               self.bindingBuildingAndFloorVisibleManager.setVisibleByDescendant(floor, true); // update 2017-07-19 
            }
        }
       
        if(self.afterLookAtBuildingFunction){
           self.afterLookAtBuildingFunction(node,floorNodes);
        }

      }

      var endCallback = function(){
        callback && callback();
         if (floorNodes.length == 1 && self.isIntoFloor() && self.shouldDoubliClickFloorNode(fData)) { //
            var fData = self.sceneManager.getNodeData(floorNodes[0]);
            self.b2fHandle.doubliClickFloorNode(floorNodes[0], self.sceneManager.network3d, fData, null, null);
        }
      }

      this.sceneManager.viewManager3d.defaultMaterialFilter.clear(); // building
      this.showFloorAnimate(floorNodes, node, oldNode,endCallback, aftrLookAtCallback);
    }
  }

});

it.BuidingAndFloorChangeAdapter = $BuidingAndFloorChangeAdapter;





/**
 * sceneManger
 * sceneManager
 *
 */
$PropertyChangeAdaperManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.changeAdapterList = new mono.List();
	this.defaultFocuseAdaper = new $ComplexNodeAndSimpleNodeChangeAdapter(sceneManager);//
	this.buildAndFloorAdaper = new $BuidingAndFloorChangeAdapter(sceneManager);
	this.init();
};

mono.extend($PropertyChangeAdaperManager,Object,{

	init: function() {
		var self = this;
		this.sceneManager.viewManager3d.addPropertyChangeListener(function(event) {
			// if(event.property == "focusNode"){
			// }
			var currentScene = self.sceneManager.getCurrentScene();
			if (event 
				&& event.property == "focusNode" 
				&& (!currentScene || currentScene.getId() != 'earth')) { // earth  billboardloadChildren
				var node = event.newValue;
				if (node) {
					self.sceneManager.loadLazyChildren(node); // : lookAt  ,lookAt
					// viewManagefocusNode--2017-09-27 
					// if (self.sceneManager.viewManager3d.defaultMaterialFilter) {
					// 	self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(self.sceneManager.getNodeData(node));
					// }
					self.setRelationWithChildren(node); // 2018-01-19 Kevin 
				}
			}

			// for (var i = 0; i < self.changeAdapterList.size(); i++) {
			// 	var changeAdaper = self.changeAdapterList.get(i);
			// 	if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
			// 		changeAdaper.focusChange(event);
			// 	}
			// }
			self.focusChange(event);
		});
		this.register(this.defaultFocuseAdaper);
		this.register(this.buildAndFloorAdaper);
	},

	// -- add By Kevin 2016-12-01 focusChangeBaseFocuseChangeAdapeter:
	// /*add  by Kevin 2016-12-01
    // 
    //    complexNodeAndSimpleNodeChangeAdaptercomplexNodesimpleNode
    //    ,realToFake  fakeToReal
    //  realToFakefakeToRealfocusNodeChangeBaseFocuseChangeAdapeter,
    //       BaseFocuseChangeAdapeternodeoldNode(:,box)
    //       
    // */
	focusChange: function(event) {
		var self = this;
		if (event && event.property == "focusNode") {
			var oldNode = event.oldValue;
			var node = event.newValue;
			if (oldNode) {
				var simpleNode = oldNode.getClient('simpleNode');
				var complexNode = oldNode.getClient('complexNode');
				//   ,(lookAt  lookAt)
				// if (simpleNode && simpleNode.getParent() != oldNode && !self.isChild(oldNode, node)) {
			// add by Kevin 2011221simpleNodeparentcomplex
				if (simpleNode 
					&& ((complexNode 
						 && complexNode != 'unload' 
						 && complexNode.getParent() == oldNode)
						|| simpleNode.getParent() != oldNode) 
					&& !self.isChild(oldNode, node)) { 
					for (var i = 0; i < self.changeAdapterList.size(); i++) {
						var changeAdaper = self.changeAdapterList.get(i);
						if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
							changeAdaper.realToFake(oldNode, node);
						}
					}
					// self.realToFake(oldNode, node);
				}
			}

			if (node) {
				self.fakeToRealForParent(node); //
				var complexNode = node.getClient('complexNode');
				var simpleNode = node.getClient('simpleNode');
				var data = self.sceneManager.getNodeData(node);
				if (complexNode == 'unload') { //
					self.sceneManager.loadComplexNode(data,function(comNode){
						self._doFakeToReal(comNode,simpleNode,oldNode,node);
					});
				}else{
					/*
			    	if (complexNode && 
				        (complexNode.getParent() != node
				          || (simpleNode && simpleNode.getParent() == node))) { //    
				    	var simpleNode = node.getClient('simpleNode');
			    		for (var i = 0; i < self.changeAdapterList.size(); i++) {
			    			var changeAdaper = self.changeAdapterList.get(i);
				    		if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
				     			changeAdaper.fakeToReal(oldNode, node);
			    			}
		    			}
		    		}*/
		    		self._doFakeToReal(complexNode,simpleNode,oldNode,node);
				}
			}

			for (var i = 0; i < self.changeAdapterList.size(); i++) {
				var changeAdaper = self.changeAdapterList.get(i);
				if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
					changeAdaper.focusNodeChange(oldNode, node);
				}
			}
			// self.focusNodeChange(oldNode, node);
		}
	},
    
    /**
     * 
     * node
     */
	_doFakeToReal: function(complexNode,simpleNode,oldNode,node) {
		if (complexNode &&
			 (complexNode.getParent() != node 
			  || (simpleNode && simpleNode.getParent() == node))) { //    
			var simpleNode = node.getClient('simpleNode');
			for (var i = 0; i < this.changeAdapterList.size(); i++) {
				var changeAdaper = this.changeAdapterList.get(i);
				if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
					changeAdaper.fakeToReal(oldNode, node);
				}
			}
		}
	},

	/**
     * parent
     * add 2017-07-14
     */
	fakeToRealForParent : function(node){
		var nodeData = this.sceneManager.getNodeData(node);
		var self = this;
		if (nodeData && nodeData.getParentId && nodeData.getParentId()) { //
			var parent = this.sceneManager.dataManager.getDataById(nodeData.getParentId());
			if (parent && this.sceneManager.isCurrentSceneInstance(parent)) {
				var parentNode = this.sceneManager.getNodeByDataOrId(parent);
				if (!parentNode) {
					return;
				}
				this.fakeToRealForParent.call(this,parentNode);//
				var complexNode = parentNode.getClient('complexNode');
				var simpleNode = parentNode.getClient('simpleNode');
				if (complexNode == 'unload') { //
					self.sceneManager.loadComplexNode(parent,function(comNode){
						self._doFakeToReal(comNode,simpleNode,null,parentNode);
					});
				}else if(complexNode && complexNode.getParent() != parentNode){ //
		    		self._doFakeToReal(complexNode,simpleNode,null,parentNode);
				}	
			}
		}
	},

	isChild : function(parentNode,childNode,scope){
		scope = scope || this;
        if(!parentNode || !childNode){
            return false;
        }
        var pdata = parentNode;
        if (parentNode instanceof mono.Element) {
        	pdata = scope.sceneManager.getNodeData(parentNode);
        }
        if(!pdata) {
            return false;
        }
        var cdata = childNode;
        if (childNode instanceof mono.Element) {
        	cdata = scope.sceneManager.getNodeData(childNode);
        }
        if(!cdata || !(cdata instanceof $Data)){
            return false;
        }
        var pDataScene = scope.sceneManager.getSceneFromData(pdata);
        var cDataScene = scope.sceneManager.getSceneFromData(cdata);
        if ((!pDataScene && cDataScene) 
        	|| (pDataScene && !cDataScene)
        	|| (pDataScene != cDataScene)) {
        	return false;
        }
        if(cdata.getParentId() && cdata.getParentId() === pdata.getId()){
            return true;
        }else{
        	var cdataParent = scope.sceneManager.dataManager.getDataById(cdata.getParentId());
        	return scope.isChild(pdata,cdataParent,scope);
        }
        // return false;
    },

    /**
     * 2018-01-19 Kevin 
     * node
     * loadLazyChildrennodeloadScene
     * ITloadLazyDatalookAt()
     */
    setRelationWithChildren : function(node){
    	var data = this.sceneManager.getNodeData(node);
    	if (data) {
    		var children = data.getChildren();
    		if (children && children.size() > 0) {
    			for(var i = 0 ;i < children.size(); i++){
    				var child = children.get(i);
    				this.sceneManager.setParentRelationShip(child);
    			}
    		}
    	} 
    },

	register : function(changeAdaper){
		if (changeAdaper) {
			if (!this.changeAdapterList.contains(changeAdaper)) {
				changeAdaper.startInit();
				this.changeAdapterList.add(changeAdaper);
			}
		}
	},

	deregister : function(changeAdaper){ //listener
		if (changeAdaper) {
			if (this.changeAdapterList.contains(changeAdaper)) {
				this.changeAdapterList.remove(changeAdaper);
				changeAdaper.destroy();
			}
		}
	},


});

it.PropertyChangeAdaperManager = $PropertyChangeAdaperManager;



/**
 * fouse/
 * (oldFouseNodefouseNode)
 */
var $SpaceAdapter = function(sceneManager,spaceManager){
	it.BaseFocuseChangeAdapeter.call(this,sceneManager);
	this.spaceManager = spaceManager;
	this.box = this.sceneManager.network3d.getDataBox();
};

mono.extend($SpaceAdapter, it.BaseFocuseChangeAdapeter, {

	/**
	 * (/)()
	 * boxspaceNode(frame+cube)
	 * 1
	 * 2spaceNode()
	 * 3(cube)
	 * add 2017-11-18 oldNode
	 */
	realToFake: function(oldNode, node) {
		var self = this;
		var isSpaceNode = false,spaceNode = null;
		var children = oldNode.getChildren().toArray();
		var oldData = this.sceneManager.getNodeData(oldNode);
		for (j = 0; j < children.length; j++) {
			var child = children[j];
			if (this.spaceManager.isSpaceChildrenNode(child)) { // || this.isSpaceChildrenNode(child)
				this.box.removeByDescendant(child);
				child.setParent(null);
				isSpaceNode = true;
			}else{
				// 2017-11-10 ComplexNodeAndSimpleNodeChangeAdapter
				// 2017-11-18 
				var childData = this.sceneManager.getNodeData(child);
				var cCategory = this.sceneManager.dataManager.getCategoryForData(childData);
				// if (!cCategory 
				// 	|| cCategory.getId().toLowerCase().indexOf('rack') < 0) {
					// remark 2017-12-14 remove
				if (oldData != childData && (!cCategory 
					|| cCategory.getId().toLowerCase().indexOf('rack') < 0)) {
					this.box.removeByDescendant(child); 
				}
			}
			if(this.spaceManager.isSpaceNode(child)){
				spaceNode = child;
			}
		}
		if (isSpaceNode) {
			var complexNode = oldNode.getClient('complexNode'); 
			var simpleNode = oldNode.getClient('simpleNode');
			this.box.removeByDescendant(complexNode); //adpeter()
			this.box.removeByDescendant(simpleNode);
			if (spaceNode) { //isSpaceNodetruespaceNode
				this.box.addByDescendant(spaceNode);
			}
		}
	},

	/**
	 * (/)()
	 * 1spaceNode
	 * 2box
	 * 3box
	 */
	fakeToReal: function(oldNode, node) {
		var self = this;
		var data = this.sceneManager.getNodeData(node);
		if (!data) {
			return;
		}
		var isSpaceNode = false;
		var children = node.getChildren().toArray();
		for (j = 0; j < children.length; j++) {
			var child = children[j];
			if (this.spaceManager.isSpaceNode(child)) { // || this.isSpaceChildrenNode(child)
				// child.setParent(null); //box
				this.box.removeByDescendant(child);
				isSpaceNode = true;
			}
		}
		if (isSpaceNode) {
			var complexNode = node.getClient('complexNode'); 
			if(complexNode){
				this.box.addByDescendant(complexNode);
			}else{
				this.box.addByDescendant(node,function(child){
					if (self.spaceManager.isSpaceNode(child)) {
						return false;
					}else{
						return true;
					}
				});
			}
			var spaceChildrenNodes = this.spaceManager.create1DChildrenSpaceNodes(data);
			for (j = 0; j < spaceChildrenNodes.length; j++) { // update By Kevin 2016-11-30 lookAt()box
				spaceChildNode = spaceChildrenNodes[j];
				spaceChildNode.setParent(node);
				this.box.addByDescendant(spaceChildNode)
			}
		}
	},

});

it.SpaceAdapter = $SpaceAdapter;



it.PowerCapacityManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.visibleManager = new $VisibleManager(this.sceneManager);
    this.sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
};

mono.extend(it.PowerCapacityManager,Object,{
    computePowerPercent : function(dataOrId){
       var dm = this.dataManager;
       var data = dataOrId;
       if(!data.getId){
          data = dm.getDataById(dataOrId);
       }
       var datatype = dm.getDataTypeForData(data);
       if(!datatype){
         return;
       }
       var powerRating = datatype.getPowerRating();
       if(powerRating == null || powerRating == 0){
          return null;
       }
       
       var totalPower = 0,power;
       var childList = data.getChildren();
       childList.forEach(function(child){
           power = child.getPower() || 0;
           totalPower += power;
       });
       return totalPower / powerRating;
    },

    createPowerNode : function(dataOrId){

        var sm = this.sceneManager,dm = this.dataManager,data = dataOrId,
            box = sm.network3d.getDataBox();
        if(!sm.isCurrentSceneInstance(dataOrId)){
            return;
        }
        if(!data.getId){
            data = dm.getDataById(dataOrId);
        }
        var percent = this.computePowerPercent(dataOrId);
        if(percent == null){
            return;
        }
        var node = sm.getNodeByDataOrId(data);
        var boundingBox = node.getBoundingBox(),
            size = boundingBox.size(),
            width = size.x,height = size.y,depth = size.z;

        var powerNode = node.getClient('powerNode'),powerNode2;
        percent = percent || 0.01;
        if(!powerNode){
            powerNode = new mono.Cube(width-0.2,height ,depth-0.2);
            powerNode2 = new mono.Cube(width,height,depth);
            powerNode2.setParent(powerNode);
            powerNode.s({
                'm.type':'phong',
            });
            powerNode2.s({
                'm.wireframe':true,
                'm.wireframeLinewidth':1,
                'm.color':'white',
            });
            powerNode.setClient('child',powerNode2);
        }
        var color = this.getPowerNodeColor(percent);
         powerNode.s({
            'm.color':color,
            'm.ambient':color,
            'm.specularStrength':30,
        });
        powerNode.setParent(node);
        powerNode.setScale(1,percent,1);
        powerNode.setY(height * percent / 2  -  height / 2 + 5);
        powerNode.setClient('powerChildNode',true);
        node.setClient('powerNode',powerNode);
        powerNode.setClient('it_data','power');
        box.addByDescendant(powerNode);
        // this.makeItDataNodeUnvisible(node);
        this.makeItDataUnvisible(data);
        return powerNode;
    },

    // makeItDataNodeUnvisible : function(node){
    //     if(node.getClient('it_data')){
    //        if(node._oldvisible === undefined){
    //           node._oldvisible = node.getStyle('m.visible',false,false);
    //           node._oldvisible = node._oldvisible === false ? false: true;
    //        }
    //        node.setStyle('m.visible',false);
    //     }
    //     var self = this;
    //     node.getChildren().forEach(function(child){
    //         self.makeItDataNodeUnvisible(child);
    //     });
    // },

    makeItDataUnvisible : function(data){
        if (!data) {
          return;
        }
        this.visibleManager.setVisible(data,false);
        var self = this;
        data.getChildren().forEach(function(child){
            self.makeItDataUnvisible(child);
        });
    },

    makeItDataVisible : function(data){//node
      if (!data) {
         return;
      }
       this.visibleManager.setVisible(data,true);
      var self = this;
      data.getChildren().forEach(function(child){
          self.makeItDataVisible(child);
      });
    },

    removePowerNode : function(dataOrId){
        var sm = this.sceneManager,dm = this.dataManager,data = dataOrId,box = sm.network3d.getDataBox();
        if(!data.getId){
            data = dm.getDataById(dataOrId);
        }
        var node = sm.getNodeByDataOrId(dataOrId);
        if(!node){
            return;
        }
        var powerNode = node.getClient('powerNode');
        if(powerNode){
            powerNode.setParent(null);
            box.removeByDescendant(powerNode);
            // this.makeItDataNodeVisible(node);
        }
         this.makeItDataVisible(data);
    },

    getPowerNodeColor : function(percent){
       if(this.powerNodeColorFunction){
          var color = this.powerNodeColorFunction(percent);
         return color;
       }
       var color;
       if(percent < 0.25){
          color = 'green';
       }else if(percent >= 0.25 && percent <= 0.75){ // TODO
          color = "orange";
       }else{
          color = "red";
       }
       return color;
    },

    isPowerAvailabe : function(){

    },


});
/**
 * 
 * @param sceneManager
 * @constructor
 */
it.WeightCapacityManager = function (sceneManager) {
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.visibleManager = new $VisibleManager(this.sceneManager);
    this.sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
};

mono.extend(it.WeightCapacityManager, Object, {

    /**
     * 
     * @param dataOrId
     * @returns {*}
     */
    computeWeightPercent: function (dataOrId) {

        var dm = this.dataManager;
        var data = dataOrId;
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var dataType = dm.getDataTypeForData(data);
        if (!dataType) {
            return;
        }
        var weightRating = dataType.getWeightRating();
        //0, null
        if (weightRating == null || weightRating == 0) {
            return null;
        }

        //
        var totalWeight = this.computeChildrenWeight(data);

        return totalWeight / weightRating;
    },

    /**
     * 
     * @param dataOrId
     * @returns {number}
     */
    computeChildrenWeight: function (dataOrId) {

        var dm = this.dataManager;
        var self = this;
        var data = dataOrId;
        if (!data.getId) {

            data = dm.getDataById(dataOrId);
        }
        var totalWeight = 0, weight;
        var childList = data.getChildren();
        childList.forEach(function (child) {//haizi
            weight = child.getWeight() || 0;
            totalWeight += weight;
            //
            var childChildren = child.getChildren();
            if (childChildren && childChildren.size() > 0) {
                totalWeight += self.computeChildrenWeight(child);
            }
        });
        return totalWeight;
    },

    /**
     * 
     * @param dataOrId
     */
    createWeightNode: function (dataOrId) {

        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId,
            box = sm.network3d.getDataBox();
        //
        if(!sm.isCurrentSceneInstance(dataOrId)){
            return;
        }
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var node = sm.getNodeByDataOrId(data);
        var percent = this.computeWeightPercent(data);

        if (percent == null) {
            return;
        }
        data._weightPercent = percent;
        var boundingBox = node.getBoundingBox(),
            size = boundingBox.size(),
            width = size.x, height = size.y, depth = size.z;

        var weightNode = node.getClient('weightNode'), weightNode2;
        percent = percent || 0.01; //0, 
        if (!weightNode) {
            weightNode = new mono.Cube(width - 0.2, height, depth - 0.2);
            weightNode2 = new mono.Cube(width, height, depth);
            weightNode2.setParent(weightNode);
            weightNode.s({
                'm.type': 'phong',
            });
            weightNode2.s({
                'm.wireframe': true,
                'm.wireframeLinewidth': 1,
                'm.color': 'white',
            });
            weightNode.setClient('child', weightNode2);
        }
        var color = this.getWeightNodeColor(percent);
        weightNode.s({
            'm.color': color,
            'm.ambient': color,
            'm.specularStrength': 30,
        });
        weightNode.setParent(node);
        weightNode.setScale(1, percent, 1);
        weightNode.setY(height * percent / 2 - height / 2 + 5);
        weightNode.setClient('weightChildNode', true);
        node.setClient('weightNode', weightNode);
        weightNode.setClient('it_data','weight');
        box.addByDescendant(weightNode);
        this.makeItDataUnvisible(data);
        return weightNode;
    },

    // makeItDataNodeUnvisible: function (node) {
    //     if (node.getClient('it_data')) {
    //         if (node.__oldvisible === undefined) {
    //             node.__oldvisible = node.getStyle('m.visible', false, false);
    //             node.__oldvisible = node.__oldvisible === false ? false : true;
    //         }
    //         node.setStyle('m.visible', false);
    //     }
    //     var self = this;
    //     node.getChildren().forEach(function (child) {
    //         self.makeItDataNodeUnvisible(child);
    //     });
    // },

    // makeItDataNodeVisible: function (node) {
    //     if (node.getClient('it_data')) {
    //         if (node.__oldvisible === undefined || node.__oldvisible === true) {
    //             node.setStyle('m.visible', true);
    //         }
    //     }
    //     var self = this;
    //     node.getChildren().forEach(function (child) {
    //         self.makeItDataNodeVisible(child);
    //     });
    // },

    makeItDataUnvisible : function(data){
        if (!data) {
          return;
        }
        this.visibleManager.setVisible(data,false);
        var self = this;
        data.getChildren().forEach(function(child){
            self.makeItDataUnvisible(child);
        });
    },

    makeItDataVisible : function(data){//node
      if (!data) {
         return;
      }
      this.visibleManager.setVisible(data,true);
      var self = this;
      data.getChildren().forEach(function(child){
          self.makeItDataVisible(child);
      });
    },

    removeWeightNode: function (dataOrId) {
        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId, box = sm.network3d.getDataBox();
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        delete data._weightPercent;
        var node = sm.getNodeByDataOrId(dataOrId);
        if (!node) {
            return;
        }
        var weightNode = node.getClient('weightNode');
        if (weightNode) {
            weightNode.setParent(null);
            box.removeByDescendant(weightNode);
            // this.makeItDataNodeVisible(node);
        }
        this.makeItDataVisible(data);
    },

    getWeightNodeColor: function (percent) {
        if (this.weightNodeColorFunction) {
            var color = this.weightNodeColorFunction(percent);
            return color;
        }
        var color;
        if (percent < 0.25) {
            color = 'green';
        } else if (percent >= 0.25 && percent <= 0.75) { // TODO
            color = "orange";
        } else {
            color = "red";
        }
        return color;
    },

    isWeightAvailabe: function () {

    },


});
it.CameraFollow = function (camera) {
    
    this.setHost = function(hostNode){
        if(camera._hostNode){
        	  camera._hostNode.removePropertyChangeListener(follow);
    	  }
    		camera._hostNode = hostNode;
    		hostNode.addPropertyChangeListener(function(e){
    	       follow(e,hostNode);
    		});
    };

	function follow(e,node){
       var property = e.property;
       if(property.startsWith('position') || property.startsWith('rotation')){
     	   	var pos = node.p();
     	   	var distance = camera.getDistance();
     	   	var pos2 = node.worldPosition(new mono.Vec3(-2,1,0),distance);			
		      camera.lookAt(pos);
		      camera.setPosition(pos2);
       }
	};
}
it.InspectionManager = function (sceneManager) {

    it.EventHandler.call(this);
    this.sceneManager = sceneManager;
    this.visibleManager = new it.VisibleManager(sceneManager);
    sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
    this.dataManager = this.sceneManager.dataManager;
    this.camera = this.sceneManager.network3d.getCamera();
    this.box = this.sceneManager.network3d.getDataBox();

    this.status = it.InspectionManager.STATUS_READY;
    this.host = null;//
    this.path = [];//
    this.animates = [];//
    this.loop = false; //,play, false
    this.finalAngle = null;//
    this.limitDistance = 200;//,100
    this.limitAngle = 40; //, 40
    this.inspectDataArray = [];//data
    this.inspectDataMap = {};//data
    this.currentInspectDataArray = [];//,data
    this.currentInspectingDataMap = {}; // data
    this.inspectColor = 'orange';//,
    this.moveSpeed = 10; //
    this.rotateSpeed = 400;//
    this.showTrail = true;//

    this.trailColor = 'green';//
    this.trailWidth = 20;//
    this.trailHeight = 3;//

    this.hideDataMap = {};//,data

    this.isCameraFollow = true;
    this.cameraFollow = null;

};


it.InspectionManager.STATUS_READY = 'ready';
it.InspectionManager.STATUS_PLAYING = 'playing';
it.InspectionManager.STATUS_PAUSE = 'pause';
it.InspectionManager.STATUS_STOP = 'stop';


mono.extend(it.InspectionManager, it.EventHandler, {

    /**
     * 
     * @param data
     */
    renderDataHandle: function (data) {

    },

    /**
     * 
     */
    resetDataHandler: function (data) {

    },


    /**
     * 
     */
    createTrail: function (points, trailWidth, trailHeight, trailColor) {

        var path = new mono.Path();
        path.moveTo(points[0][0], points[0][1]);
        for (var i = 1; i < points.length; i++) {
            path.lineTo(points[i][0], points[i][1]);
        }
        path = mono.PathNode.prototype.adjustPath(path, 20);
        trailWidth = trailWidth || this.trailWidth;
        trailHeight = trailHeight || this.trailHeight;
        trailColor = trailColor || this.trailColor;
        var trail = new mono.PathCube(path, trailWidth, trailHeight);
        trail.s({
            'm.type': 'phong',
            'm.specularStrength': 30,
            'm.color': trailColor,
            'm.ambient': trailColor,
            'm.texture.repeat': new mono.Vec2(150, 1),
        });
        trail.setRotationX(Math.PI);
        trail.setPositionY(trailHeight / 2 + 4);
        trail.setClient('type', 'trail');
        return trail;
    },
    /**
     * 
     */
    play: function () {
        if (this.isPlaying()) {
            console.warn('it is already playing');
            return;
        }

        if (this.isPause()) {
            console.warn('status is pause, you should call resume function');
            return;
        }
        //readystop,
        this.startPlay();
        this.status = it.InspectionManager.STATUS_PLAYING;
    },

    /**
     * 
     */
    pause: function () {
        if (this.isPlaying()) {
            var animate = this.getCurrentAnimate();
            animate.pause();
            this.status = it.InspectionManager.STATUS_PAUSE
        } else {
            console.warn('when inspection status is playing, you can pause inspection')
        }
    },

    /**
     * 
     */
    resume: function () {
        if (this.isPause()) {
            //,
            var animate = this.getCurrentAnimate();
            animate.resume();
            this.status = it.InspectionManager.STATUS_PLAYING;
        } else {
            console.warn('when inspection status is pause, you can resume inspection')
        }
    },

    /**
     * 
     * @param finish
     */
    stop: function (finish) {
        if (this.isPlaying() || this.isPause()) {
            if (!finish) {
                var animate = this.getCurrentAnimate();
                animate.stop();
            }
            this.resetHideData();
            this.resetInspectData();
            this.onFinish();
            //,
            if (this.trail) {
                this.box.remove(this.trail);
            }
            delete this.animates;
            delete this.trail;
            delete this.host.animate;

            this.status = it.InspectionManager.STATUS_STOP;
        } else {
            console.warn('inspection is not started')
        }
    },

    /**
     * , ,
     * @param path {[{x,y}]} path,
     */
    setPath: function (path) {
        this.path = path;
    },

    /**
     * host
     * @param host
     */
    setHost: function (host) {
        this.host = host;
    },

    /**
     * 
     * @returns {boolean}
     */
    isReady: function () {
        return this.status == it.InspectionManager.STATUS_READY;
    },

    /**
     * 
     * @returns {boolean}
     */
    isPlaying: function () {
        return this.status == it.InspectionManager.STATUS_PLAYING;
    },

    /**
     * 
     * @returns {boolean}
     */
    isPause: function () {
        return this.status == it.InspectionManager.STATUS_PAUSE;
    },

    /**
     * 
     * @returns {boolean}
     */
    isStop: function () {
        return this.status == it.InspectionManager.STATUS_STOP;
    },

    /**
     * 
     */
    onFinish: function () {

        console.log("inspection is completed")
    },

    /**
     * 
     * 
     * ,
     */
    startPlay: function () {

        var self = this;
        var sceneManager = this.sceneManager;
        var camera = this.camera;
        var box = this.box;

        this.initInspectData();

        var object = this.host;
        if (this.isCameraFollow) {
            var cameraFollow = this.cameraFollow || new it.CameraFollow(camera);
            cameraFollow.setHost(object);
        }
        var points = this.path;
        object.setPositionX(points[0][0]);
        object.setPositionZ(points[0][1]);
        //create animate chain
        var animates = this.animates = this.createPathAnimates(camera, object, points, this.loop, this.finalAngle);
        animates[animates.length - 1].onDone = function () {

            self.stop(true);
        };

        this.hideData();

        if (this.showTrail) {

            if (self.createTrail) {
                this.trail = self.createTrail(this.path);
            }
            if (this.trail) {
                this.trail.setParent(this.host.getParent());
                box.add(this.trail);
            }
        }
        //start play
        object.animate = animates[0];
        object.animate.play();
    },

    hideData: function () {
        var self = this;
        var keys = Object.keys(this.hideDataMap);
        keys.forEach(function (key) {
            var data = self.hideDataMap[key];
            self.visibleManager.setVisible(data, false);
        })
    },

    resetHideData: function () {
        var self = this;
        var keys = Object.keys(this.hideDataMap);
        keys.forEach(function (key) {
            var data = self.hideDataMap[key];
            self.visibleManager.setVisible(data, true);
        })
    },

    /**
     * 
     */
    initInspectData: function () {
        this.inspectDataArray = [];
        this.inspectDataMap = {};
        this.hideDataMap = {};
        this.box.getNodes().forEach(function (node) {
            var data = this.sceneManager.getNodeData(node);
            if (data && !this.inspectDataMap[data.getId()] && this.isInspect(data)) {
                this.initDataPositionAndRotation(data);
                this.inspectDataMap[data.getId()] = data;
                this.inspectDataArray.push(data);
            }
            if (data && !this.hideDataMap[data.getId()] && this.isHideInInspection(data)) {
                this.hideDataMap[data.getId()] = data;
            }
        }, this);
    },

    /**
     * 
     * @returns {*}
     */
    getCurrentAnimate: function () {
        if (this.host) {
            return this.host.animate;
        }
        return null;
    },

    /**
     * 
     * @param camera
     * @param element
     * @param points
     * @param loop
     * @param finalAngle
     * @returns {Array}
     */
    createPathAnimates: function (camera, element, points, loop, finalAngle) {

        var self = this;
        var animates = [];
        var moveSpeed = this.moveSpeed || 10;
        var rotateSpeed = this.rotateSpeed || 400;

        if (points && points.length >= 2) {

            var angle = element.getRotationY() || 0;

            for (var i = 1; i < points.length; i++) {
                var point0 = points[i - 1];
                var point1 = points[i];
                var x = point0[0];
                var z = point0[1];
                var x1 = point1[0];
                var z1 = point1[1];
                var rotate = Math.atan2(-(z1 - z), x1 - x) || 0;

                var rotateAnimate = this.createRotateAnimate(camera, element, rotateSpeed, rotate, angle);
                if (rotateAnimate) {
                    animates.push(rotateAnimate);
                    angle = rotateAnimate.toAngle;
                }

                var moveAnimate = this.createMoveAnimate(camera, element, moveSpeed, x, z, x1, z1);
                animates.push(moveAnimate);

                x = x1;
                z = z1;
            }

            if (finalAngle != undefined && angle != finalAngle) {
                var rotateAnimate = this.createRotateAnimate(camera, element, rotateSpeed, finalAngle, angle);
                if (rotateAnimate) {
                    animates.push(rotateAnimate);
                }
            }
        }
        var animate;
        for (var i = 0; i < animates.length; i++) {
            if (i > 0) {
                animates[i - 1].chain(animates[i]);
                if (loop && i == animates.length - 1) {
                    animates[i].chain(animate);
                }
            } else {
                animate = animates[i];
            }
        }
        return animates;
    },

    /**
     * 
     * @param camera
     * @param element
     * @param moveSpeed
     * @param x
     * @param z
     * @param x1
     * @param z1
     * @returns {TGL.Animate|mono.Animate|Ib.Animate|Ib.animate.Animate}
     */
    createMoveAnimate: function (camera, element, moveSpeed, x, z, x1, z1) {

        var self = this;
        var moveAnimate = new mono.Animate({
            from: { x: x, y: z },
            to: { x: x1, y: z1 },
            type: 'point',
            dur: Math.sqrt((x1 - x) * (x1 - x) + (z1 - z) * (z1 - z)) * moveSpeed,
            easing: 'easeNone',
            onPlay: function () {
                element.animate = this;
                self.currentInspectDataArray = self.getCurrentInspectionData(this);
                self.resetInspectData();
            },
            onUpdate: function (value) {
                element.setPositionX(value.x);
                element.setPositionZ(value.y);
                self.renderInspectData();

            },
        });
        return moveAnimate;
    },

    /**
     * 
     * @param camera
     * @param element
     * @param toAngle
     * @param angle
     * @returns {*}
     */
    createRotateAnimate: function (camera, element, rotateSpeed, toAngle, angle) {

        angle = parseFloat(angle);
        toAngle = parseFloat(toAngle);
        if (angle === undefined || angle === null || isNaN(angle) ||
            toAngle === undefined || angle === null || isNaN(toAngle) ||
            toAngle == angle) {
            return null;
        }
        if (toAngle - angle > Math.PI) {
            toAngle -= Math.PI * 2;
        }
        if (toAngle - angle < -Math.PI) {
            toAngle += Math.PI * 2;
        }
        //console.log(angle, toAngle);
        var rotateAnimate = new mono.Animate({
            from: angle,
            to: toAngle,
            type: 'number',
            dur: Math.abs(toAngle - angle) * rotateSpeed,
            easing: 'easeNone',
            onPlay: function () {
                element.animate = this;
            },
            onUpdate: function (value) {
                value = value || 0;
                element.setRotationY(value);
            },

        });
        rotateAnimate.toAngle = toAngle;
        return rotateAnimate;
    },


    /**
     * 
     * @param data
     */
    renderData: function (data) {

        if (data._inspected) {
            return;
        }
        data._inspected = true;
        var node = this.sceneManager.getNodeByDataOrId(data);
        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        var oldColor = node.getStyle('inspection.m.ambient') || node.getStyle('m.ambient');
        node.setStyle('m.ambient', this.inspectColor);
        node.setStyle('inspection.m.ambient', oldColor);
        this.renderDataHandle && this.renderDataHandle(data);
    },

    /**
     * 
     * @param data
     */
    resetData: function (data) {
        if (!data._inspected) {
            return;
        }
        data._inspected = false;
        delete data._inspected;
        delete data._face2animateLine;
        delete data._distance2host;
        var node = this.sceneManager.getNodeByDataOrId(data);
        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        node.setStyle('m.ambient', node.getStyle('inspection.m.ambient'));
        node.setStyle('inspection.m.ambient', null);
        this.resetDataHandler && this.resetDataHandler(data);
    },

    /**
     * 
     */
    renderInspectData: function () {

        var result = false;
        var self = this;

        var newDataArrayTemp = [];
        //hostdata
        this.currentInspectDataArray.forEach(function (data) {
            if (self.isClosed(data, self.host)) {
                newDataArrayTemp.push(data);

            }
        })

        //data, data,
        var newDataArray = this.filterInspectData(newDataArrayTemp);

        //data
        var map = {};
        newDataArray.forEach(function (data) {
            map[data.getId()] = data;
        })

        //,data
        newDataArray.forEach(function (data) {
            if (!self.currentInspectingDataMap[data.getId()]) {
                self.renderData(data);
                self.currentInspectingDataMap[data.getId()] = data;
                result = result || true;
            }
        })

        //, 
        var keys = Object.keys(this.currentInspectingDataMap);
        if (keys.length > 0) {
            keys.forEach(function (key) {
                if (!map[key]) {
                    self.resetData(self.currentInspectingDataMap[key]);
                    delete self.currentInspectingDataMap[key];
                    result = result || true;
                }
            })
        }
        return result;
    },

    /**
     * 
     */
    resetInspectData: function () {
        var self = this;
        var keys = Object.keys(this.currentInspectingDataMap);
        if (keys.length > 0) {
            keys.forEach(function (key) {
                self.resetData(self.currentInspectingDataMap[key]);
                delete self.currentInspectingDataMap[key]
            })
        }
    },

    /**
     * 
     * @param array
     * @returns {*}
     */
    filterInspectData: function (array) {

        if (array.length <= 1) {
            return array;
        }
        var result = [];

        //
        array.sort(function (o1, o2) {
            return o1._distance2host - o2._distance2host;
        });

        for (var i = 0; i < array.length; i++) {
            var d = array[i];
            //,
            if (d._face2animateLine === undefined) {
                continue;
            }
            if (!this.haveSameDir(d, result)) {
                result.push(d);
            }
        }

        return result;
    },

    /**
     * 
     * @param data
     * @param array
     * @returns {boolean}
     */
    haveSameDir: function (data, array) {
        var angle = data._face2animateLine;
        for (var j = 0; j < array.length; j++) {
            var angleTmp = array[j]._face2animateLine;
            //,
            if (Math.abs(angle - angleTmp) < 45) {
                return true;
            }
        }
        return false;
    },

    /**
     * 
     * 
     * @param data
     * @returns {boolean}
     */
    isInspect: function (data) {
        var dataType = this.dataManager.getDataTypeForData(data);
        if (!dataType) {
            return false;
        }
        var categoryId = dataType.getCategoryId();
        if (categoryId == 'rack' || categoryId == 'headerRack') {
            return true;
        }
        return false;
    },

    /**
     * 
     * @param data
     * @returns {boolean}
     */
    isHideInInspection: function (data) {
        var dataType = this.dataManager.getDataTypeForData(data);
        if (!dataType) {
            return false;
        }
        var categoryId = dataType.getCategoryId();
        if (categoryId == 'channel') {
            return true;
        }
        return false;
    },

    /**
     * , data, limitDistancedata
     * @param animate
     * @returns {Array}
     */
    getCurrentInspectionData: function (animate) {
        var result = [];
        var from = animate.from;
        var to = animate.to;
        var line = this.getLine(from, to);
        this.inspectDataArray.forEach(function (data) {
            if (this.isFace2Line(data, from, to, line)) {
                result.push(data);
            }
        }, this)
        return result;
    },

    /**
     * 
     * @param data
     * @returns {boolean}
     */
    isFace2Line: function (data, from, to, line) {

        var np = data._absolutePosition;
        var npx = np.x;
        var npy = np.z;
        var nodeAngle = data._absoluteRotation.y;
        if (line.b == 0) {

            var dx = npx - to.x;
            if (Math.abs(dx) > this.limitDistance) {
                return false;
            }

            //
            var angle;
            //
            if (npx > -line.c) {
                angle = 270;
            } else {
                angle = 90;
            }
            //
            if (Math.abs(nodeAngle - angle) > this.limitAngle) {
                return false;
            }
            data._face2animateLine = angle;
        } else if (line.a == 0) {

            var dy = npy - to.y;
            if (Math.abs(dy) > this.limitDistance) {
                return false;
            }

            //
            var angle;
            //
            if (npy > -line.c) {
                angle = 180;
            } else {
                angle = 0;
            }
            if (Math.abs(nodeAngle - angle) > this.limitAngle) {
                return false;
            }
            data._face2animateLine = angle;
        } else {

            var d = Math.abs((line.a * npx + line.b * npy + line.c) / Math.sqrt(Math.pow(line.a, 2) + Math.pow(line.b, 2)))
            if (d > this.limitDistance) {
                return false;
            }

            //
            var kk = 1 / line.k;//
            var angle = Math.atan(kk) / Math.PI * 180; //
            var npxx = -(line.b * npy + line.c) / line.a;
            //
            if (npxx < npx) {// 90 270

                angle += 180;
            } else {  // -90   90

                if (angle < 0) {
                    angle += 360;
                }
            }
            //-90,90
            angle += 90;
            angle = angle % 360;
            //, 180
            var da = Math.abs(nodeAngle - angle);
            if (da > 180) { //180, , 180
                da = 360 - da;
            }
            if (da > this.limitAngle) {
                return false;
            }
            data._face2animateLine = angle;
        }
        return true;
    },

    /**
     * 
     * @param data
     * @param host
     * @returns {*}
     */
    isClosed: function (data, host) {

        var np = data._absolutePosition;
        var npx = np.x;
        var npy = np.z;

        var hp = host.getPosition();
        var hpx = hp.x;
        var hpy = hp.z;
        var d = Math.sqrt(Math.pow(hpx - npx, 2) + Math.pow(hpy - npy, 2));
        data._distance2host = d;
        return d < this.limitDistance;
    },

    /**
     * , 
     * @param p1
     * @param p2
     * @returns {*}
     */
    getLine: function (p1, p2) {
        if (p1.x == p2.x) {
            //
            return { a: 1, b: 0, c: -p1.x };
        } else if (p1.y == p2.y) {
            //
            return { a: 0, b: 1, c: -p1.y }
        }
        var a = 0, b = 0, c = 0;
        var k = (p1.y - p2.y) / (p1.x - p2.x);
        var c = p1.y - k * p1.x;
        a = k, b = -1;
        return { a: a, b: b, c: c, k: k }
    },

    /**
     * data
     * @param data
     */
    initDataPositionAndRotation: function (data) {

        if (data._absolutePosition && data._absoluteRotation) {
            return;
        }
        var node = this.sceneManager.getNodeByDataOrId(data);
        var p = node.getPosition();
        var r = node.getRotation();
        var pp = { x: p.x, y: p.y, z: p.z };
        var rr = { x: r.x, y: r.y, z: r.z };
        var parentData = this.dataManager.getDataById(data.getParentId());
        this._initDataPositionAndRotation(parentData, pp, rr);
        rr.x = (rr.x / Math.PI * 180) % 360;
        rr.y = (rr.y / Math.PI * 180) % 360;
        rr.z = (rr.z / Math.PI * 180) % 360;
        data._absolutePosition = pp;
        data._absoluteRotation = rr;
    },

    /**
     * 
     * @param parentData
     * @param position
     */
    _initDataPositionAndRotation: function (parentData, position, rotation) {

        if (!parentData) {
            return;
        }
        var dataType = this.dataManager.getDataTypeForData(parentData);
        if (!dataType) {
            console.warn('dataType is null');
            return;
        }
        var categoryId = dataType.getCategoryId();
        if (categoryId == 'floor') {
            console.warn('parent data type is floor, calculate position complete')
            return;
        }

        //
        //x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ;

        //y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ;

        var parentNode = this.sceneManager.getNodeByDataOrId(parentData);
        if (parentNode) {
            var pp = parentNode.getPosition();
            var rr = parentNode.getRotation();

            var x = position.x;
            var z = position.z;
            var rx0 = 0;
            var rz0 = 0;
            var a = -rr.y;//
            var x0 = (x - rx0) * Math.cos(a) - (z - rz0) * Math.sin(a) + rx0;
            var z0 = (x - rx0) * Math.sin(a) + (z - rz0) * Math.cos(a) + rz0;
            position.x = x0;
            position.z = z0;//2D3D,3D, , z, 

            position.x += pp.x;
            position.y += pp.y;
            position.z += pp.z;


            rotation.x += rr.x;
            rotation.y += rr.y;
            rotation.z += rr.z;
        }

        var parentParentData = this.dataManager.getDataById(parentData.getParentId());
        if (parentParentData) {
            this._initDataPositionAndRotation(parentParentData, position, rotation);
        }
    }
});

/**
 * 
 * 1
 * 2
 * 3
 */
var $PortManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	this.dataBox = this.sceneManager.network3d.getDataBox();
	//2Did:'id+"@"+parentId',parentId
	//tree,{parentId001:{port01:portNode01,...},parentId001:{port01:portNode01,...}}
	this.portNodeMap = {}; //  2017-07-21
};

mono.extend($PortManager,Object,{

	removePortsByParentId : function(parentId){
		var ports = this.portNodeMap[parentId];
		if (ports) {
			for(var id in ports){
				var port = ports[id];
				if (port) {
					port.setParent(null);
					this.dataBox.remove(port);
				}
			}
			// delete this.portNodeMap[parentId];
		}
	},

	/**
     * id
     */
	getAllPortsByParentId: function(parentId){
		var ports = [];
		var dataType = this.dataManager.getDataTypeForData(parentId);
		if (!dataType || !dataType.getTemplateDatas()) {
			return null;
		}
		var templateDatas = dataType.getTemplateDatas();
		for(var i = 0 ;i < templateDatas.length; i++){
			var tdata = templateDatas[i];
			var side = tdata.getUserData('side')||0;
			port = this.loadPortByPortId(parentId,tdata.getId(),side);
			ports.push(port);
		}
		return ports;
	},
    
    /**
     * id
     */
	loadAllPortsByParentId : function(parentId){
		var ports = this.getAllPortsByParentId(parentId);
		for(var i = 0 ;i < ports.length; i++){
			var port = ports[i];
			this.dataBox.add(port);
		}
	},
    
    /**
     * id(idparentidid)
     */
	loadPortByPortId : function(parentId,portId,side){
		var port = this.getPortById(parentId,portId);
		if (port) {
			return port;
		}
	    port = this.createPortByPortId(parentId,portId,side);
		if (port) {
			var parentPorts = this.portNodeMap[parentId];
			if (!parentPorts) {
				parentPorts = {portId:port};
				this.portNodeMap[parentId] = parentPorts;
			}else{
				parentPorts[portId] = port;
			}
		}
		return port;
	},

    /**
     * id
     */
	getPortById : function(parentId,portId){
		var parentPorts = this.portNodeMap[parentId];
		if (parentPorts) {
			return parentPorts[portId];
		}
		return null;
	},
    
    /**
     * id3d
     * @parentId id
     * @portId id
     * @side 01
     * ()
     */
	createPortByPortId : function(parentId,portId,side){
		var dataType = this.dataManager.getDataTypeForData(parentId);
		var devNode = this.sceneManager.getNodeByDataOrId(parentId);
		if (!dataType || !portId || !devNode) {
			return null;
		}
		side = side||0;
		var portData = dataType.getTemplateDataById(portId+(side?'@true':'@false'));
		if (!portData) {
			return null;
		}
		var panelData = dataType.getModel2dParameters()[0];
		var portType = this.dataManager.getDataTypeById(portData.getDataTypeId()); //can not getDataTypeForData
		if (!portType) {
			return null;
		}
		if (!panelData) {
			return null;
		}
		if (!portType.getModel()) {
			console.log('portTypes model is null!');
			return null;
		};
		var panelParam = make.Default.getModelDefaultParametersValues(panelData.id);
		// {width: 13.06, height: 9.55}
		var portParam = make.Default.getModelDefaultParametersValues(portType.getModel2d());
		if (!portParam) {
			console.log('port Param is null');
			return null;
		}
		var port = this.sceneManager.loadModel(portType.getModel(),portType.getModelParameters(),true,portType.getId());
		// x:(data.getPosition().x - panel.size.x)/10
		// y:(data.getPosition().y - panel.size.y)/10
		var port2DPos = portData.getPosition();
		var portRot = portData.getRotation();// 
		var dbb = devNode.getBoundingBox();
		if (!port || !port2DPos || !panelParam) {
			return null;
		}
		 // {width: 455, height: 44.45} ,10(x: 50, y: 4.445, z: 51)boundingBoxsize
		 var scaleX = panelParam.width/dbb.size().x; 
		 var scaleY = panelParam.height/dbb.size().y;

         /* 
		 var padding = devNode.getClient('padding');
		 if (side === 1 && padding && padding instanceof Array) {
		 	 var up = padding[0]||0,right = padding[1]||0,down = padding[2]||0,left = padding[3]||0;
		 	 scaleX = panelParam.width/(dbb.size().x - right - left);
		 	 scaleY = panelParam.height/(dbb.size().y - up - down);
		 }
		 */
		 // nn 
		var x = (port2DPos.x + portParam.width/2 - panelParam.width/2)/scaleX; 
		var y = (panelParam.height/2 - portParam.height/2 - port2DPos.y)/scaleY; // 2d(0,0)hostlocationhost
		if (side === 1) { // padding
		 	var backPanelData = dataType.getModel2d2Parameters()[0];
		 	var backPanelParam = make.Default.getModelDefaultParametersValues(backPanelData.id);
		 	var backWidth = backPanelParam.width;
		 	var backHeight = backPanelParam.height;
		 	// var up  = (panelParam.height-backHeight)/2;
		 	// var left = (panelParam.width-backWidth)/2;
		 	var up = 0; //+up-left
		 	var left = 0;
		 	x = (port2DPos.x + portParam.width/2 + left - backPanelParam.width/2)/scaleX; 
		    y = (backPanelParam.height/2 - portParam.height/2 - port2DPos.y - up)/scaleY;
		}
		port.setX(x);
		port.setY(y);
		if (side === 1) {
			port.setZ(dbb.min.z); 
			// 
			port.setRotationY(Math.PI);
			var px =  (-1)*x;  //
			port.setX(px);
		}else{
			port.setZ(dbb.max.z);
		}
		if (portRot) {
			if (portRot.x) {
				port.setRotationX(portRot.x*Math.PI/180);
			}
			if (portRot.z) {
				port.setRotationZ(portRot.z*Math.PI/180);
			}
		}
		port.c({
			'parentId': parentId,
			'portId': portId,
			'side': side
		});
		port.setParent(devNode);
		return port;
	}
	
});

it.PortManager = $PortManager;
/**
 * 
 * @param sceneManager
 * @constructor
 */
it.PortCapacityManager = function (sceneManager) {

    it.EventHandler.call(this);
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.visibleManager = new $VisibleManager(this.sceneManager);
    this.sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
    this.colors = ['#8A0808', '#088A08', '#088A85', '#6A0888', '#B18904'];
    this.padding = 2.5;
    this.portNodes = [];
    this.solidColor = '#eaeaea';
};

it.PortCapacityManager.CATEGORY_EQUIPMENT = 'equipment';
it.PortCapacityManager.CATEGORY_PORT = 'port';

mono.extend(it.PortCapacityManager, it.EventHandler, {

    /**
     * 
     * @param dataOrId
     * @returns {*}
     */
    computePortPercent: function (dataOrId) {

        var dm = this.dataManager;
        var data = dataOrId;
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var dataType = dm.getDataTypeForData(data);
        if (!dataType) {
            return;
        }
        //
        if (dataType.getCategoryId() != it.PortCapacityManager.CATEGORY_EQUIPMENT) {
            return;
        }

        //
        var ports = this.computePortInfo(data);
        //,100%
        if (!ports || ports.length == 0) {
            return 100;
        }

        //
        var count = 0;
        for (var i = 0; i < ports.length; i++) {
            var port = ports[i];
            var links = port.getAllLinks();
            if (links && Object.keys(links).length > 0) {
                count++;
            }
        }
        return count / ports.length * 100;
    },

    /**
     * 
     * @param dataOrId
     * @returns {Array}
     */
    computePortInfo: function (dataOrId) {

        var dm = this.dataManager;
        var self = this;
        var data = dataOrId;
        if (!data.getId) {

            data = dm.getDataById(dataOrId);
        }
        //
        var allPorts = [];
        var children = dm.getChildren(data);
        children.forEach(function (child) {
            var childDataType = dm.getDataTypeForData(child);
            if (!childDataType || childDataType.getCategoryId() != it.PortCapacityManager.CATEGORY_PORT) {
                return;
            }
            allPorts.push(child);
        })
        return allPorts;
    },

    /**
     * 
     * @param dataOrId
     */
    createPortNode: function (dataOrId, width, height, depth, positionY, rackNode) {

        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId,
            box = sm.network3d.getDataBox();
        //
        if (!sm.isCurrentSceneInstance(dataOrId)) {
            return;
        }
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var percent = this.computePortPercent(data);

        if (percent == null) {
            return;
        }

        percent = Math.round(Math.random() * 100);//FIXME 
        data._portPercent = percent;

        var portNode = data._portNode;
        if (!portNode) {
            portNode = new mono.Cube(width, height, depth);
            portNode.setPosition(0, positionY, 0);
            portNode.s({
                'm.type': 'phong',
                'm.specularStrength': 50,
                'm.transparent': true,
                'm.opacity': 0.6,

            });
            portNode.setClient('it_data', 'port');
            portNode.setClient('portChildNode', true);
            portNode.setClient('data', data);
            data._portNode = portNode;
        }
        var color = this.getPortNodeColor(percent);
        portNode.s({
            'm.color': color,
            'm.ambient': color,
        });
        portNode.setParent(rackNode);
        box.addByDescendant(portNode);
        return portNode;
    },

    /**
     * 
     * @param dataOrId
     */
    createSolidNode: function (width, height, depth, positionY, rackNode) {

        var sm = this.sceneManager, dm = this.dataManager, box = sm.network3d.getDataBox();

        var solidNode = solidNode = new mono.Cube(width, height, depth);
        solidNode.setPosition(0, positionY, 0);
        solidNode.s({
            'm.type': 'phong',
            'm.specularStrength': 50,
            'm.color': this.solidColor,
            'm.ambient': this.solidColor,

        });
        solidNode.setClient('it_data', 'port_solid');
        solidNode.setClient('portChildNode_solid', true);
        solidNode.setParent(rackNode);
        box.addByDescendant(solidNode);
        return solidNode;
    },

    makeItDataUnvisible: function (data) {
        if (!data) {
            return;
        }
        this.visibleManager.setVisible(data, false);
        var self = this;
        data.getChildren().forEach(function (child) {
            self.makeItDataUnvisible(child);
        });
    },

    makeItDataVisible: function (data) {//node
        if (!data) {
            return;
        }
        this.visibleManager.setVisible(data, true);
        var self = this;
        data.getChildren().forEach(function (child) {
            self.makeItDataVisible(child);
        });
    },

    removePortNode: function (dataOrId) {
        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId, box = sm.network3d.getDataBox();
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        delete data._portPercent;
        var portNode = data._portNode;
        if (portNode) {
            portNode.setParent(null);
            box.removeByDescendant(portNode);
        }
        this.makeItDataVisible(data);
    },

    getPortNodeColor: function (percent) {
        if (this.portNodeColorFunction) {
            var color = this.portNodeColorFunction(percent);
            return color;
        }

        var colorIndex = Math.ceil(percent / 20);
        return this.colors[colorIndex - 1];
    },

    isDataSupport: function (data) {
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        if (dataType && dataType.getCategoryId() == it.PortCapacityManager.CATEGORY_EQUIPMENT && dataType.getSubType() == 'network') {

            return true;
        }
        return false;
    },

    calcDataHeight: function (data) {
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        var size = dataType.getSize();
        return parseInt(size.ySize || 0) * make.Default.UNIT_HEIGHT;
    },


    /**
     * 
     * FIXME ,
     * @param data
     */
    createPortNodeInRack: function (data) {
        var result = [];
        var sm = this.sceneManager, dm = this.dataManager, self = this;
        //
        if (!sm.isCurrentSceneInstance(data)) {
            return;
        }
        var dataType = dm.getDataTypeForData(data);
        if (!dataType) {
            console.warn('dataType is not exist');
            return;
        }
        var rackNode = sm.getNodeByDataOrId(data);
        if (!rackNode) {
            console.warn('rack node is not exist')
            return;
        }
        var childrenSize = dataType.getChildrenSize();
        var boundingBox = rackNode.getBoundingBox(),
            size = boundingBox.size(),
            width = size.x, height = size.y, depth = size.z;

        this.makeItDataUnvisible(data);
        var childrenAll = dm.getChildren(data);
        //var children = [];
        var childMap = {};
        //
        childrenAll.forEach(function (child) {
            if (self.isDataSupport(child)) {
                //children.push(child);
                childMap[child.getLocation().y] = child;
            }
        })

        var lastSolid = 0;
        //
        for (var i = 1; i <= childrenSize.ySize; i++) {
            if (childMap[i]) {

                var child = childMap[i];
                if (lastSolid != 0) {
                    //
                    var childSize = i - lastSolid;
                    var childHeight = parseInt(childSize) * make.Default.UNIT_HEIGHT;
                    childHeight -= self.padding;

                    var positionY = childrenSize.yPadding[0];
                    positionY += (lastSolid - 1 + (childSize) / 2) * make.Default.UNIT_HEIGHT;
                    positionY += self.padding / 2;
                    positionY -= height /2;
                    console.log('solid: height = ' + childHeight + '  positionY = ' + positionY);
                    var node = self.createSolidNode(width, childHeight, depth, positionY, rackNode);
                    if (node) {
                        result.push(node);
                    }
                    lastSolid = 0;
                }
                var childDataType = dm.getDataTypeForData(child);
                var childSize = childDataType.getSize().ySize;
                var childHeight = parseInt(childSize || 0) * make.Default.UNIT_HEIGHT;
                childHeight -= self.padding;

                var loc = child.getLocation();
                var positionY = childrenSize.yPadding[0];
                positionY += (loc.y - 1 + childSize / 2) * make.Default.UNIT_HEIGHT;
                positionY += self.padding / 2;
                positionY -= height /2;
                console.log('port : height = ' + childHeight + '  positionY = ' + positionY);
                var node = self.createPortNode(child, width, childHeight, depth, positionY, rackNode);
                if (node) {
                    result.push(node);
                }
                i--;
                i += childSize;
            } else if (lastSolid == 0) {
                lastSolid = i;
                continue;
            }

        }
        if (lastSolid != 0) {
            //
            var childSize = i - lastSolid;
            var childHeight = parseInt(childSize) * make.Default.UNIT_HEIGHT;
            childHeight -= self.padding;

            var positionY = childrenSize.yPadding[0];
            positionY += (lastSolid - 1 + (childSize) / 2) * make.Default.UNIT_HEIGHT;
            positionY += self.padding / 2;
            positionY -= height /2;
            console.log('solid: height = ' + childHeight + '  positionY = ' + positionY);
            var node = self.createSolidNode(width, childHeight, depth, positionY, rackNode);
            if (node) {
                result.push(node);
            }
            lastSolid = 0;
        }
        data.portNodeArray = result;
        //
        //children.sort(function (o1, o2) {
        //    return o1.getLocation().y - o2.getLocation().y;
        //})
        //children.forEach(function (child) {
        //
        //    var solid = !!child.network;
        //    var childDataType = dm.getDataTypeForData(child);
        //    var childSize = childDataType.getSize();
        //    var childHeight = parseInt(childSize.ySize || 0) * make.Default.UNIT_HEIGHT;
        //    var loc = child.getLocation();
        //    var positionY = childrenSize.yPadding[0];
        //    positionY += loc.y * make.Default.UNIT_HEIGHT - height / 2;
        //    childHeight -= self.padding;
        //    positionY += self.padding / 2;
        //    var node = self.createPortNode(child, width, childHeight, depth, positionY, solid, rackNode);
        //    if (node) {
        //        result.push(node);
        //    }
        //
        //})
        return result;
    },

    hasChild: function (y, children) {

    },

    /**
     * 
     * @param data
     */
    removePortNodeInRack: function (data) {
        var sm = this.sceneManager, dm = this.dataManager, self = this, box = sm.network3d.getDataBox();
        //
        if (!sm.isCurrentSceneInstance(data)) {
            return;
        }
        var rackNode = sm.getNodeByDataOrId(data);
        if (!rackNode) {
            return;
        }
        this.makeItDataVisible(data);
        if (data.portNodeArray) {
            data.portNodeArray.forEach(function (node) {
                box.remove(node);
            })
        }
    },
});

var $VisibleManager = function(sceneManager){
    it.VisibleFilter.call(this);
    this.sceneManager = sceneManager;
    this.isDealWithFunction = null;
    this._vmap = {};
};

mono.extend($VisibleManager,it.VisibleFilter,{

    clear: function(){
        this._vmap = {};
        // viewManager3Dclearfire,!!!
        this.sceneManager._sceneVisibleChangeDispather.fire({
                data:null,
                type:'clear'
        });
    },

    /**
     * /
     * @param data
     * @returns {boolean}
     */
    isDealWith : function(data){
        if(this.isDealWithFunction != null){
            return this.isDealWithFunction(data);
        }
        return true;
    },

    getBId : function(data){
        if(!data) {
            return null;
        }
        if (!(data instanceof it.Data)) {
             return null;
        }
        if(!this.isDealWith(data)){
            return null;
        }
        return data.getId();
    },

    setVisible: function(data, visible, fireDispather) {
        var id = this.getBId(data);
        if (id) {
            var oldValue = this._vmap[id];
            if (visible) {
                delete this._vmap[id];
            } else {
                this._vmap[id] = false;
            }
            if (oldValue == undefined) { //map
                return ;
            }
            if (fireDispather === null || fireDispather === undefined) {
                fireDispather = true;
            }
            if (fireDispather && (oldValue != visible)) {
                this.sceneManager._sceneVisibleChangeDispather.fire({
                    data: data,
                    value: visible,
                });
            }
        }
    },

    getDataByNode : function(node){
        if(!node){
            return null;
        }
        return this.sceneManager.getNodeData(node);
    },

    setVisibleByDescendant : function(data,visible,fireDispather){
        if(!data){
            return ;
        }
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(fireDispather === null || fireDispather === undefined){
            fireDispather = true;
        }
        if(!data || !data.getId()) return;
        this.setVisible(data,visible,false);
        // var node = this.sceneManager.dataNodeMap[data.getId()];
        // var children = node.getChildren();
        var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                // var childData = this.getDataByNode(child);
                // if(childData
                //     && this.getBId(childData) != this.getBId(data)){
                //     this.setVisibleByDescendant(child,visible,false,this);
                // }
                if(this.getBId(child) != this.getBId(data) 
                    || (!this.getBId(child) && !this.getBId(data))){ //Bidnullfilter()
                    this.setVisibleByDescendant(child,visible,false,this);
                }
            }
        }
        if(fireDispather){
            this.sceneManager._sceneVisibleChangeDispather.fire({
                data: data,
                type:'descendtant',
                value: visible,
            });
        }
    },

    isVisible: function(node,dataOrId,network){
        var data = null;
        if (dataOrId) {
            if (dataOrId instanceof it.Data) {
                data = dataOrId;
            }else{
                data = this.sceneManager.dataManager.getDataById(dataOrId);
            }
        }
        var id = this.getBId(data);
        if (node && node.getClient(it.SceneManager.CLIENT_EXT_VISIBLE)) { // 
            return true;
        }
        if(this._vmap[id] != false){
            return true;
        }
        return false;
    }

});

it.VisibleManager = $VisibleManager;


/**
 * DataFind
 * @constructor
 */
it.SData = function(inputIndex,inputType,label,placeholder,dataType,readonly){
    it.Base.call(this);
    this._key = "";
//    this._isObject = false; // data.obj[key] obj
    this._isClient = false;
    this._value = "";
    this._operation = "";
    this._clientMap = {};
    this._style = "";
    this.placeholder = placeholder;
    this.label = label;
    this.inputType = inputType;
    this.inputIndex = inputIndex; //BasePaneldivid
    this._dataType = dataType||'string';
    this._readonly = false;
    if (readonly === true) {
        this._readonly = true;
    }
//    this._rowspan = null;
//    this._colspan = null;
};

mono.extend(it.SData,it.Base,{

    ___accessor :['key','isClient','value','operation','style','dataType'],

    setClient : function(key,value){
        if(key){
            this._clientMap[key] = value;
        }
    },

    getClient : function(key){
       return this._clientMap[key];
    },

    //{key:'u:userId',value:'aaa',operation:'like'}
    toString : function(){
        if(!this._key || !this._value){
            return '';
        }
        var key = this._key;
        if(this._isClient){
            key = 'u:' + key;
        }
        var obj = {key:key};
        var value = '';
        if(this._value){
            value = this._value;
        }
        obj.value = value;
        var operation = '=';
        if(this._operation){
            operation = this._operation;
        }
        obj.operation = operation;
        obj.dataType = this._dataType;
        return obj;
    }

});


/**
 * panel
 * @constructor
 */

it.BasePanel = function(panelId){
    if(!panelId){
        panelId = 'base-search-panel'
    }
    this.mainPane = $('<div id="'+panelId+'" class="inputPane"> </div>');
    this._ids = [];
    this.inputMap = {}; // sdatainput
    this.className = 'BasePanel';
    this.doClickFunction = null;
    this.doClearFunction = null;
};

mono.extend(it.BasePanel,Object,{

    createRow : function(){
        return $('<div class="row"></div>');
    },

    createCol : function(num,withClass){
        if(!num){
            num = 3;
        }
        if(withClass){
            return  $('<div class="without-padding col-md-'+num+' '+ withClass +'"></div>');
        }else{
            return  $('<div class="without-padding col-md-'+num+'"></div>');
        }
    },

    appendRow : function(row){
        if(row){
            this.mainPane.append(row);
            var height = this.mainPane.height();
            height += 27;
            // this.mainPane.height(height); //lable
        }
    },

    addQuick : function(cdata){
        if(!cdata) return;
        if (this.className && cdata.inputIndex) {
            cdata.inputIndex = this.className + '_' + cdata.inputIndex;
        };
        var id = cdata.inputIndex;
        var placeholder = cdata.placeholder;
        var row = this.createRow();
        var col = this.createCol(12);
        var input = $('<input type="text" class="input-min contral-width" id="'+id+'" placeholder="'+placeholder+'">');
        var style = cdata.getStyle()||"";
        if(style){
            input.attr('style',style);
        }
        var self = this;
        input.keypress(function(event){
            if(event.keyCode === 13){
                self.doClick();
            }
        });
        col.append(input);
        this.inputMap[id] = input;
        row.append(col);
        this.appendRow(row);
        this._ids.push(cdata);
    },

    validateDatePick : function(){
        $('.datetime-picker').datetimepicker({
            language:  'zh-CN',
            format: 'yyyy-mm-dd',
            autoclose: true,
            todayBtn: true,
            startView: 2,
            minView: 2
        });
    },


    createInput : function(data){
        if(!data) return;
        var id = data.inputIndex;
        var input = null;
        if(data.inputType && data.inputType.toLowerCase() == 'date'){
            input = $('<input id="'+id+'" class="input-min contral-width datetime-picker">');
//            this.validateDatePick(); //,datepicker,addbody
            input.datetimepicker({  //2016-09-21
                language:  'zh-CN',
                format: 'yyyy-mm-dd',
                autoclose: true,
                todayBtn: true,
                startView: 2,
                minView: 2
            });
        }else{
             input = $('<input id="'+id+'" class="input-min contral-width">');
        }
        var style = data.getStyle()||"";
        if(style){
            input.attr('style',style);
        }
        if (data._readonly) {
            input.attr('readonly', 'readonly');
        }
        // this.inputMap[id] = input;
        return input;
    },

    /**
     * cdata
     * @param cdata
     * @param cdata2
     */
    addRow : function(cdata,cdata2){
        if(!cdata && !cdata2) return;
        if (this.className) {
            if (cdata && cdata.inputIndex) {
                cdata.inputIndex = this.className + '_' + cdata.inputIndex;
            }
            if (cdata2 && cdata2.inputIndex) {
                cdata2.inputIndex = this.className + '_' + cdata2.inputIndex;
            }
        }
        var row = this.createRow();
        if(cdata && cdata2){//cdatacdata2
            var id1 = cdata.inputIndex;
            var label1 = cdata.label;
            var labelCol1 = this.createCol(3);
            var h_label = $('<label for="'+id1+'" class="inputpane-label label-min">'+label1+'</label>');
            labelCol1.append(h_label);
            row.append(labelCol1);
            var txtCol1 = this.createCol(4);
            var input1 = this.createInput(cdata);
            this.inputMap[cdata.inputIndex] = input1;
            txtCol1.append(input1);
            row.append(txtCol1);
            input1.keypress(function(event){
                if(event.keyCode === 13){
                    self.doClick();
                }
            });
            this._ids.push(cdata);
            var id2 = cdata2.inputIndex;
            var label2 = cdata2.label;
            var labelCol2 = this.createCol(1,'text-center');
            var h_label2 = $('<label for="'+id2+'" class="inputpane-label label-min">'+label2+'</label>');
            labelCol2.append(h_label2);
            row.append(labelCol2);
            var txtCol2 = this.createCol(4);
            var input2 = this.createInput(cdata2);
            this.inputMap[cdata2.inputIndex] = input2;
            txtCol2.append(input2);
            row.append(txtCol2);
            input2.keypress(function(event){
                if(event.keyCode === 13){
                    self.doClick();
                }
            });
            this.appendRow(row);
            this._ids.push(cdata2);
        }else{
            if(!cdata && cdata2) {
                cdata = cdata2;
            }
            var id = cdata.inputIndex;
            var label = cdata.label;
            var labelCol = this.createCol(3);
            var txtCol = this.createCol(9);
            var h_label = $('<label for="'+id+'" class="inputpane-label label-min">'+label+'</label>');
            labelCol.append(h_label);
            row.append(labelCol);
//        var input = $('<input id="'+id+'" class="input-min contral-width">');
            var input = this.createInput(cdata);
            this.inputMap[cdata.inputIndex] = input;
            var self = this;
            input.keypress(function(event){
                if(event.keyCode === 13){
                    self.doClick();
                }
            });
            txtCol.append(input);
            row.append(txtCol);
            this.appendRow(row);
            this._ids.push(cdata);
        }
    },

    /**
     * typeRack
     * @param cdata
     */
    addConstantCondition : function(cdata){
        if(!cdata){
            this._ids.push(cdata);
        }
    },

    addButtonRow : function(){
        var row = this.createRow();
        var col = this.createCol(12);
        var btnOk = $('<span id="btn_search_it" class="base-panel-search-btn" type="submit" title=" "> </span>');
        var btnClear = $('<span id="btn_cancel_search_it" class="base-panel-search-btn" type="cancel" title=" "> </span>');
        col.append(btnClear);
        col.append(btnOk);
        var self = this;
        btnOk.click(function(){
            self.doClick();
        });
        btnClear.click(function(){
            self.doClear();
        });
        row.append(col);
        this.appendRow(row);
    },

    /**
     * objit.SData
     */
    createSDataByObj: function(data) {
        if (!data) {
            return null;
        }
        var inputIndex = data.inputIndex;
        var inputType = data.inputType;
        var label = data.label;
        var placeholder = data.placeholder;
        var dataType = data.dataType;
        var key = data.key;
        if (!key) {
            return null;
        }
        var sdata = new it.SData(inputIndex, inputType, label, placeholder, dataType);
        sdata.setKey(key);
        sdata.setOperation(data.operation);
        if (data.source) {
            if (data.source instanceof Array) {
                sdata.setClient('options',data.source);
            }else if (this[data.source] && typeof(this[data.source]) == 'function') {
                var options = this[data.source]();
                 sdata.setClient('options',options);
            }
        }
        if (data.style) {
            sdata.setStyle(data.style);
        }
        return sdata;
    },

    getContentPane : function(){
        return this.mainPane;
    },


    getDataValue : function(sdata){
        if(sdata && sdata.inputIndex){
            var id = sdata.inputIndex;
            var inputType = sdata.inputType;
//            if(inputType && inputType.toLowerCase().indexOf('input') < 0){
//                if(inputType.toLowerCase().indexOf('select') >= 0){
//
//                }else if(inputType.toLowerCase().indexOf('checkbox') >= 0){
//
//                }
//            }else{
                var value = $('#'+id).val();
                sdata.setValue(value);
//            }
            if(sdata.toString()){
                return sdata.toString();
            }
        }
        return '';
    },

    getInputValues : function(){
        if(!this._ids) return;
        var contents = [];
        for(var i = 0 ; i < this._ids.length ; i++){
            var data = this._ids[i];
            var obj =  this.getDataValue(data);
            if(obj){
                contents.push(obj);
            }
        }
        return contents;
    },

    getInputHtmlById : function(sid){
        return this.inputMap[this.className + '_' + sid];
    },

    doClick : function(){
        var values = this.getInputValues();
        if(this.doClickFunction){
            this.doClickFunction(values);
        }
    },

    /**
     * 
     */
    clearInputByData : function(id,data){

    },

    clearInput : function(){
        if(!this._ids) return;
        for(var i = 0 ; i < this._ids.length ; i++){
            var data = this._ids[i];
            if(data && data.inputIndex){
                var id = data.inputIndex;
                this.clearInputByData(id,data);
                if(!data || !data.inputType || data.inputType.toLowerCase().indexOf('input') >=0 ){
                    $('#'+id).val('');
                }else{
                    $('#'+id).val('');
                }
            }
        }
    },

    doClear : function(){
        this.clearInput();
        if(this.doClearFunction){
            this.doClearFunction();
        }
    }

});

it.ITSearchPanel = function(){
    it.BasePanel.call(this);
    this.init();
};

mono.extend(it.ITSearchPanel,it.BasePanel,{

    init:function(){
        var sdata = new it.SData('it_key_text',null,null,''); //inputIndex,inputType,label,placeholder
        sdata.setKey('id');
        sdata.setStyle('background: url("./css/images/insidesearch.svg") no-repeat scroll right center;background-position-x: 98%;');
        this.addQuick(sdata);

        sdata = new it.SData('txt_location','select','');
        sdata.setKey('location');
        sdata.setIsClient(true);
        var options = ['','','',''];
        sdata.setClient('options',options);
        this.addRow(sdata);

        sdata = new it.SData('txt_type','select','');
        sdata.setKey('userId');
        sdata.setIsClient(false);
        var options = ['','1','1',''];
        sdata.setClient('options',options);
        this.addRow(sdata);

        sdata = new it.SData('txt_model','input','');
        sdata.setKey('model');
        sdata.setIsClient(true);
        this.addRow(sdata);

        sdata = new it.SData('txt_manu','input','');
        sdata.setKey('userId');
        sdata.setIsClient(true);
        this.addRow(sdata);

        sdata = new it.SData('txt_Type','input','');
        sdata.setKey('userId');
        sdata.setIsClient(true);
        this.addRow(sdata);

//        sdata = new it.SData('test_id001','input','userId');
//        sdata.setKey('userId');
//        sdata.setIsClient(true);
//        sdata.setOperation('like');
//        this.addRow(sdata);
//        sdata = new it.SData('test_id002','select','');
//        sdata.setKey('');
//        sdata.setIsClient(true);
//        sdata.setOperation('like');
//        var options = ['','A','B','C'];
//        sdata.setClient('options',options);

        this.addRow(sdata);
        this.addButtonRow();
    },

    /***
     * select
     * @param data
     * @returns {*}
     */
    createInput : function(data){
        if (data && data.inputType) {
            var inputType = data.inputType;
            var inputId = data.inputIndex;
            if (inputType.toLowerCase().indexOf('select') >= 0) {
                var select = $('<select id="' + inputId + '" class="input-min contral-width"></select>');
                var options = data.getClient('options');
                if (options && options.length > 0) {
                    for (var i = 0; i < options.length; i++) {
                        var value = options[i];
                        var option = $('<option value="' + value + '" class="input-min">'+value+'</option>');
                        select.append(option);
                    }
                }
                this.inputMap[inputId] = select;
                return select;
            }
        }
        return this.constructor.superClass.createInput(data);
    }
});

it.SpaceSearchPanel = function(){
    it.BasePanel.call(this);
    this.className = 'SpaceSearchPanel';
    this.init();
};

mono.extend(it.SpaceSearchPanel,it.BasePanel,{

    init:function(){
        var sdata = new it.SData('U_ID','input','U');
        sdata.setKey('dyna_user_data_maxSerSpace');
        sdata.setIsClient(true);
        sdata.setOperation('>=');
        sdata.setDataType('number');
        this.addRow(sdata);
        this.addButtonRow();
    },

    getUNumber : function(){
        return $('#' + this.className + '_U_ID').val();
    }

});
/*globals jQuery, define, exports, require, window, document, postMessage */
(function (factory) {
//	"use strict";
	if (typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else if(typeof exports === 'object') {
		factory(require('jquery'));
	}
	else {
		factory(jQuery);
	}
}(function ($, undefined) {
//	"use strict";
/*!
 * jsTree 3.1.1
 * http://jstree.com/
 *
 * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
 *
 * Licensed same as jquery - under the terms of the MIT License
 *   http://www.opensource.org/licenses/mit-license.php
 */
/*!
 * if using jslint please allow for the jQuery global and use following options:
 * jslint: browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true
 */

	// prevent another load? maybe there is a better way?
	if($.jstree) {
		return;
	}

	/**
	 * ### jsTree core functionality
	 */

	// internal variables
	var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		ccp_inst = false,
		themes_loaded = [],
		src = $('script:last').attr('src'),
		document = window.document, // local variable is always faster to access then a global
		_node = document.createElement('LI'), _temp1, _temp2;

	_node.setAttribute('role', 'treeitem');
	_temp1 = document.createElement('I');
	_temp1.className = 'jstree-icon jstree-ocl';
	_temp1.setAttribute('role', 'presentation');
	_node.appendChild(_temp1);
	_temp1 = document.createElement('A');
	_temp1.className = 'jstree-anchor';
	_temp1.setAttribute('href','#');
	_temp1.setAttribute('tabindex','-1');
	_temp2 = document.createElement('I');
	_temp2.className = 'jstree-icon jstree-themeicon';
	_temp2.setAttribute('role', 'presentation');
	_temp1.appendChild(_temp2);
	_node.appendChild(_temp1);
	_temp1 = _temp2 = null;


	/**
	 * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
	 * @name $.jstree
	 */
	$.jstree = {
		/**
		 * specifies the jstree version in use
		 * @name $.jstree.version
		 */
		version : '3.1.1',
		/**
		 * holds all the default options used when creating new instances
		 * @name $.jstree.defaults
		 */
		defaults : {
			/**
			 * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
			 * @name $.jstree.defaults.plugins
			 */
			plugins : []
		},
		/**
		 * stores all loaded jstree plugins (used internally)
		 * @name $.jstree.plugins
		 */
		plugins : {},
		path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
		idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g
	};
	/**
	 * creates a jstree instance
	 * @name $.jstree.create(el [, options])
	 * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
	 * @param {Object} options options for this instance (extends `$.jstree.defaults`)
	 * @return {jsTree} the new instance
	 */
	$.jstree.create = function (el, options) {
		var tmp = new $.jstree.core(++instance_counter),
			opt = options;
		options = $.extend(true, {}, $.jstree.defaults, options);
		if(opt && opt.plugins) {
			options.plugins = opt.plugins;
		}
		$.each(options.plugins, function (i, k) {
			if(i !== 'core') {
				tmp = tmp.plugin(k, options[k]);
			}
		});
		$(el).data('jstree', tmp);
		tmp.init(el, options);
		return tmp;
	};
	/**
	 * remove all traces of jstree from the DOM and destroy all instances
	 * @name $.jstree.destroy()
	 */
	$.jstree.destroy = function () {
		$('.jstree:jstree').jstree('destroy');
		$(document).off('.jstree');
	};
	/**
	 * the jstree class constructor, used only internally
	 * @private
	 * @name $.jstree.core(id)
	 * @param {Number} id this instance's index
	 */
	$.jstree.core = function (id) {
		this._id = id;
		this._cnt = 0;
		this._wrk = null;
		this._data = {
			core : {
				themes : {
					name : false,
					dots : false,
					icons : false
				},
				selected : [],
				last_error : {},
				working : false,
				worker_queue : [],
				focused : null
			}
		};
	};
	/**
	 * get a reference to an existing instance
	 *
	 * __Examples__
	 *
	 *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
	 *	// all of there will return the same instance
	 *	$.jstree.reference('tree');
	 *	$.jstree.reference('#tree');
	 *	$.jstree.reference($('#tree'));
	 *	$.jstree.reference(document.getElementByID('tree'));
	 *	$.jstree.reference('branch');
	 *	$.jstree.reference('#branch');
	 *	$.jstree.reference($('#branch'));
	 *	$.jstree.reference(document.getElementByID('branch'));
	 *
	 * @name $.jstree.reference(needle)
	 * @param {DOMElement|jQuery|String} needle
	 * @return {jsTree|null} the instance or `null` if not found
	 */
	$.jstree.reference = function (needle) {
		var tmp = null,
			obj = null;
		if(needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }

		if(!obj || !obj.length) {
			try { obj = $(needle); } catch (ignore) { }
		}
		if(!obj || !obj.length) {
			try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
		}
		if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
			tmp = obj;
		}
		else {
			$('.jstree').each(function () {
				var inst = $(this).data('jstree');
				if(inst && inst._model.data[needle]) {
					tmp = inst;
					return false;
				}
			});
		}
		return tmp;
	};
	/**
	 * Create an instance, get an instance or invoke a command on a instance.
	 *
	 * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
	 *
	 * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
	 *
	 * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
	 *
	 * In any other case - nothing is returned and chaining is not broken.
	 *
	 * __Examples__
	 *
	 *	$('#tree1').jstree(); // creates an instance
	 *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
	 *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
	 *	$('#tree2').jstree(); // get an existing instance (or create an instance)
	 *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
	 *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
	 *
	 * @name $().jstree([arg])
	 * @param {String|Object} arg
	 * @return {Mixed}
	 */
	$.fn.jstree = function (arg) {
		// check for string argument
		var is_method	= (typeof arg === 'string'),
			args		= Array.prototype.slice.call(arguments, 1),
			result		= null;
		if(arg === true && !this.length) { return false; }
		this.each(function () {
			// get the instance (if there is one) and method (if it exists)
			var instance = $.jstree.reference(this),
				method = is_method && instance ? instance[arg] : null;
			// if calling a method, and method is available - execute on the instance
			result = is_method && method ?
				method.apply(instance, args) :
				null;
			// if there is no instance and no method is being called - create one
			if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
				$.jstree.create(this, arg);
			}
			// if there is an instance and no method is called - return the instance
			if( (instance && !is_method) || arg === true ) {
				result = instance || false;
			}
			// if there was a method call which returned a result - break and return the value
			if(result !== null && result !== undefined) {
				return false;
			}
		});
		// if there was a method call with a valid return value - return that, otherwise continue the chain
		return result !== null && result !== undefined ?
			result : this;
	};
	/**
	 * used to find elements containing an instance
	 *
	 * __Examples__
	 *
	 *	$('div:jstree').each(function () {
	 *		$(this).jstree('destroy');
	 *	});
	 *
	 * @name $(':jstree')
	 * @return {jQuery}
	 */
	$.expr[':'].jstree = $.expr.createPseudo(function(search) {
		return function(a) {
			return $(a).hasClass('jstree') &&
				$(a).data('jstree') !== undefined;
		};
	});

	/**
	 * stores all defaults for the core
	 * @name $.jstree.defaults.core
	 */
	$.jstree.defaults.core = {
		/**
		 * data configuration
		 *
		 * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
		 *
		 * You can also pass in a HTML string or a JSON array here.
		 *
		 * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.
		 * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
		 *
		 * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
		 *
		 * __Examples__
		 *
		 *	// AJAX
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : {
		 *				'url' : '/get/children/',
		 *				'data' : function (node) {
		 *					return { 'id' : node.id };
		 *				}
		 *			}
		 *		});
		 *
		 *	// direct data
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : [
		 *				'Simple root node',
		 *				{
		 *					'id' : 'node_2',
		 *					'text' : 'Root node with options',
		 *					'state' : { 'opened' : true, 'selected' : true },
		 *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
		 *				}
		 *			]
		 *		});
		 *
		 *	// function
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : function (obj, callback) {
		 *				callback.call(this, ['Root 1', 'Root 2']);
		 *			}
		 *		});
		 *
		 * @name $.jstree.defaults.core.data
		 */
		data			: false,
		/**
		 * configure the various strings used throughout the tree
		 *
		 * You can use an object where the key is the string you need to replace and the value is your replacement.
		 * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
		 * If left as `false` no replacement is made.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'strings' : {
		 *				'Loading ...' : 'Please wait ...'
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.strings
		 */
		strings			: false,
		/**
		 * determines what happens when a user tries to modify the structure of the tree
		 * If left as `false` all operations like create, rename, delete, move or copy are prevented.
		 * You can set this to `true` to allow all interactions or use a function to have better control.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'check_callback' : function (operation, node, node_parent, node_position, more) {
		 *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'
		 *				// in case of 'rename_node' node_position is filled with the new node name
		 *				return operation === 'rename_node' ? true : false;
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.check_callback
		 */
		check_callback	: false,
		/**
		 * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
		 * @name $.jstree.defaults.core.error
		 */
		error			: $.noop,
		/**
		 * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
		 * @name $.jstree.defaults.core.animation
		 */
		animation		: 200,
		/**
		 * a boolean indicating if multiple nodes can be selected
		 * @name $.jstree.defaults.core.multiple
		 */
		multiple		: true,
		/**
		 * theme configuration object
		 * @name $.jstree.defaults.core.themes
		 */
		themes			: {
			/**
			 * the name of the theme to use (if left as `false` the default theme is used)
			 * @name $.jstree.defaults.core.themes.name
			 */
			name			: false,
			/**
			 * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
			 * @name $.jstree.defaults.core.themes.url
			 */
			url				: false,
			/**
			 * the location of all jstree themes - only used if `url` is set to `true`
			 * @name $.jstree.defaults.core.themes.dir
			 */
			dir				: false,
			/**
			 * a boolean indicating if connecting dots are shown
			 * @name $.jstree.defaults.core.themes.dots
			 */
			dots			: true,
			/**
			 * a boolean indicating if node icons are shown
			 * @name $.jstree.defaults.core.themes.icons
			 */
			icons			: true,
			/**
			 * a boolean indicating if the tree background is striped
			 * @name $.jstree.defaults.core.themes.stripes
			 */
			stripes			: false,
			/**
			 * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
			 * @name $.jstree.defaults.core.themes.variant
			 */
			variant			: false,
			/**
			 * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
			 * @name $.jstree.defaults.core.themes.responsive
			 */
			responsive		: false
		},
		/**
		 * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
		 * @name $.jstree.defaults.core.expand_selected_onload
		 */
		expand_selected_onload : true,
		/**
		 * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
		 * @name $.jstree.defaults.core.worker
		 */
		worker : true,
		/**
		 * Force node text to plain text (and escape HTML). Defaults to `false`
		 * @name $.jstree.defaults.core.force_text
		 */
		force_text : false,
		/**
		 * Should the node should be toggled if the text is double clicked . Defaults to `true`
		 * @name $.jstree.defaults.core.dblclick_toggle
		 */
		dblclick_toggle : true
	};
	$.jstree.core.prototype = {
		/**
		 * used to decorate an instance with a plugin. Used internally.
		 * @private
		 * @name plugin(deco [, opts])
		 * @param  {String} deco the plugin to decorate with
		 * @param  {Object} opts options for the plugin
		 * @return {jsTree}
		 */
		plugin : function (deco, opts) {
			var Child = $.jstree.plugins[deco];
			if(Child) {
				this._data[deco] = {};
				Child.prototype = this;
				return new Child(opts, this);
			}
			return this;
		},
		/**
		 * initialize the instance. Used internally.
		 * @private
		 * @name init(el, optons)
		 * @param {DOMElement|jQuery|String} el the element we are transforming
		 * @param {Object} options options for this instance
		 * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
		 */
		init : function (el, options) {
			this._model = {
				data : {
					'#' : {
						id : '#',
						parent : null,
						parents : [],
						children : [],
						children_d : [],
						state : { loaded : false }
					}
				},
				changed : [],
				force_full_redraw : false,
				redraw_timeout : false,
				default_state : {
					loaded : true,
					opened : false,
					selected : false,
					disabled : false
				}
			};

			this.element = $(el).addClass('jstree jstree-' + this._id);
			this.settings = options;

			this._data.core.ready = false;
			this._data.core.loaded = false;
			this._data.core.rtl = (this.element.css("direction") === "rtl");
			this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
			this.element.attr('role','tree');
			if(this.settings.core.multiple) {
				this.element.attr('aria-multiselectable', true);
			}
			if(!this.element.attr('tabindex')) {
				this.element.attr('tabindex','0');
			}

			this.bind();
			/**
			 * triggered after all events are bound
			 * @event
			 * @name init.jstree
			 */
			this.trigger("init");

			this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
			this._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function() {
					return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
			this.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+this._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
			this.element.attr('aria-activedescendant','j' + this._id + '_loading');
			this._data.core.li_height = this.get_container_ul().children("li").first().height() || 24;
			/**
			 * triggered after the loading text is shown and before loading starts
			 * @event
			 * @name loading.jstree
			 */
			this.trigger("loading");
			this.load_node('#');
		},
		/**
		 * destroy an instance
		 * @name destroy()
		 * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
		 */
		destroy : function (keep_html) {
			if(this._wrk) {
				try {
					window.URL.revokeObjectURL(this._wrk);
					this._wrk = null;
				}
				catch (ignore) { }
			}
			if(!keep_html) { this.element.empty(); }
			this.teardown();
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name teardown()
		 */
		teardown : function () {
			this.unbind();
			this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
			this.element = null;
		},
		/**
		 * bind all events. Used internally.
		 * @private
		 * @name bind()
		 */
		bind : function () {
			var word = '',
				tout = null,
				was_click = 0;
			this.element
				.on("dblclick.jstree", function () {
						if(document.selection && document.selection.empty) {
							document.selection.empty();
						}
						else {
							if(window.getSelection) {
								var sel = window.getSelection();
								try {
									sel.removeAllRanges();
									sel.collapse();
								} catch (ignore) { }
							}
						}
					})
				.on("mousedown.jstree", $.proxy(function (e) {
						if(e.target === this.element[0]) {
							e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
							was_click = +(new Date()); // ie does not allow to prevent losing focus
						}
					}, this))
				.on("mousedown.jstree", ".jstree-ocl", function (e) {
						e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
					})
				.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
						this.toggle_node(e.target);
					}, this))
				.on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this.settings.core.dblclick_toggle) {
							this.toggle_node(e.target);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						e.preventDefault();
						if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
						this.activate_node(e.currentTarget, e);
					}, this))
				.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
						if(e.target.tagName === "INPUT") { return true; }
						if(e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) { return true; }
						var o = null;
						if(this._data.core.rtl) {
							if(e.which === 37) { e.which = 39; }
							else if(e.which === 39) { e.which = 37; }
						}
						switch(e.which) {
							case 32: // aria defines space only with Ctrl
								if(e.ctrlKey) {
									e.type = "click";
									$(e.currentTarget).trigger(e);
								}
								break;
							case 13: // enter
								e.type = "click";
								$(e.currentTarget).trigger(e);
								break;
							case 37: // right
								e.preventDefault();
								if(this.is_open(e.currentTarget)) {
									this.close_node(e.currentTarget);
								}
								else {
									o = this.get_parent(e.currentTarget);
									if(o && o.id !== '#') { this.get_node(o, true).children('.jstree-anchor').focus(); }
								}
								break;
							case 38: // up
								e.preventDefault();
								o = this.get_prev_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 39: // left
								e.preventDefault();
								if(this.is_closed(e.currentTarget)) {
									this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
								}
								else if (this.is_open(e.currentTarget)) {
									o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
									if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
								}
								break;
							case 40: // down
								e.preventDefault();
								o = this.get_next_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 106: // aria defines * on numpad as open_all - not very common
								this.open_all();
								break;
							case 36: // home
								e.preventDefault();
								o = this._firstChild(this.get_container_ul()[0]);
								if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
								break;
							case 35: // end
								e.preventDefault();
								this.element.find('.jstree-anchor').filter(':visible').last().focus();
								break;
							/*
							// delete
							case 46:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== '#') {
									o = this.is_selected(o) ? this.get_selected() : o;
									this.delete_node(o);
								}
								break;
							// f2
							case 113:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== '#') {
									// this.edit(o);
								}
								break;
							default:
								// console.log(e.which);
								break;
							*/
						}
					}, this))
				.on("load_node.jstree", $.proxy(function (e, data) {
						if(data.status) {
							if(data.node.id === '#' && !this._data.core.loaded) {
								this._data.core.loaded = true;
								if(this._firstChild(this.get_container_ul()[0])) {
									this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
								}
								/**
								 * triggered after the root node is loaded for the first time
								 * @event
								 * @name loaded.jstree
								 */
								this.trigger("loaded");
							}
							if(!this._data.core.ready) {
								setTimeout($.proxy(function() {
									if(this.element && !this.get_container_ul().find('.jstree-loading').length) {
										this._data.core.ready = true;
										if(this._data.core.selected.length) {
											if(this.settings.core.expand_selected_onload) {
												var tmp = [], i, j;
												for(i = 0, j = this._data.core.selected.length; i < j; i++) {
													tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
												}
												tmp = $.vakata.array_unique(tmp);
												for(i = 0, j = tmp.length; i < j; i++) {
													this.open_node(tmp[i], false, 0);
												}
											}
											this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
										}
										/**
										 * triggered after all nodes are finished loading
										 * @event
										 * @name ready.jstree
										 */
										this.trigger("ready");
									}
								}, this), 0);
							}
						}
					}, this))
				// quick searching when the tree is focused
				.on('keypress.jstree', $.proxy(function (e) {
						if(e.target.tagName === "INPUT") { return true; }
						if(tout) { clearTimeout(tout); }
						tout = setTimeout(function () {
							word = '';
						}, 500);

						var chr = String.fromCharCode(e.which).toLowerCase(),
							col = this.element.find('.jstree-anchor').filter(':visible'),
							ind = col.index(document.activeElement) || 0,
							end = false;
						word += chr;

						// match for whole word from current node down (including the current node)
						if(word.length > 1) {
							col.slice(ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// match for whole word from the beginning of the tree
							col.slice(0, ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
						// list nodes that start with that letter (only if word consists of a single char)
						if(new RegExp('^' + chr + '+$').test(word)) {
							// search for the next node starting with that letter
							col.slice(ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// search from the beginning
							col.slice(0, ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
					}, this))
				// THEME RELATED
				.on("init.jstree", $.proxy(function () {
						var s = this.settings.core.themes;
						this._data.core.themes.dots			= s.dots;
						this._data.core.themes.stripes		= s.stripes;
						this._data.core.themes.icons		= s.icons;
						this.set_theme(s.name || "default", s.url);
						this.set_theme_variant(s.variant);
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
						this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
						this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
					}, this))
				.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
						this._data.core.focused = null;
						$(e.currentTarget).filter('.jstree-hovered').mouseleave();
						this.element.attr('tabindex', '0');
					}, this))
				.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
						var tmp = this.get_node(e.currentTarget);
						if(tmp && tmp.id) {
							this._data.core.focused = tmp.id;
						}
						this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
						$(e.currentTarget).mouseenter();
						this.element.attr('tabindex', '-1');
					}, this))
				.on('focus.jstree', $.proxy(function () {
						if(+(new Date()) - was_click > 500 && !this._data.core.focused) {
							was_click = 0;
							var act = this.get_node(this.element.attr('aria-activedescendant'), true);
							if(act) {
								act.find('> .jstree-anchor').focus();
							}
						}
					}, this))
				.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.hover_node(e.currentTarget);
					}, this))
				.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name unbind()
		 */
		unbind : function () {
			this.element.off('.jstree');
			$(document).off('.jstree-' + this._id);
		},
		/**
		 * trigger an event. Used internally.
		 * @private
		 * @name trigger(ev [, data])
		 * @param  {String} ev the name of the event to trigger
		 * @param  {Object} data additional data to pass with the event
		 */
		trigger : function (ev, data) {
			if(!data) {
				data = {};
			}
			data.instance = this;
			this.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);
		},
		/**
		 * returns the jQuery extended instance container
		 * @name get_container()
		 * @return {jQuery}
		 */
		get_container : function () {
			return this.element;
		},
		/**
		 * returns the jQuery extended main UL node inside the instance container. Used internally.
		 * @private
		 * @name get_container_ul()
		 * @return {jQuery}
		 */
		get_container_ul : function () {
			return this.element.children(".jstree-children").first();
		},
		/**
		 * gets string replacements (localization). Used internally.
		 * @private
		 * @name get_string(key)
		 * @param  {String} key
		 * @return {String}
		 */
		get_string : function (key) {
			var a = this.settings.core.strings;
			if($.isFunction(a)) { return a.call(this, key); }
			if(a && a[key]) { return a[key]; }
			return key;
		},
		/**
		 * gets the first child of a DOM node. Used internally.
		 * @private
		 * @name _firstChild(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_firstChild : function (dom) {
			dom = dom ? dom.firstChild : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the next sibling of a DOM node. Used internally.
		 * @private
		 * @name _nextSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_nextSibling : function (dom) {
			dom = dom ? dom.nextSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the previous sibling of a DOM node. Used internally.
		 * @private
		 * @name _previousSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_previousSibling : function (dom) {
			dom = dom ? dom.previousSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.previousSibling;
			}
			return dom;
		},
		/**
		 * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
		 * @name get_node(obj [, as_dom])
		 * @param  {mixed} obj
		 * @param  {Boolean} as_dom
		 * @return {Object|jQuery}
		 */
		get_node : function (obj, as_dom) {
			if(obj && obj.id) {
				obj = obj.id;
			}
			var dom;
			try {
				if(this._model.data[obj]) {
					obj = this._model.data[obj];
				}
				else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
					obj = this._model.data[obj.replace(/^#/, '')];
				}
				else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
					obj = this._model.data['#'];
				}
				else {
					return false;
				}

				if(as_dom) {
					obj = obj.id === '#' ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
				}
				return obj;
			} catch (ex) { return false; }
		},
		/**
		 * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
		 * @name get_path(obj [, glue, ids])
		 * @param  {mixed} obj the node
		 * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
		 * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
		 * @return {mixed}
		 */
		get_path : function (obj, glue, ids) {
			obj = obj.parents ? obj : this.get_node(obj);
			if(!obj || obj.id === '#' || !obj.parents) {
				return false;
			}
			var i, j, p = [];
			p.push(ids ? obj.id : obj.text);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
			}
			p = p.reverse().slice(1);
			return glue ? p.join(glue) : p;
		},
		/**
		 * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_next_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_next_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this._firstChild(this.get_container_ul()[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._nextSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			if(obj.hasClass("jstree-open")) {
				tmp = this._firstChild(obj.children('.jstree-children')[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				if(tmp !== null) {
					return $(tmp);
				}
			}
			tmp = obj[0];
			do {
				tmp = this._nextSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				return $(tmp);
			}
			return obj.parentsUntil(".jstree",".jstree-node").nextAll(".jstree-node:visible").first();
		},
		/**
		 * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_prev_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_prev_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this.get_container_ul()[0].lastChild;
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._previousSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._previousSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			tmp = obj[0];
			do {
				tmp = this._previousSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				obj = $(tmp);
				while(obj.hasClass("jstree-open")) {
					obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
				}
				return obj;
			}
			tmp = obj[0].parentNode.parentNode;
			return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
		},
		/**
		 * get the parent ID of a node
		 * @name get_parent(obj)
		 * @param  {mixed} obj
		 * @return {String}
		 */
		get_parent : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			return obj.parent;
		},
		/**
		 * get a jQuery collection of all the children of a node (node must be rendered)
		 * @name get_children_dom(obj)
		 * @param  {mixed} obj
		 * @return {jQuery}
		 */
		get_children_dom : function (obj) {
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				return this.get_container_ul().children(".jstree-node");
			}
			if(!obj || !obj.length) {
				return false;
			}
			return obj.children(".jstree-children").children(".jstree-node");
		},
		/**
		 * checks if a node has children
		 * @name is_parent(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_parent : function (obj) {
			obj = this.get_node(obj);
			return obj && (obj.state.loaded === false || obj.children.length > 0);
		},
		/**
		 * checks if a node is loaded (its children are available)
		 * @name is_loaded(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loaded : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.loaded;
		},
		/**
		 * check if a node is currently loading (fetching children)
		 * @name is_loading(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loading : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.loading;
		},
		/**
		 * check if a node is opened
		 * @name is_open(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_open : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.opened;
		},
		/**
		 * check if a node is in a closed state
		 * @name is_closed(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_closed : function (obj) {
			obj = this.get_node(obj);
			return obj && this.is_parent(obj) && !obj.state.opened;
		},
		/**
		 * check if a node has no children
		 * @name is_leaf(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_leaf : function (obj) {
			return !this.is_parent(obj);
		},
		/**
		 * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
		 * @name load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
		 * @return {Boolean}
		 * @trigger load_node.jstree
		 */
		load_node : function (obj, callback) {
			var k, l, i, j, c;
			if($.isArray(obj)) {
				this._load_nodes(obj.slice(), callback);
				return true;
			}
			obj = this.get_node(obj);
			if(!obj) {
				if(callback) { callback.call(this, obj, false); }
				return false;
			}
			// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
			if(obj.state.loaded) {
				obj.state.loaded = false;
				for(k = 0, l = obj.children_d.length; k < l; k++) {
					for(i = 0, j = obj.parents.length; i < j; i++) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_remove_item(this._model.data[obj.parents[i]].children_d, obj.children_d[k]);
					}
					if(this._model.data[obj.children_d[k]].state.selected) {
						c = true;
						this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.children_d[k]);
					}
					delete this._model.data[obj.children_d[k]];
				}
				obj.children = [];
				obj.children_d = [];
				if(c) {
					this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
				}
			}
			obj.state.failed = false;
			obj.state.loading = true;
			this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
			this._load_node(obj, $.proxy(function (status) {
				obj = this._model.data[obj.id];
				obj.state.loading = false;
				obj.state.loaded = status;
				obj.state.failed = !obj.state.loaded;
				var dom = this.get_node(obj, true);
				if(obj.state.loaded && !obj.children.length && dom && dom.length && !dom.hasClass('jstree-leaf')) {
					dom.removeClass('jstree-closed jstree-open').addClass('jstree-leaf');
				}
				dom.removeClass("jstree-loading").attr('aria-busy',false);
				/**
				 * triggered after a node is loaded
				 * @event
				 * @name load_node.jstree
				 * @param {Object} node the node that was loading
				 * @param {Boolean} status was the node loaded successfully
				 */
				this.trigger('load_node', { "node" : obj, "status" : status });
				if(callback) {
					callback.call(this, obj, status);
				}
			}, this));
			return true;
		},
		/**
		 * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
		 * @private
		 * @name _load_nodes(nodes [, callback])
		 * @param  {array} nodes
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
		 */
		_load_nodes : function (nodes, callback, is_callback) {
			var r = true,
				c = function () { this._load_nodes(nodes, callback, true); },
				m = this._model.data, i, j, tmp = [];
			for(i = 0, j = nodes.length; i < j; i++) {
				if(m[nodes[i]] && ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || !is_callback)) {
					if(!this.is_loading(nodes[i])) {
						this.load_node(nodes[i], c);
					}
					r = false;
				}
			}
			if(r) {
				for(i = 0, j = nodes.length; i < j; i++) {
					if(m[nodes[i]] && m[nodes[i]].state.loaded) {
						tmp.push(nodes[i]);
					}
				}
				if(callback && !callback.done) {
					callback.call(this, tmp);
					callback.done = true;
				}
			}
		},
		/**
		 * loads all unloaded nodes
		 * @name load_all([obj, callback])
		 * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
		 * @param {function} callback a function to be executed once loading all the nodes is complete,
		 * @trigger load_all.jstree
		 */
		load_all : function (obj, callback) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var to_load = [],
				m = this._model.data,
				c = m[obj.id].children_d,
				i, j;
			if(obj.state && !obj.state.loaded) {
				to_load.push(obj.id);
			}
			for(i = 0, j = c.length; i < j; i++) {
				if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
					to_load.push(c[i]);
				}
			}
			if(to_load.length) {
				this._load_nodes(to_load, function () {
					this.load_all(obj, callback);
				});
			}
			else {
				/**
				 * triggered after a load_all call completes
				 * @event
				 * @name load_all.jstree
				 * @param {Object} node the recursively loaded node
				 */
				if(callback) { callback.call(this, obj); }
				this.trigger('load_all', { "node" : obj });
			}
		},
		/**
		 * handles the actual loading of a node. Used only internally.
		 * @private
		 * @name _load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
		 * @return {Boolean}
		 */
		_load_node : function (obj, callback) {
			var s = this.settings.core.data, t;
			// use original HTML
			if(!s) {
				if(obj.id === '#') {
					return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
						callback.call(this, status);
					});
				}
				else {
					return callback.call(this, false);
				}
				// return callback.call(this, obj.id === '#' ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
			}
			if($.isFunction(s)) {
				return s.call(this, obj, $.proxy(function (d) {
					if(d === false) {
						callback.call(this, false);
					}
					this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(function () { return this.nodeType !== 3; }) : d, function (status) {
						callback.call(this, status);
					});
					// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
				}, this));
			}
			if(typeof s === 'object') {
				if(s.url) {
					s = $.extend(true, {}, s);
					if($.isFunction(s.url)) {
						s.url = s.url.call(this, obj);
					}
					if($.isFunction(s.data)) {
						s.data = s.data.call(this, obj);
					}
					return $.ajax(s)
						.done($.proxy(function (d,t,x) {
								var type = x.getResponseHeader('Content-Type');
								if((type && type.indexOf('json') !== -1) || typeof d === "object") {
									return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
									//return callback.call(this, this._append_json_data(obj, d));
								}
								if((type && type.indexOf('html') !== -1) || typeof d === "string") {
									return this._append_html_data(obj, $($.parseHTML(d)).filter(function () { return this.nodeType !== 3; }), function (status) { callback.call(this, status); });
									// return callback.call(this, this._append_html_data(obj, $(d)));
								}
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
								this.settings.core.error.call(this, this._data.core.last_error);
								return callback.call(this, false);
							}, this))
						.fail($.proxy(function (f) {
								callback.call(this, false);
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
								this.settings.core.error.call(this, this._data.core.last_error);
							}, this));
				}
				t = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;
				if(obj.id === '#') {
					return this._append_json_data(obj, t, function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === "#" ? this._append_json_data(obj, t) : false) );
			}
			if(typeof s === 'string') {
				if(obj.id === '#') {
					return this._append_html_data(obj, $($.parseHTML(s)).filter(function () { return this.nodeType !== 3; }), function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === "#" ? this._append_html_data(obj, $(s)) : false) );
			}
			return callback.call(this, false);
		},
		/**
		 * adds a node to the list of nodes to redraw. Used only internally.
		 * @private
		 * @name _node_changed(obj [, callback])
		 * @param  {mixed} obj
		 */
		_node_changed : function (obj) {
			obj = this.get_node(obj);
			if(obj) {
				this._model.changed.push(obj.id);
			}
		},
		/**
		 * appends HTML content to the tree. Used internally.
		 * @private
		 * @name _append_html_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the HTML string to parse and append
		 * @trigger model.jstree, changed.jstree
		 */
		_append_html_data : function (dom, data, cb) {
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			var dat = data.is('ul') ? data.children() : data,
				par = dom.id,
				chd = [],
				dpc = [],
				m = this._model.data,
				p = m[par],
				s = this._data.core.selected.length,
				tmp, i, j;
			dat.each($.proxy(function (i, v) {
				tmp = this._parse_model_from_html($(v), par, p.parents.concat());
				if(tmp) {
					chd.push(tmp);
					dpc.push(tmp);
					if(m[tmp].children_d.length) {
						dpc = dpc.concat(m[tmp].children_d);
					}
				}
			}, this));
			p.children = chd;
			p.children_d = dpc;
			for(i = 0, j = p.parents.length; i < j; i++) {
				m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
			}
			/**
			 * triggered when new data is inserted to the tree model
			 * @event
			 * @name model.jstree
			 * @param {Array} nodes an array of node IDs
			 * @param {String} parent the parent ID of the nodes
			 */
			this.trigger('model', { "nodes" : dpc, 'parent' : par });
			if(par !== '#') {
				this._node_changed(par);
				this.redraw();
			}
			else {
				this.get_container_ul().children('.jstree-initial-node').remove();
				this.redraw(true);
			}
			if(this._data.core.selected.length !== s) {
				this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
			}
			cb.call(this, true);
		},
		/**
		 * appends JSON content to the tree. Used internally.
		 * @private
		 * @name _append_json_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the JSON object to parse and append
		 * @param  {Boolean} force_processing internal param - do not set
		 * @trigger model.jstree, changed.jstree
		 */
		_append_json_data : function (dom, data, cb, force_processing) {
			if(this.element === null) { return; }
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			// *%$@!!!
			if(data.d) {
				data = data.d;
				if(typeof data === "string") {
					data = JSON.parse(data);
				}
			}
			if(!$.isArray(data)) { data = [data]; }
			var w = null,
				args = {
					'df'	: this._model.default_state,
					'dat'	: data,
					'par'	: dom.id,
					'm'		: this._model.data,
					't_id'	: this._id,
					't_cnt'	: this._cnt,
					'sel'	: this._data.core.selected
				},
				func = function (data, undefined) {
					if(data.data) { data = data.data; }
					var dat = data.dat,
						par = data.par,
						chd = [],
						dpc = [],
						add = [],
						df = data.df,
						t_id = data.t_id,
						t_cnt = data.t_cnt,
						m = data.m,
						p = m[par],
						sel = data.sel,
						tmp, i, j, rslt,
						parse_flat = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = d.id.toString(),
								i, j, c, e,
								tmp = {
									id			: tid,
									text		: d.text || '',
									icon		: d.icon !== undefined ? d.icon : true,
									parent		: p,
									parents		: ps,
									children	: d.children || [],
									children_d	: d.children_d || [],
									data		: d.data,
									state		: { },
									li_attr		: { id : false },
									a_attr		: { href : '#' },
									original	: false
								};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tid;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							m[tmp.id] = tmp;
							for(i = 0, j = tmp.children.length; i < j; i++) {
								c = parse_flat(m[tmp.children[i]], tmp.id, ps);
								e = m[c];
								tmp.children_d.push(c);
								if(e.children_d.length) {
									tmp.children_d = tmp.children_d.concat(e.children_d);
								}
							}
							delete d.data;
							delete d.children;
							m[tmp.id].original = d;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						},
						parse_nest = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = false, i, j, c, e, tmp;
							do {
								tid = 'j' + t_id + '_' + (++t_cnt);
							} while(m[tid]);

							tmp = {
								id			: false,
								text		: typeof d === 'string' ? d : '',
								icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
								parent		: p,
								parents		: ps,
								children	: [],
								children_d	: [],
								data		: null,
								state		: { },
								li_attr		: { id : false },
								a_attr		: { href : '#' },
								original	: false
							};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.id) { tmp.id = d.id.toString(); }
							if(d && d.text) { tmp.text = d.text; }
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(tmp.li_attr.id && !tmp.id) {
								tmp.id = tmp.li_attr.id.toString();
							}
							if(!tmp.id) {
								tmp.id = tid;
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tmp.id;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children.length) {
								for(i = 0, j = d.children.length; i < j; i++) {
									c = parse_nest(d.children[i], tmp.id, ps);
									e = m[c];
									tmp.children.push(c);
									if(e.children_d.length) {
										tmp.children_d = tmp.children_d.concat(e.children_d);
									}
								}
								tmp.children_d = tmp.children_d.concat(tmp.children);
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							delete d.data;
							delete d.children;
							tmp.original = d;
							m[tmp.id] = tmp;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						};

					if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
						// Flat JSON support (for easy import from DB):
						// 1) convert to object (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							if(!dat[i].children) {
								dat[i].children = [];
							}
							m[dat[i].id.toString()] = dat[i];
						}
						// 2) populate children (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							m[dat[i].parent.toString()].children.push(dat[i].id.toString());
							// populate parent.children_d
							p.children_d.push(dat[i].id.toString());
						}
						// 3) normalize && populate parents and children_d with recursion
						for(i = 0, j = p.children.length; i < j; i++) {
							tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
							dpc.push(tmp);
							if(m[tmp].children_d.length) {
								dpc = dpc.concat(m[tmp].children_d);
							}
						}
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					else {
						for(i = 0, j = dat.length; i < j; i++) {
							tmp = parse_nest(dat[i], par, p.parents.concat());
							if(tmp) {
								chd.push(tmp);
								dpc.push(tmp);
								if(m[tmp].children_d.length) {
									dpc = dpc.concat(m[tmp].children_d);
								}
							}
						}
						p.children = chd;
						p.children_d = dpc;
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					if(typeof window === 'undefined' || typeof window.document === 'undefined') {
						postMessage(rslt);
					}
					else {
						return rslt;
					}
				},
				rslt = function (rslt, worker) {
					if(this.element === null) { return; }
					this._cnt = rslt.cnt;
					this._model.data = rslt.mod; // breaks the reference in load_node - careful

					if(worker) {
						var i, j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice(), m = this._model.data;
						// if selection was changed while calculating in worker
						if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
							// deselect nodes that are no longer selected
							for(i = 0, j = r.length; i < j; i++) {
								if($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
									m[r[i]].state.selected = false;
								}
							}
							// select nodes that were selected in the mean time
							for(i = 0, j = s.length; i < j; i++) {
								if($.inArray(s[i], r) === -1) {
									m[s[i]].state.selected = true;
								}
							}
						}
					}
					if(rslt.add.length) {
						this._data.core.selected = this._data.core.selected.concat(rslt.add);
					}

					this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });

					if(rslt.par !== '#') {
						this._node_changed(rslt.par);
						this.redraw();
					}
					else {
						// this.get_container_ul().children('.jstree-initial-node').remove();
						this.redraw(true);
					}
					if(rslt.add.length) {
						this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
					}
					cb.call(this, true);
				};
			if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
				try {
					if(this._wrk === null) {
						this._wrk = window.URL.createObjectURL(
							new window.Blob(
								['self.onmessage = ' + func.toString()],
								{type:"text/javascript"}
							)
						);
					}
					if(!this._data.core.working || force_processing) {
						this._data.core.working = true;
						w = new window.Worker(this._wrk);
						w.onmessage = $.proxy(function (e) {
							rslt.call(this, e.data, true);
							try { w.terminate(); w = null; } catch(ignore) { }
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}, this);
						if(!args.par) {
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}
						else {
							w.postMessage(args);
						}
					}
					else {
						this._data.core.worker_queue.push([dom, data, cb, true]);
					}
				}
				catch(e) {
					rslt.call(this, func(args), false);
					if(this._data.core.worker_queue.length) {
						this._append_json_data.apply(this, this._data.core.worker_queue.shift());
					}
					else {
						this._data.core.working = false;
					}
				}
			}
			else {
				rslt.call(this, func(args), false);
			}
		},
		/**
		 * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_html(d [, p, ps])
		 * @param  {jQuery} d the jQuery object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_html : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = [].concat(ps); }
			if(p) { ps.unshift(p); }
			var c, e, m = this._model.data,
				data = {
					id			: false,
					text		: false,
					icon		: true,
					parent		: p,
					parents		: ps,
					children	: [],
					children_d	: [],
					data		: null,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				}, i, tmp, tid;
			for(i in this._model.default_state) {
				if(this._model.default_state.hasOwnProperty(i)) {
					data.state[i] = this._model.default_state[i];
				}
			}
			tmp = $.vakata.attributes(d, true);
			$.each(tmp, function (i, v) {
				v = $.trim(v);
				if(!v.length) { return true; }
				data.li_attr[i] = v;
				if(i === 'id') {
					data.id = v.toString();
				}
			});
			tmp = d.children('a').first();
			if(tmp.length) {
				tmp = $.vakata.attributes(tmp, true);
				$.each(tmp, function (i, v) {
					v = $.trim(v);
					if(v.length) {
						data.a_attr[i] = v;
					}
				});
			}
			tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
			tmp.children("ins, i, ul").remove();
			tmp = tmp.html();
			tmp = $('<div />').html(tmp);
			data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
			tmp = d.data();
			data.data = tmp ? $.extend(true, {}, tmp) : null;
			data.state.opened = d.hasClass('jstree-open');
			data.state.selected = d.children('a').hasClass('jstree-clicked');
			data.state.disabled = d.children('a').hasClass('jstree-disabled');
			if(data.data && data.data.jstree) {
				for(i in data.data.jstree) {
					if(data.data.jstree.hasOwnProperty(i)) {
						data.state[i] = data.data.jstree[i];
					}
				}
			}
			tmp = d.children("a").children(".jstree-themeicon");
			if(tmp.length) {
				data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
			}
			if(data.state.icon !== undefined) {
				data.icon = data.state.icon;
			}
			if(data.icon === undefined || data.icon === null || data.icon === "") {
				data.icon = true;
			}
			tmp = d.children("ul").children("li");
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);
			data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
			if(tmp.length) {
				tmp.each($.proxy(function (i, v) {
					c = this._parse_model_from_html($(v), data.id, ps);
					e = this._model.data[c];
					data.children.push(c);
					if(e.children_d.length) {
						data.children_d = data.children_d.concat(e.children_d);
					}
				}, this));
				data.children_d = data.children_d.concat(data.children);
			}
			else {
				if(d.hasClass('jstree-closed')) {
					data.state.loaded = false;
				}
			}
			if(data.li_attr['class']) {
				data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
			}
			if(data.a_attr['class']) {
				data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
			}
			m[data.id] = data;
			if(data.state.selected) {
				this._data.core.selected.push(data.id);
			}
			return data.id;
		},
		/**
		 * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_flat_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_flat_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = d.id.toString(),
				m = this._model.data,
				df = this._model.default_state,
				i, j, c, e,
				tmp = {
					id			: tid,
					text		: d.text || '',
					icon		: d.icon !== undefined ? d.icon : true,
					parent		: p,
					parents		: ps,
					children	: d.children || [],
					children_d	: d.children_d || [],
					data		: d.data,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tid;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			m[tmp.id] = tmp;
			for(i = 0, j = tmp.children.length; i < j; i++) {
				c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
				e = m[c];
				tmp.children_d.push(c);
				if(e.children_d.length) {
					tmp.children_d = tmp.children_d.concat(e.children_d);
				}
			}
			delete d.data;
			delete d.children;
			m[tmp.id].original = d;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);

			tmp = {
				id			: false,
				text		: typeof d === 'string' ? d : '',
				icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
				parent		: p,
				parents		: ps,
				children	: [],
				children_d	: [],
				data		: null,
				state		: { },
				li_attr		: { id : false },
				a_attr		: { href : '#' },
				original	: false
			};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.id) { tmp.id = d.id.toString(); }
			if(d && d.text) { tmp.text = d.text; }
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(tmp.li_attr.id && !tmp.id) {
				tmp.id = tmp.li_attr.id.toString();
			}
			if(!tmp.id) {
				tmp.id = tid;
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tmp.id;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children.length) {
				for(i = 0, j = d.children.length; i < j; i++) {
					c = this._parse_model_from_json(d.children[i], tmp.id, ps);
					e = m[c];
					tmp.children.push(c);
					if(e.children_d.length) {
						tmp.children_d = tmp.children_d.concat(e.children_d);
					}
				}
				tmp.children_d = tmp.children_d.concat(tmp.children);
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			delete d.data;
			delete d.children;
			tmp.original = d;
			m[tmp.id] = tmp;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * redraws all nodes that need to be redrawn. Used internally.
		 * @private
		 * @name _redraw()
		 * @trigger redraw.jstree
		 */
		_redraw : function () {
			var nodes = this._model.force_full_redraw ? this._model.data['#'].children.concat([]) : this._model.changed.concat([]),
				f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
			for(i = 0, j = nodes.length; i < j; i++) {
				tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
				if(tmp && this._model.force_full_redraw) {
					f.appendChild(tmp);
				}
			}
			if(this._model.force_full_redraw) {
				f.className = this.get_container_ul()[0] ? this.get_container_ul()[0].className : null;
				f.setAttribute('role','group');
				this.element.empty().append(f);
				//this.get_container_ul()[0].appendChild(f);
			}
			if(fe !== null) {
				tmp = this.get_node(fe, true);
				if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
					tmp.children('.jstree-anchor').focus();
				}
				else {
					this._data.core.focused = null;
				}
			}
			this._model.force_full_redraw = false;
			this._model.changed = [];
			/**
			 * triggered after nodes are redrawn
			 * @event
			 * @name redraw.jstree
			 * @param {array} nodes the redrawn nodes
			 */
			this.trigger('redraw', { "nodes" : nodes });
		},
		/**
		 * redraws all nodes that need to be redrawn or optionally - the whole tree
		 * @name redraw([full])
		 * @param {Boolean} full if set to `true` all nodes are redrawn.
		 */
		redraw : function (full) {
			if(full) {
				this._model.force_full_redraw = true;
			}
			//if(this._model.redraw_timeout) {
			//	clearTimeout(this._model.redraw_timeout);
			//}
			//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
			this._redraw();
		},
		/**
		 * redraws a single node's children. Used internally.
		 * @private
		 * @name draw_children(node)
		 * @param {mixed} node the node whose children will be redrawn
		 */
		draw_children : function (node) {
			var obj = this.get_node(node),
				i = false,
				j = false,
				k = false,
				d = document;
			if(!obj) { return false; }
			if(obj.id === '#') { return this.redraw(true); }
			node = this.get_node(node, true);
			if(!node || !node.length) { return false; } // TODO: quick toggle

			node.children('.jstree-children').remove();
			node = node[0];
			if(obj.children.length && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], true, true));
				}
				node.appendChild(k);
			}
		},
		/**
		 * redraws a single node. Used internally.
		 * @private
		 * @name redraw_node(node, deep, is_callback, force_render)
		 * @param {mixed} node the node to redraw
		 * @param {Boolean} deep should child nodes be redrawn too
		 * @param {Boolean} is_callback is this a recursion call
		 * @param {Boolean} force_render should children of closed parents be drawn anyway
		 */
		redraw_node : function (node, deep, is_callback, force_render) {
			var obj = this.get_node(node),
				par = false,
				ind = false,
				old = false,
				i = false,
				j = false,
				k = false,
				c = '',
				d = document,
				m = this._model.data,
				f = false,
				s = false,
				tmp = null,
				t = 0,
				l = 0;
			if(!obj) { return false; }
			if(obj.id === '#') {  return this.redraw(true); }
			deep = deep || obj.children.length === 0;
			node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
			if(!node) {
				deep = true;
				//node = d.createElement('LI');
				if(!is_callback) {
					par = obj.parent !== '#' ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
					if(par !== null && (!par || !m[obj.parent].state.opened)) {
						return false;
					}
					ind = $.inArray(obj.id, par === null ? m['#'].children : m[obj.parent].children);
				}
			}
			else {
				node = $(node);
				if(!is_callback) {
					par = node.parent().parent()[0];
					if(par === this.element[0]) {
						par = null;
					}
					ind = node.index();
				}
				// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
				if(!deep && obj.children.length && !node.children('.jstree-children').length) {
					deep = true;
				}
				if(!deep) {
					old = node.children('.jstree-children')[0];
				}
				f = node.children('.jstree-anchor')[0] === document.activeElement;
				node.remove();
				//node = d.createElement('LI');
				//node = node[0];
			}
			node = _node.cloneNode(true);
			// node is DOM, deep is boolean

			c = 'jstree-node ';
			for(i in obj.li_attr) {
				if(obj.li_attr.hasOwnProperty(i)) {
					if(i === 'id') { continue; }
					if(i !== 'class') {
						node.setAttribute(i, obj.li_attr[i]);
					}
					else {
						c += obj.li_attr[i];
					}
				}
			}
			if(!obj.a_attr.id) {
				obj.a_attr.id = obj.id + '_anchor';
			}
			node.setAttribute('aria-selected', !!obj.state.selected);
			node.setAttribute('aria-level', obj.parents.length);
			node.setAttribute('aria-labelledby', obj.a_attr.id);
			if(obj.state.disabled) {
				node.setAttribute('aria-disabled', true);
			}

			if(obj.state.loaded && !obj.children.length) {
				c += ' jstree-leaf';
			}
			else {
				c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
				node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
			}
			if(obj.parent !== null && m[obj.parent].children[m[obj.parent].children.length - 1] === obj.id) {
				c += ' jstree-last';
			}
			node.id = obj.id;
			node.className = c;
			c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
			for(j in obj.a_attr) {
				if(obj.a_attr.hasOwnProperty(j)) {
					if(j === 'href' && obj.a_attr[j] === '#') { continue; }
					if(j !== 'class') {
						node.childNodes[1].setAttribute(j, obj.a_attr[j]);
					}
					else {
						c += ' ' + obj.a_attr[j];
					}
				}
			}
			if(c.length) {
				node.childNodes[1].className = 'jstree-anchor ' + c;
			}
			if((obj.icon && obj.icon !== true) || obj.icon === false) {
				if(obj.icon === false) {
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
				}
				else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
					node.childNodes[1].className += ' ' + obj.icon + ' jstree-themeicon-custom';	//jstree 
				}
				else {
					node.childNodes[1].childNodes[0].style.backgroundImage = 'url('+obj.icon+')';
					node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
					node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
				}
			}

			if(this.settings.core.force_text) {
				node.childNodes[1].appendChild(d.createTextNode(obj.text));
			}
			else {
				node.childNodes[1].innerHTML += obj.text;
			}


			if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], deep, true));
				}
				node.appendChild(k);
			}
			if(old) {
				node.appendChild(old);
			}
			if(!is_callback) {
				// append back using par / ind
				if(!par) {
					par = this.element[0];
				}
				for(i = 0, j = par.childNodes.length; i < j; i++) {
					if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
						tmp = par.childNodes[i];
						break;
					}
				}
				if(!tmp) {
					tmp = d.createElement('UL');
					tmp.setAttribute('role', 'group');
					tmp.className = 'jstree-children';
					par.appendChild(tmp);
				}
				par = tmp;

				if(ind < par.childNodes.length) {
					par.insertBefore(node, par.childNodes[ind]);
				}
				else {
					par.appendChild(node);
				}
				if(f) {
					t = this.element[0].scrollTop;
					l = this.element[0].scrollLeft;
					node.childNodes[1].focus();
					this.element[0].scrollTop = t;
					this.element[0].scrollLeft = l;
				}
			}
			if(obj.state.opened && !obj.state.loaded) {
				obj.state.opened = false;
				setTimeout($.proxy(function () {
					this.open_node(obj.id, false, 0);
				}, this), 0);
			}
			return node;
		},
		/**
		 * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_node(obj [, callback, animation])
		 * @param {mixed} obj the node to open
		 * @param {Function} callback a function to execute once the node is opened
		 * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger open_node.jstree, after_open.jstree, before_open.jstree
		 */
		open_node : function (obj, callback, animation) {
			var t1, t2, d, t;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.open_node(obj[t1], callback, animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			if(!this.is_closed(obj)) {
				if(callback) {
					callback.call(this, obj, false);
				}
				return false;
			}
			if(!this.is_loaded(obj)) {
				if(this.is_loading(obj)) {
					return setTimeout($.proxy(function () {
						this.open_node(obj, callback, animation);
					}, this), 500);
				}
				this.load_node(obj, function (o, ok) {
					return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
				});
			}
			else {
				d = this.get_node(obj, true);
				t = this;
				if(d.length) {
					if(animation && d.children(".jstree-children").length) {
						d.children(".jstree-children").stop(true, true);
					}
					if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
						this.draw_children(obj);
						//d = this.get_node(obj, true);
					}
					if(!animation) {
						this.trigger('before_open', { "node" : obj });
						d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
						d[0].setAttribute("aria-expanded", true);
					}
					else {
						this.trigger('before_open', { "node" : obj });
						d
							.children(".jstree-children").css("display","none").end()
							.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
							.children(".jstree-children").stop(true, true)
								.slideDown(animation, function () {
									this.style.display = "";
									t.trigger("after_open", { "node" : obj });
								});
					}
				}
				obj.state.opened = true;
				if(callback) {
					callback.call(this, obj, true);
				}
				if(!d.length) {
					/**
					 * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
					 * @event
					 * @name before_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('before_open', { "node" : obj });
				}
				/**
				 * triggered when a node is opened (if there is an animation it will not be completed yet)
				 * @event
				 * @name open_node.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_node', { "node" : obj });
				if(!animation || !d.length) {
					/**
					 * triggered when a node is opened and the animation is complete
					 * @event
					 * @name after_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger("after_open", { "node" : obj });
				}
			}
		},
		/**
		 * opens every parent of a node (node should be loaded)
		 * @name _open_to(obj)
		 * @param {mixed} obj the node to reveal
		 * @private
		 */
		_open_to : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			var i, j, p = obj.parents;
			for(i = 0, j = p.length; i < j; i+=1) {
				if(i !== '#') {
					this.open_node(p[i], false, 0);
				}
			}
			return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
		},
		/**
		 * closes a node, hiding its children
		 * @name close_node(obj [, animation])
		 * @param {mixed} obj the node to close
		 * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger close_node.jstree, after_close.jstree
		 */
		close_node : function (obj, animation) {
			var t1, t2, t, d;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.close_node(obj[t1], animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			if(this.is_closed(obj)) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			t = this;
			d = this.get_node(obj, true);
			if(d.length) {
				if(!animation) {
					d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
					d.attr("aria-expanded", false).children('.jstree-children').remove();
				}
				else {
					d
						.children(".jstree-children").attr("style","display:block !important").end()
						.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
						.children(".jstree-children").stop(true, true).slideUp(animation, function () {
							this.style.display = "";
							d.children('.jstree-children').remove();
							t.trigger("after_close", { "node" : obj });
						});
				}
			}
			obj.state.opened = false;
			/**
			 * triggered when a node is closed (if there is an animation it will not be complete yet)
			 * @event
			 * @name close_node.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_node',{ "node" : obj });
			if(!animation || !d.length) {
				/**
				 * triggered when a node is closed and the animation is complete
				 * @event
				 * @name after_close.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger("after_close", { "node" : obj });
			}
		},
		/**
		 * toggles a node - closing it if it is open, opening it if it is closed
		 * @name toggle_node(obj)
		 * @param {mixed} obj the node to toggle
		 */
		toggle_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.toggle_node(obj[t1]);
				}
				return true;
			}
			if(this.is_closed(obj)) {
				return this.open_node(obj);
			}
			if(this.is_open(obj)) {
				return this.close_node(obj);
			}
		},
		/**
		 * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_all([obj, animation, original_obj])
		 * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
		 * @param {jQuery} reference to the node that started the process (internal use)
		 * @trigger open_all.jstree
		 */
		open_all : function (obj, animation, original_obj) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					if(this.is_closed(this._model.data[obj.children_d[i]])) {
						this._model.data[obj.children_d[i]].state.opened = true;
					}
				}
				return this.trigger('open_all', { "node" : obj });
			}
			original_obj = original_obj || dom;
			_this = this;
			dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
			dom.each(function () {
				_this.open_node(
					this,
					function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
					animation || 0
				);
			});
			if(original_obj.find('.jstree-closed').length === 0) {
				/**
				 * triggered when an `open_all` call completes
				 * @event
				 * @name open_all.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_all', { "node" : this.get_node(original_obj) });
			}
		},
		/**
		 * closes all nodes within a node (or the tree), revaling their children
		 * @name close_all([obj, animation])
		 * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
		 * @trigger close_all.jstree
		 */
		close_all : function (obj, animation) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true),
				_this = this, i, j;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].state.opened = false;
				}
				return this.trigger('close_all', { "node" : obj });
			}
			dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
			$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
			/**
			 * triggered when an `close_all` call completes
			 * @event
			 * @name close_all.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_all', { "node" : obj });
		},
		/**
		 * checks if a node is disabled (not selectable)
		 * @name is_disabled(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_disabled : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.disabled;
		},
		/**
		 * enables a node - so that it can be selected
		 * @name enable_node(obj)
		 * @param {mixed} obj the node to enable
		 * @trigger enable_node.jstree
		 */
		enable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			obj.state.disabled = false;
			this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
			/**
			 * triggered when an node is enabled
			 * @event
			 * @name enable_node.jstree
			 * @param {Object} node the enabled node
			 */
			this.trigger('enable_node', { 'node' : obj });
		},
		/**
		 * disables a node - so that it can not be selected
		 * @name disable_node(obj)
		 * @param {mixed} obj the node to disable
		 * @trigger disable_node.jstree
		 */
		disable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			obj.state.disabled = true;
			this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
			/**
			 * triggered when an node is disabled
			 * @event
			 * @name disable_node.jstree
			 * @param {Object} node the disabled node
			 */
			this.trigger('disable_node', { 'node' : obj });
		},
		/**
		 * called when a node is selected by the user. Used internally.
		 * @private
		 * @name activate_node(obj, e)
		 * @param {mixed} obj the node
		 * @param {Object} e the related event
		 * @trigger activate_node.jstree, changed.jstree
		 */
		activate_node : function (obj, e) {
			if(this.is_disabled(obj)) {
				return false;
			}

			// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
			this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
			if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
			if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }

			if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
				if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
					this.deselect_node(obj, false, e);
				}
				else {
					this.deselect_all(true);
					this.select_node(obj, false, false, e);
					this._data.core.last_clicked = this.get_node(obj);
				}
			}
			else {
				if(e.shiftKey) {
					var o = this.get_node(obj).id,
						l = this._data.core.last_clicked.id,
						p = this.get_node(this._data.core.last_clicked.parent).children,
						c = false,
						i, j;
					for(i = 0, j = p.length; i < j; i += 1) {
						// separate IFs work whem o and l are the same
						if(p[i] === o) {
							c = !c;
						}
						if(p[i] === l) {
							c = !c;
						}
						if(!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
							this.select_node(p[i], true, false, e);
						}
						else {
							this.deselect_node(p[i], true, e);
						}
					}
					this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
				}
				else {
					if(!this.is_selected(obj)) {
						this.select_node(obj, false, false, e);
					}
					else {
						this.deselect_node(obj, false, e);
					}
				}
			}
			/**
			 * triggered when an node is clicked or intercated with by the user
			 * @event
			 * @name activate_node.jstree
			 * @param {Object} node
			 */
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * applies the hover state on a node, called when a node is hovered by the user. Used internally.
		 * @private
		 * @name hover_node(obj)
		 * @param {mixed} obj
		 * @trigger hover_node.jstree
		 */
		hover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
				return false;
			}
			var o = this.element.find('.jstree-hovered'), t = this.element;
			if(o && o.length) { this.dehover_node(o); }

			obj.children('.jstree-anchor').addClass('jstree-hovered');
			/**
			 * triggered when an node is hovered
			 * @event
			 * @name hover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('hover_node', { 'node' : this.get_node(obj) });
			setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
		},
		/**
		 * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
		 * @private
		 * @name dehover_node(obj)
		 * @param {mixed} obj
		 * @trigger dehover_node.jstree
		 */
		dehover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
				return false;
			}
			obj.children('.jstree-anchor').removeClass('jstree-hovered');
			/**
			 * triggered when an node is no longer hovered
			 * @event
			 * @name dehover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('dehover_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * select a node
		 * @name select_node(obj [, supress_event, prevent_open])
		 * @param {mixed} obj an array can be used to select multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
		 * @trigger select_node.jstree, changed.jstree
		 */
		select_node : function (obj, supress_event, prevent_open, e) {
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.select_node(obj[t1], supress_event, prevent_open, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.selected) {
				obj.state.selected = true;
				this._data.core.selected.push(obj.id);
				if(!prevent_open) {
					dom = this._open_to(obj);
				}
				if(dom && dom.length) {
					dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
				}
				/**
				 * triggered when an node is selected
				 * @event
				 * @name select_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this select_node
				 */
				this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					/**
					 * triggered when selection changes
					 * @event
					 * @name changed.jstree
					 * @param {Object} node
					 * @param {Object} action the action that caused the selection to change
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this changed event
					 */
					this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * deselect a node
		 * @name deselect_node(obj [, supress_event])
		 * @param {mixed} obj an array can be used to deselect multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_node.jstree, changed.jstree
		 */
		deselect_node : function (obj, supress_event, e) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.deselect_node(obj[t1], supress_event, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.selected) {
				obj.state.selected = false;
				this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
				if(dom.length) {
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
				}
				/**
				 * triggered when an node is deselected
				 * @event
				 * @name deselect_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this deselect_node
				 */
				this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * select all nodes in the tree
		 * @name select_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger select_all.jstree, changed.jstree
		 */
		select_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			this._data.core.selected = this._model.data['#'].children_d.concat();
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are selected
			 * @event
			 * @name select_all.jstree
			 * @param {Array} selected the current selection
			 */
			this.trigger('select_all', { 'selected' : this._data.core.selected });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * deselect all selected nodes
		 * @name deselect_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_all.jstree, changed.jstree
		 */
		deselect_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = false;
				}
			}
			this._data.core.selected = [];
			this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
			/**
			 * triggered when all nodes are deselected
			 * @event
			 * @name deselect_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 */
			this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * checks if a node is selected
		 * @name is_selected(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 */
		is_selected : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			return obj.state.selected;
		},
		/**
		 * get an array of all selected nodes
		 * @name get_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_selected : function (full) {
			return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
		},
		/**
		 * get an array of all top level selected nodes (ignoring children of selected nodes)
		 * @name get_top_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_top_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		},
		/**
		 * get an array of all bottom level selected nodes (ignoring selected parents)
		 * @name get_bottom_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_bottom_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		},
		/**
		 * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
		 * @name get_state()
		 * @private
		 * @return {Object}
		 */
		get_state : function () {
			var state	= {
				'core' : {
					'open' : [],
					'scroll' : {
						'left' : this.element.scrollLeft(),
						'top' : this.element.scrollTop()
					},
					/*!
					'themes' : {
						'name' : this.get_theme(),
						'icons' : this._data.core.themes.icons,
						'dots' : this._data.core.themes.dots
					},
					*/
					'selected' : []
				}
			}, i;
			for(i in this._model.data) {
				if(this._model.data.hasOwnProperty(i)) {
					if(i !== '#') {
						if(this._model.data[i].state.opened) {
							state.core.open.push(i);
						}
						if(this._model.data[i].state.selected) {
							state.core.selected.push(i);
						}
					}
				}
			}
			return state;
		},
		/**
		 * sets the state of the tree. Used internally.
		 * @name set_state(state [, callback])
		 * @private
		 * @param {Object} state the state to restore
		 * @param {Function} callback an optional function to execute once the state is restored.
		 * @trigger set_state.jstree
		 */
		set_state : function (state, callback) {
			if(state) {
				if(state.core) {
					var res, n, t, _this, i;
					if(state.core.open) {
						if(!$.isArray(state.core.open) || !state.core.open.length) {
							delete state.core.open;
							this.set_state(state, callback);
						}
						else {
							this._load_nodes(state.core.open, function (nodes) {
								this.open_node(nodes, false, 0);
								delete state.core.open;
								this.set_state(state, callback);
							}, true);
						}
						return false;
					}
					if(state.core.scroll) {
						if(state.core.scroll && state.core.scroll.left !== undefined) {
							this.element.scrollLeft(state.core.scroll.left);
						}
						if(state.core.scroll && state.core.scroll.top !== undefined) {
							this.element.scrollTop(state.core.scroll.top);
						}
						delete state.core.scroll;
						this.set_state(state, callback);
						return false;
					}
					if(state.core.selected) {
						_this = this;
						this.deselect_all();
						$.each(state.core.selected, function (i, v) {
							_this.select_node(v, false, true);
						});
						delete state.core.selected;
						this.set_state(state, callback);
						return false;
					}
					for(i in state) {
						if(state.hasOwnProperty(i) && i !== "core" && $.inArray(i, this.settings.plugins) === -1) {
							delete state[i];
						}
					}
					if($.isEmptyObject(state.core)) {
						delete state.core;
						this.set_state(state, callback);
						return false;
					}
				}
				if($.isEmptyObject(state)) {
					state = null;
					if(callback) { callback.call(this); }
					/**
					 * triggered when a `set_state` call completes
					 * @event
					 * @name set_state.jstree
					 */
					this.trigger('set_state');
					return false;
				}
				return true;
			}
			return false;
		},
		/**
		 * refreshes the tree - all nodes are reloaded with calls to `load_node`.
		 * @name refresh()
		 * @param {Boolean} skip_loading an option to skip showing the loading indicator
		 * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
		 * @trigger refresh.jstree
		 */
		refresh : function (skip_loading, forget_state) {
			this._data.core.state = forget_state === true ? {} : this.get_state();
			if(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
			this._cnt = 0;
			this._model.data = {
				'#' : {
					id : '#',
					parent : null,
					parents : [],
					children : [],
					children_d : [],
					state : { loaded : false }
				}
			};
			var c = this.get_container_ul()[0].className;
			if(!skip_loading) {
				this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
				this.element.attr('aria-activedescendant','j'+this._id+'_loading');
			}
			this.load_node('#', function (o, s) {
				if(s) {
					this.get_container_ul()[0].className = c;
					if(this._firstChild(this.get_container_ul()[0])) {
						this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
					}
					this.set_state($.extend(true, {}, this._data.core.state), function () {
						/**
						 * triggered when a `refresh` call completes
						 * @event
						 * @name refresh.jstree
						 */
						this.trigger('refresh');
					});
				}
				this._data.core.state = null;
			});
		},
		/**
		 * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
		 * @name refresh_node(obj)
		 * @param  {mixed} obj the node
		 * @trigger refresh_node.jstree
		 */
		refresh_node : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var opened = [], to_load = [], s = this._data.core.selected.concat([]);
			to_load.push(obj.id);
			if(obj.state.opened === true) { opened.push(obj.id); }
			this.get_node(obj, true).find('.jstree-open').each(function() { opened.push(this.id); });
			this._load_nodes(to_load, $.proxy(function (nodes) {
				this.open_node(opened, false, 0);
				this.select_node(this._data.core.selected);
				/**
				 * triggered when a node is refreshed
				 * @event
				 * @name refresh_node.jstree
				 * @param {Object} node - the refreshed node
				 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
				 */
				this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
			}, this));
		},
		/**
		 * set (change) the ID of a node
		 * @name set_id(obj, id)
		 * @param  {mixed} obj the node
		 * @param  {String} id the new ID
		 * @return {Boolean}
		 */
		set_id : function (obj, id) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var i, j, m = this._model.data;
			id = id.toString();
			// update parents (replace current ID with new one in children and children_d)
			m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
			for(i = 0, j = obj.parents.length; i < j; i++) {
				m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
			}
			// update children (replace current ID with new one in parent and parents)
			for(i = 0, j = obj.children.length; i < j; i++) {
				m[obj.children[i]].parent = id;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
			}
			i = $.inArray(obj.id, this._data.core.selected);
			if(i !== -1) { this._data.core.selected[i] = id; }
			// update model and obj itself (obj.id, this._model.data[KEY])
			i = this.get_node(obj.id, true);
			if(i) {
				i.attr('id', id).children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
				if(this.element.attr('aria-activedescendant') === obj.id) {
					this.element.attr('aria-activedescendant', id);
				}
			}
			delete m[obj.id];
			obj.id = id;
			obj.li_attr.id = id;
			m[id] = obj;
			return true;
		},
		/**
		 * get the text value of a node
		 * @name get_text(obj)
		 * @param  {mixed} obj the node
		 * @return {String}
		 */
		get_text : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === '#') ? false : obj.text;
		},
		/**
		 * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
		 * @private
		 * @name set_text(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger set_text.jstree
		 */
		set_text : function (obj, val) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_text(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			obj.text = val;
			if(this.get_node(obj, true).length) {
				this.redraw_node(obj.id);
			}
			/**
			 * triggered when a node text value is changed
			 * @event
			 * @name set_text.jstree
			 * @param {Object} obj
			 * @param {String} text the new value
			 */
			this.trigger('set_text',{ "obj" : obj, "text" : val });
			return true;
		},
		/**
		 * gets a JSON representation of a node (or the whole tree)
		 * @name get_json([obj, options])
		 * @param  {mixed} obj
		 * @param  {Object} options
		 * @param  {Boolean} options.no_state do not return state information
		 * @param  {Boolean} options.no_id do not return ID
		 * @param  {Boolean} options.no_children do not include children
		 * @param  {Boolean} options.no_data do not include node data
		 * @param  {Boolean} options.flat return flat JSON instead of nested
		 * @return {Object}
		 */
		get_json : function (obj, options, flat) {
			obj = this.get_node(obj || '#');
			if(!obj) { return false; }
			if(options && options.flat && !flat) { flat = []; }
			var tmp = {
				'id' : obj.id,
				'text' : obj.text,
				'icon' : this.get_icon(obj),
				'li_attr' : $.extend(true, {}, obj.li_attr),
				'a_attr' : $.extend(true, {}, obj.a_attr),
				'state' : {},
				'data' : options && options.no_data ? false : $.extend(true, {}, obj.data)
				//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
			}, i, j;
			if(options && options.flat) {
				tmp.parent = obj.parent;
			}
			else {
				tmp.children = [];
			}
			if(!options || !options.no_state) {
				for(i in obj.state) {
					if(obj.state.hasOwnProperty(i)) {
						tmp.state[i] = obj.state[i];
					}
				}
			}
			if(options && options.no_id) {
				delete tmp.id;
				if(tmp.li_attr && tmp.li_attr.id) {
					delete tmp.li_attr.id;
				}
				if(tmp.a_attr && tmp.a_attr.id) {
					delete tmp.a_attr.id;
				}
			}
			if(options && options.flat && obj.id !== '#') {
				flat.push(tmp);
			}
			if(!options || !options.no_children) {
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(options && options.flat) {
						this.get_json(obj.children[i], options, flat);
					}
					else {
						tmp.children.push(this.get_json(obj.children[i], options));
					}
				}
			}
			return options && options.flat ? flat : (obj.id === '#' ? tmp.children : tmp);
		},
		/**
		 * create a new node (do not confuse with load_node)
		 * @name create_node([obj, node, pos, callback, is_loaded])
		 * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
		 * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
		 * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
		 * @param  {Function} callback a function to be called once the node is created
		 * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
		 * @return {String}            the ID of the newly create node
		 * @trigger model.jstree, create_node.jstree
		 */
		create_node : function (par, node, pos, callback, is_loaded) {
			if(par === null) { par = "#"; }
			par = this.get_node(par);
			if(!par) { return false; }
			pos = pos === undefined ? "last" : pos;
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
			}
			if(!node) { node = { "text" : this.get_string('New node') }; }
			if(typeof node === "string") { node = { "text" : node }; }
			if(node.text === undefined) { node.text = this.get_string('New node'); }
			var tmp, dpc, i, j;

			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children);
					par = tmp;
					break;
				case "after" :
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children) + 1;
					par = tmp;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > par.children.length) { pos = par.children.length; }
			if(!node.id) { node.id = true; }
			if(!this.check("create_node", node, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, par.id, par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : par.id });

			par.children_d = par.children_d.concat(dpc);
			for(i = 0, j = par.parents.length; i < j; i++) {
				this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
			}
			node = tmp;
			tmp = [];
			for(i = 0, j = par.children.length; i < j; i++) {
				tmp[i >= pos ? i+1 : i] = par.children[i];
			}
			tmp[pos] = node.id;
			par.children = tmp;

			this.redraw_node(par, true);
			if(callback) { callback.call(this, this.get_node(node)); }
			/**
			 * triggered when a node is created
			 * @event
			 * @name create_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the new node among the parent's children
			 */
			this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
			return node.id;
		},
		/**
		 * set the text value of a node
		 * @name rename_node(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger rename_node.jstree
		 */
		rename_node : function (obj, val) {
			var t1, t2, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.rename_node(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			old = obj.text;
			if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
			/**
			 * triggered when a node is renamed
			 * @event
			 * @name rename_node.jstree
			 * @param {Object} node
			 * @param {String} text the new value
			 * @param {String} old the old value
			 */
			this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
			return true;
		},
		/**
		 * remove a node
		 * @name delete_node(obj)
		 * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
		 * @return {Boolean}
		 * @trigger delete_node.jstree, changed.jstree
		 */
		delete_node : function (obj) {
			var t1, t2, par, pos, tmp, i, j, k, l, c;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.delete_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			par = this.get_node(obj.parent);
			pos = $.inArray(obj.id, par.children);
			c = false;
			if(!this.check("delete_node", obj, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(pos !== -1) {
				par.children = $.vakata.array_remove(par.children, pos);
			}
			tmp = obj.children_d.concat([]);
			tmp.push(obj.id);
			for(k = 0, l = tmp.length; k < l; k++) {
				for(i = 0, j = obj.parents.length; i < j; i++) {
					pos = $.inArray(tmp[k], this._model.data[obj.parents[i]].children_d);
					if(pos !== -1) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_remove(this._model.data[obj.parents[i]].children_d, pos);
					}
				}
				if(this._model.data[tmp[k]].state.selected) {
					c = true;
					pos = $.inArray(tmp[k], this._data.core.selected);
					if(pos !== -1) {
						this._data.core.selected = $.vakata.array_remove(this._data.core.selected, pos);
					}
				}
			}
			/**
			 * triggered when a node is deleted
			 * @event
			 * @name delete_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 */
			this.trigger('delete_node', { "node" : obj, "parent" : par.id });
			if(c) {
				this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				delete this._model.data[tmp[k]];
			}
			this.redraw_node(par, true);
			return true;
		},
		/**
		 * check if an operation is premitted on the tree. Used internally.
		 * @private
		 * @name check(chk, obj, par, pos)
		 * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
		 * @param  {mixed} obj the node
		 * @param  {mixed} par the parent
		 * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
		 * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
		 * @return {Boolean}
		 */
		check : function (chk, obj, par, pos, more) {
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
			if(chk === "move_node" || chk === "copy_node") {
				if((!more || !more.is_multi) && (obj.id === par.id || $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					return false;
				}
			}
			if(tmp && tmp.data) { tmp = tmp.data; }
			if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
				if(tmp.functions[chk] === false) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				}
				return tmp.functions[chk];
			}
			if(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				return false;
			}
			return true;
		},
		/**
		 * get the last error
		 * @name last_error()
		 * @return {Object}
		 */
		last_error : function () {
			return this._data.core.last_error;
		},
		/**
		 * move a node to a new parent
		 * @name move_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to move, pass an array to move multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger move_node.jstree
		 */
		move_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
			}

			if($.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);

			if(!obj || obj.id === '#') { return false; }

			old_par = (obj.parent || '#').toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
			old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(is_multi) {
				if((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
					if(old_ins) { old_ins.delete_node(obj); }
					return tmp;
				}
				return false;
			}
			//var m = this._model.data;
			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(obj.parent === new_par.id) {
				dpc = new_par.children.concat();
				tmp = $.inArray(obj.id, dpc);
				if(tmp !== -1) {
					dpc = $.vakata.array_remove(dpc, tmp);
					if(pos > tmp) { pos--; }
				}
				tmp = [];
				for(i = 0, j = dpc.length; i < j; i++) {
					tmp[i >= pos ? i+1 : i] = dpc[i];
				}
				tmp[pos] = obj.id;
				new_par.children = tmp;
				this._node_changed(new_par.id);
				this.redraw(new_par.id === '#');
			}
			else {
				// clean old parent and up
				tmp = obj.children_d.concat();
				tmp.push(obj.id);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					dpc = [];
					p = old_ins._model.data[obj.parents[i]].children_d;
					for(k = 0, l = p.length; k < l; k++) {
						if($.inArray(p[k], tmp) === -1) {
							dpc.push(p[k]);
						}
					}
					old_ins._model.data[obj.parents[i]].children_d = dpc;
				}
				old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);

				// insert into new parent and up
				for(i = 0, j = new_par.parents.length; i < j; i++) {
					this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
				}
				dpc = [];
				for(i = 0, j = new_par.children.length; i < j; i++) {
					dpc[i >= pos ? i+1 : i] = new_par.children[i];
				}
				dpc[pos] = obj.id;
				new_par.children = dpc;
				new_par.children_d.push(obj.id);
				new_par.children_d = new_par.children_d.concat(obj.children_d);

				// update object
				obj.parent = new_par.id;
				tmp = new_par.parents.concat();
				tmp.unshift(new_par.id);
				p = obj.parents.length;
				obj.parents = tmp;

				// update object children
				tmp = tmp.concat();
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
					Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
				}

				if(old_par === '#' || new_par.id === '#') {
					this._model.force_full_redraw = true;
				}
				if(!this._model.force_full_redraw) {
					this._node_changed(old_par);
					this._node_changed(new_par.id);
				}
				if(!skip_redraw) {
					this.redraw();
				}
			}
			if(callback) { callback.call(this, obj, new_par, pos); }
			/**
			 * triggered when a node is moved
			 * @event
			 * @name move_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the old position of the node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return obj.id;
		},
		/**
		 * copy a node to a new parent
		 * @name copy_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger model.jstree copy_node.jstree
		 */
		copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
			}

			if($.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }

			old_par = (obj.parent || '#').toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);

			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
			if(!node) { return false; }
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });

			// insert into new parent and up
			for(i = 0, j = new_par.parents.length; i < j; i++) {
				this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
			}
			dpc = [];
			for(i = 0, j = new_par.children.length; i < j; i++) {
				dpc[i >= pos ? i+1 : i] = new_par.children[i];
			}
			dpc[pos] = tmp.id;
			new_par.children = dpc;
			new_par.children_d.push(tmp.id);
			new_par.children_d = new_par.children_d.concat(tmp.children_d);

			if(new_par.id === '#') {
				this._model.force_full_redraw = true;
			}
			if(!this._model.force_full_redraw) {
				this._node_changed(new_par.id);
			}
			if(!skip_redraw) {
				this.redraw(new_par.id === '#');
			}
			if(callback) { callback.call(this, tmp, new_par, pos); }
			/**
			 * triggered when a node is copied
			 * @event
			 * @name copy_node.jstree
			 * @param {Object} node the copied node
			 * @param {Object} original the original node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the position of the original node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return tmp.id;
		},
		/**
		 * cut a node (a later call to `paste(obj)` would move the node)
		 * @name cut(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger cut.jstree
		 */
		cut : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== '#') { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'move_node';
			/**
			 * triggered when nodes are added to the buffer for moving
			 * @event
			 * @name cut.jstree
			 * @param {Array} node
			 */
			this.trigger('cut', { "node" : obj });
		},
		/**
		 * copy a node (a later call to `paste(obj)` would copy the node)
		 * @name copy(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger copy.jstree
		 */
		copy : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== '#') { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'copy_node';
			/**
			 * triggered when nodes are added to the buffer for copying
			 * @event
			 * @name copy.jstree
			 * @param {Array} node
			 */
			this.trigger('copy', { "node" : obj });
		},
		/**
		 * get the current buffer (any nodes that are waiting for a paste operation)
		 * @name get_buffer()
		 * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
		 */
		get_buffer : function () {
			return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
		},
		/**
		 * check if there is something in the buffer to paste
		 * @name can_paste()
		 * @return {Boolean}
		 */
		can_paste : function () {
			return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
		},
		/**
		 * copy or move the previously cut or copied nodes to a new parent
		 * @name paste(obj [, pos])
		 * @param  {mixed} obj the new parent
		 * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
		 * @trigger paste.jstree
		 */
		paste : function (obj, pos) {
			obj = this.get_node(obj);
			if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
			if(this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
				/**
				 * triggered when paste is invoked
				 * @event
				 * @name paste.jstree
				 * @param {String} parent the ID of the receiving node
				 * @param {Array} node the nodes in the buffer
				 * @param {String} mode the performed operation - "copy_node" or "move_node"
				 */
				this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
			}
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
		},
		/**
		 * clear the buffer of previously copied or cut nodes
		 * @name clear_buffer()
		 * @trigger clear_buffer.jstree
		 */
		clear_buffer : function () {
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
			/**
			 * triggered when the copy / cut buffer is cleared
			 * @event
			 * @name clear_buffer.jstree
			 */
			this.trigger('clear_buffer');
		},
		/**
		 * put a node in edit mode (input field to rename the node)
		 * @name edit(obj [, default_text, callback])
		 * @param  {mixed} obj
		 * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)
		 * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node and a status parameter - true if the rename is successful, false otherwise. You can access the node's title using .text
		 */
		edit : function (obj, default_text, callback) {
			var rtl, w, a, s, t, h1, h2, fn, tmp;
			obj = this.get_node(obj);
			if(!obj) { return false; }
			if(this.settings.core.check_callback === false) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Could not edit node because of check_callback' };
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			tmp = obj;
			default_text = typeof default_text === 'string' ? default_text : obj.text;
			this.set_text(obj, "");
			obj = this._open_to(obj);
			tmp.text = default_text;

			rtl = this._data.core.rtl;
			w  = this.element.width();
			a  = obj.children('.jstree-anchor');
			s  = $('<span>');
			/*!
			oi = obj.children("i:visible"),
			ai = a.children("i:visible"),
			w1 = oi.width() * oi.length,
			w2 = ai.width() * ai.length,
			*/
			t  = default_text;
			h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body");
			h2 = $("<"+"input />", {
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"box-sizing" : "border-box",
							"display" : "inline-block",
							"height" : (this._data.core.li_height) + "px",
							"lineHeight" : (this._data.core.li_height) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = s.children(".jstree-rename-input"),
								v = i.val(),
								f = this.settings.core.force_text,
								nv;
							if(v === "") { v = t; }
							h1.remove();
							s.replaceWith(a);
							s.remove();
							t = f ? t : $('<div></div>').append($.parseHTML(t)).html();
							this.set_text(obj, t);
							nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());
							if(!nv) {
								this.set_text(obj, t); // move this up? and fix #483
							}
							if(callback) {
								callback.call(this, tmp, nv);
							}
						}, this),
						"keydown" : function (event) {
							var key = event.which;
							if(key === 27) {
								this.value = t;
							}
							if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
								event.stopImmediatePropagation();
							}
							if(key === 27 || key === 13) {
								event.preventDefault();
								this.blur();
							}
						},
						"click" : function (e) { e.stopImmediatePropagation(); },
						"mousedown" : function (e) { e.stopImmediatePropagation(); },
						"keyup" : function (event) {
							h2.width(Math.min(h1.text("pW" + this.value).width(),w));
						},
						"keypress" : function(event) {
							if(event.which === 13) { return false; }
						}
					});
				fn = {
						fontFamily		: a.css('fontFamily')		|| '',
						fontSize		: a.css('fontSize')			|| '',
						fontWeight		: a.css('fontWeight')		|| '',
						fontStyle		: a.css('fontStyle')		|| '',
						fontStretch		: a.css('fontStretch')		|| '',
						fontVariant		: a.css('fontVariant')		|| '',
						letterSpacing	: a.css('letterSpacing')	|| '',
						wordSpacing		: a.css('wordSpacing')		|| ''
				};
			s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
			a.replaceWith(s);
			h1.css(fn);
			h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
		},


		/**
		 * changes the theme
		 * @name set_theme(theme_name [, theme_url])
		 * @param {String} theme_name the name of the new theme to apply
		 * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
		 * @trigger set_theme.jstree
		 */
		set_theme : function (theme_name, theme_url) {
			if(!theme_name) { return false; }
			if(theme_url === true) {
				var dir = this.settings.core.themes.dir;
				if(!dir) { dir = $.jstree.path + '/themes'; }
				theme_url = dir + '/' + theme_name + '/style.css';
			}
			if(theme_url && $.inArray(theme_url, themes_loaded) === -1) {
				$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
				themes_loaded.push(theme_url);
			}
			if(this._data.core.themes.name) {
				this.element.removeClass('jstree-' + this._data.core.themes.name);
			}
			this._data.core.themes.name = theme_name;
			this.element.addClass('jstree-' + theme_name);
			this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
			/**
			 * triggered when a theme is set
			 * @event
			 * @name set_theme.jstree
			 * @param {String} theme the new theme
			 */
			this.trigger('set_theme', { 'theme' : theme_name });
		},
		/**
		 * gets the name of the currently applied theme name
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme : function () { return this._data.core.themes.name; },
		/**
		 * changes the theme variant (if the theme has variants)
		 * @name set_theme_variant(variant_name)
		 * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
		 */
		set_theme_variant : function (variant_name) {
			if(this._data.core.themes.variant) {
				this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
			this._data.core.themes.variant = variant_name;
			if(variant_name) {
				this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
		},
		/**
		 * gets the name of the currently applied theme variant
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme_variant : function () { return this._data.core.themes.variant; },
		/**
		 * shows a striped background on the container (if the theme supports it)
		 * @name show_stripes()
		 */
		show_stripes : function () { this._data.core.themes.stripes = true; this.get_container_ul().addClass("jstree-striped"); },
		/**
		 * hides the striped background on the container
		 * @name hide_stripes()
		 */
		hide_stripes : function () { this._data.core.themes.stripes = false; this.get_container_ul().removeClass("jstree-striped"); },
		/**
		 * toggles the striped background on the container
		 * @name toggle_stripes()
		 */
		toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
		/**
		 * shows the connecting dots (if the theme supports it)
		 * @name show_dots()
		 */
		show_dots : function () { this._data.core.themes.dots = true; this.get_container_ul().removeClass("jstree-no-dots"); },
		/**
		 * hides the connecting dots
		 * @name hide_dots()
		 */
		hide_dots : function () { this._data.core.themes.dots = false; this.get_container_ul().addClass("jstree-no-dots"); },
		/**
		 * toggles the connecting dots
		 * @name toggle_dots()
		 */
		toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
		/**
		 * show the node icons
		 * @name show_icons()
		 */
		show_icons : function () { this._data.core.themes.icons = true; this.get_container_ul().removeClass("jstree-no-icons"); },
		/**
		 * hide the node icons
		 * @name hide_icons()
		 */
		hide_icons : function () { this._data.core.themes.icons = false; this.get_container_ul().addClass("jstree-no-icons"); },
		/**
		 * toggle the node icons
		 * @name toggle_icons()
		 */
		toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
		/**
		 * set the node icon for a node
		 * @name set_icon(obj, icon)
		 * @param {mixed} obj
		 * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 */
		set_icon : function (obj, icon) {
			var t1, t2, dom, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_icon(obj[t1], icon);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			old = obj.icon;
			obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
			dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
			if(icon === false) {
				this.hide_icon(obj);
			}
			else if(icon === true || icon === null || icon === undefined || icon === '') {
				dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
				if(old === false) { this.show_icon(obj); }
			}
			else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
				dom.removeClass(old).css("background","");
				dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			else {
				dom.removeClass(old).css("background","");
				dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			return true;
		},
		/**
		 * get the node icon for a node
		 * @name get_icon(obj)
		 * @param {mixed} obj
		 * @return {String}
		 */
		get_icon : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === '#') ? false : obj.icon;
		},
		/**
		 * hide the icon on an individual node
		 * @name hide_icon(obj)
		 * @param {mixed} obj
		 */
		hide_icon : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === '#') { return false; }
			obj.icon = false;
			this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
			return true;
		},
		/**
		 * show the icon on an individual node
		 * @name show_icon(obj)
		 * @param {mixed} obj
		 */
		show_icon : function (obj) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === '#') { return false; }
			dom = this.get_node(obj, true);
			obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
			if(!obj.icon) { obj.icon = true; }
			dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
			return true;
		}
	};

	// helpers
	$.vakata = {};
	// collect attributes
	$.vakata.attributes = function(node, with_values) {
		node = $(node)[0];
		var attr = with_values ? {} : [];
		if(node && node.attributes) {
			$.each(node.attributes, function (i, v) {
				if($.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
				if(v.value !== null && $.trim(v.value) !== '') {
					if(with_values) { attr[v.name] = v.value; }
					else { attr.push(v.name); }
				}
			});
		}
		return attr;
	};
	$.vakata.array_unique = function(array) {
		var a = [], i, j, l, o = {};
		for(i = 0, l = array.length; i < l; i++) {
			if(o[array[i]] === undefined) {
				a.push(array[i]);
				o[array[i]] = true;
			}
		}
		return a;
	};
	// remove item from array
	$.vakata.array_remove = function(array, from, to) {
		var rest = array.slice((to || from) + 1 || array.length);
		array.length = from < 0 ? array.length + from : from;
		array.push.apply(array, rest);
		return array;
	};
	// remove item from array
	$.vakata.array_remove_item = function(array, item) {
		var tmp = $.inArray(item, array);
		return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
	};


/**
 * ### Checkbox plugin
 *
 * This plugin renders checkbox icons in front of each node, making multiple selection much easier.
 * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.
 */

	var _i = document.createElement('I');
	_i.className = 'jstree-icon jstree-checkbox';
	_i.setAttribute('role', 'presentation');
	/**
	 * stores all defaults for the checkbox plugin
	 * @name $.jstree.defaults.checkbox
	 * @plugin checkbox
	 */
	$.jstree.defaults.checkbox = {
		/**
		 * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.visible
		 * @plugin checkbox
		 */
		visible				: true,
		/**
		 * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.three_state
		 * @plugin checkbox
		 */
		three_state			: true,
		/**
		 * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.whole_node
		 * @plugin checkbox
		 */
		whole_node			: true,
		/**
		 * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.keep_selected_style
		 * @plugin checkbox
		 */
		keep_selected_style	: true,
		/**
		 * This setting controls how cascading and undetermined nodes are applied.
		 * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.
		 * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
		 * @name $.jstree.defaults.checkbox.cascade
		 * @plugin checkbox
		 */
		cascade				: '',
		/**
		 * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.
		 * @name $.jstree.defaults.checkbox.tie_selection
		 * @plugin checkbox
		 */
		tie_selection		: true
	};
	$.jstree.plugins.checkbox = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this._data.checkbox.uto = false;
			this._data.checkbox.selected = [];
			if(this.settings.checkbox.three_state) {
				this.settings.checkbox.cascade = 'up+down+undetermined';
			}
			this.element
				.on("init.jstree", $.proxy(function () {
						this._data.checkbox.visible = this.settings.checkbox.visible;
						if(!this.settings.checkbox.keep_selected_style) {
							this.element.addClass('jstree-checkbox-no-clicked');
						}
						if(this.settings.checkbox.tie_selection) {
							this.element.addClass('jstree-checkbox-selection');
						}
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
					}, this));
			if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				this.element
					.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
							// only if undetermined is in setting
							if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
							this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
						}, this));
			}
			if(!this.settings.checkbox.tie_selection) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							p = m[data.parent],
							dpc = data.nodes,
							i, j;
						for(i = 0, j = dpc.length; i < j; i++) {
							m[dpc[i]].state.checked = (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
							if(m[dpc[i]].state.checked) {
								this._data.checkbox.selected.push(dpc[i]);
							}
						}
					}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
							var m = this._model.data,
								p = m[data.parent],
								dpc = data.nodes,
								chd = [],
								c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							if(s.indexOf('down') !== -1) {
								// apply down
								if(p.state[ t ? 'selected' : 'checked' ]) {
									for(i = 0, j = dpc.length; i < j; i++) {
										m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
									}
									this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
								}
								else {
									for(i = 0, j = dpc.length; i < j; i++) {
										if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
											for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
												m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
											}
											this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
										}
									}
								}
							}

							if(s.indexOf('up') !== -1) {
								// apply up
								for(i = 0, j = p.children_d.length; i < j; i++) {
									if(!m[p.children_d[i]].children.length) {
										chd.push(m[p.children_d[i]].parent);
									}
								}
								chd = $.vakata.array_unique(chd);
								for(k = 0, l = chd.length; k < l; k++) {
									p = m[chd[k]];
									while(p && p.id !== '#') {
										c = 0;
										for(i = 0, j = p.children.length; i < j; i++) {
											c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(c === j) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										p = this.get_node(p.parent);
									}
								}
							}

							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								m = this._model.data,
								par = this.get_node(obj.parent),
								dom = this.get_node(obj, true),
								i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							// apply down
							if(s.indexOf('down') !== -1) {
								this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = m[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = true;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								while(par && par.id !== '#') {
									c = 0;
									for(i = 0, j = par.children.length; i < j; i++) {
										c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										par.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
										tmp = this.get_node(par, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									par = this.get_node(par.parent);
								}
							}

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
							var obj = this.get_node('#'),
								m = this._model.data,
								i, j, tmp;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								tmp = m[obj.children_d[i]];
								if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
									tmp.original.state.undetermined = false;
								}
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								dom = this.get_node(obj, true),
								i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;
							if(obj && obj.original && obj.original.state && obj.original.state.undetermined) {
								obj.original.state.undetermined = false;
							}

							// apply down
							if(s.indexOf('down') !== -1) {
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = this._model.data[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								for(i = 0, j = obj.parents.length; i < j; i++) {
									tmp = this._model.data[obj.parents[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
									tmp = this.get_node(obj.parents[i], true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
							}
							tmp = [];
							for(i = 0, j = this._data[ t ? 'core' : 'checkbox' ].selected.length; i < j; i++) {
								// apply down + apply up
								if(
									(s.indexOf('down') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.children_d) === -1) &&
									(s.indexOf('up') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.parents) === -1)
								) {
									tmp.push(this._data[ t ? 'core' : 'checkbox' ].selected[i]);
								}
							}
							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(tmp);

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);
							}
						}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
				this.element
					.on('delete_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var p = this.get_node(data.parent),
								m = this._model.data,
								i, j, c, tmp, t = this.settings.checkbox.tie_selection;
							while(p && p.id !== '#') {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									p.state[ t ? 'selected' : 'checked' ] = true;
									this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
									tmp = this.get_node(p, true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
								else {
									break;
								}
								p = this.get_node(p.parent);
							}
						}, this))
					.on('move_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var is_multi = data.is_multi,
								old_par = data.old_parent,
								new_par = this.get_node(data.parent),
								m = this._model.data,
								p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
							if(!is_multi) {
								p = this.get_node(old_par);
								while(p && p.id !== '#') {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									p = this.get_node(p.parent);
								}
							}
							p = new_par;
							while(p && p.id !== '#') {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									if(!p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
								}
								else {
									if(p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = false;
										this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
								}
								p = this.get_node(p.parent);
							}
						}, this));
			}
		};
		/**
		 * set the undetermined state where and if necessary. Used internally.
		 * @private
		 * @name _undetermined()
		 * @plugin checkbox
		 */
		this._undetermined = function () {
			if(this.element === null) { return; }
			var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;
			for(i = 0, j = s.length; i < j; i++) {
				if(m[s[i]] && m[s[i]].parents) {
					for(k = 0, l = m[s[i]].parents.length; k < l; k++) {
						if(o[m[s[i]].parents[k]] === undefined && m[s[i]].parents[k] !== '#') {
							o[m[s[i]].parents[k]] = true;
							p.push(m[s[i]].parents[k]);
						}
					}
				}
			}
			// attempt for server side undetermined state
			this.element.find('.jstree-closed').not(':has(.jstree-children)')
				.each(function () {
					var tmp = tt.get_node(this), tmp2;
					if(!tmp.state.loaded) {
						if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
							if(o[tmp.id] === undefined && tmp.id !== '#') {
								o[tmp.id] = true;
								p.push(tmp.id);
							}
							for(k = 0, l = tmp.parents.length; k < l; k++) {
								if(o[tmp.parents[k]] === undefined && tmp.parents[k] !== '#') {
									o[tmp.parents[k]] = true;
									p.push(tmp.parents[k]);
								}
							}
						}
					}
					else {
						for(i = 0, j = tmp.children_d.length; i < j; i++) {
							tmp2 = m[tmp.children_d[i]];
							if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
								if(o[tmp2.id] === undefined && tmp2.id !== '#') {
									o[tmp2.id] = true;
									p.push(tmp2.id);
								}
								for(k = 0, l = tmp2.parents.length; k < l; k++) {
									if(o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== '#') {
										o[tmp2.parents[k]] = true;
										p.push(tmp2.parents[k]);
									}
								}
							}
						}
					}
				});

			this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
			for(i = 0, j = p.length; i < j; i++) {
				if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
					s = this.get_node(p[i], true);
					if(s && s.length) {
						s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
					}
				}
			}
		};
		this.redraw_node = function(obj, deep, is_callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var i, j, tmp = null;
				for(i = 0, j = obj.childNodes.length; i < j; i++) {
					if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
						tmp = obj.childNodes[i];
						break;
					}
				}
				if(tmp) {
					if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
					tmp.insertBefore(_i.cloneNode(false), tmp.childNodes[0]);
				}
			}
			if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
				this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
			}
			return obj;
		};
		/**
		 * show the node checkbox icons
		 * @name show_checkboxes()
		 * @plugin checkbox
		 */
		this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
		/**
		 * hide the node checkbox icons
		 * @name hide_checkboxes()
		 * @plugin checkbox
		 */
		this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
		/**
		 * toggle the node icons
		 * @name toggle_checkboxes()
		 * @plugin checkbox
		 */
		this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
		/**
		 * checks if a node is in an undetermined state
		 * @name is_undetermined(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		this.is_undetermined = function (obj) {
			obj = this.get_node(obj);
			var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
			if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
				return false;
			}
			if(!obj.state.loaded && obj.original.state.undetermined === true) {
				return true;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				if($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
					return true;
				}
			}
			return false;
		};

		this.activate_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
				e.ctrlKey = true;
			}
			if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
				return parent.activate_node.call(this, obj, e);
			}
			if(this.is_disabled(obj)) {
				return false;
			}
			if(this.is_checked(obj)) {
				this.uncheck_node(obj, e);
			}
			else {
				this.check_node(obj, e);
			}
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		};

		/**
		 * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
		 * @name check_node(obj)
		 * @param {mixed} obj an array can be used to check multiple nodes
		 * @trigger check_node.jstree
		 * @plugin checkbox
		 */
		this.check_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.check_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checked) {
				obj.state.checked = true;
				this._data.checkbox.selected.push(obj.id);
				if(dom && dom.length) {
					dom.children('.jstree-anchor').addClass('jstree-checked');
				}
				/**
				 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name check_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this check_node
				 * @plugin checkbox
				 */
				this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
		 * @name uncheck_node(obj)
		 * @param {mixed} obj an array can be used to uncheck multiple nodes
		 * @trigger uncheck_node.jstree
		 * @plugin checkbox
		 */
		this.uncheck_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.uncheck_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checked) {
				obj.state.checked = false;
				this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
				if(dom.length) {
					dom.children('.jstree-anchor').removeClass('jstree-checked');
				}
				/**
				 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name uncheck_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this uncheck_node
				 * @plugin checkbox
				 */
				this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
		 * @name check_all()
		 * @trigger check_all.jstree, changed.jstree
		 * @plugin checkbox
		 */
		this.check_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.select_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			this._data.checkbox.selected = this._model.data['#'].children_d.concat();
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name check_all.jstree
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
		};
		/**
		 * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
		 * @name uncheck_all()
		 * @trigger uncheck_all.jstree
		 * @plugin checkbox
		 */
		this.uncheck_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = false;
				}
			}
			this._data.checkbox.selected = [];
			this.element.find('.jstree-checked').removeClass('jstree-checked');
			/**
			 * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name uncheck_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
		};
		/**
		 * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
		 * @name is_checked(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 * @plugin checkbox
		 */
		this.is_checked = function (obj) {
			if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			return obj.state.checked;
		};
		/**
		 * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
		 * @name get_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
			return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
		};
		/**
		 * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
		 * @name get_top_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_top_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
			var tmp = this.get_checked(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		};
		/**
		 * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
		 * @name get_bottom_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_bottom_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
			var tmp = this.get_checked(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		};
		this.load_node = function (obj, callback) {
			var k, l, i, j, c, tmp;
			if(!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
				tmp = this.get_node(obj);
				if(tmp && tmp.state.loaded) {
					for(k = 0, l = tmp.children_d.length; k < l; k++) {
						if(this._model.data[tmp.children_d[k]].state.checked) {
							c = true;
							this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
						}
					}
				}
			}
			return parent.load_node.apply(this, arguments);
		};
		this.get_state = function () {
			var state = parent.get_state.apply(this, arguments);
			if(this.settings.checkbox.tie_selection) { return state; }
			state.checkbox = this._data.checkbox.selected.slice();
			return state;
		};
		this.set_state = function (state, callback) {
			var res = parent.set_state.apply(this, arguments);
			if(res && state.checkbox) {
				if(!this.settings.checkbox.tie_selection) {
					this.uncheck_all();
					var _this = this;
					$.each(state.checkbox, function (i, v) {
						_this.check_node(v);
					});
				}
				delete state.checkbox;
				this.set_state(state, callback);
				return false;
			}
			return res;
		};
	};

	// include the checkbox plugin by default
	// $.jstree.defaults.plugins.push("checkbox");

/**
 * ### Contextmenu plugin
 *
 * Shows a context menu when a node is right-clicked.
 */

	/**
	 * stores all defaults for the contextmenu plugin
	 * @name $.jstree.defaults.contextmenu
	 * @plugin contextmenu
	 */
	$.jstree.defaults.contextmenu = {
		/**
		 * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
		 * @name $.jstree.defaults.contextmenu.select_node
		 * @plugin contextmenu
		 */
		select_node : true,
		/**
		 * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
		 * @name $.jstree.defaults.contextmenu.show_at_node
		 * @plugin contextmenu
		 */
		show_at_node : true,
		/**
		 * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
		 *
		 * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required):
		 *
		 * * `separator_before` - a boolean indicating if there should be a separator before this item
		 * * `separator_after` - a boolean indicating if there should be a separator after this item
		 * * `_disabled` - a boolean indicating if this action should be disabled
		 * * `label` - a string - the name of the action (could be a function returning a string)
		 * * `action` - a function to be executed if this item is chosen
		 * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
		 * * `shortcut_label` - shortcut label (like for example `F2` for rename)
		 *
		 * @name $.jstree.defaults.contextmenu.items
		 * @plugin contextmenu
		 */
		items : function (o, cb) { // Could be an object directly
			return {
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
					"label"				: "Create",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.create_node(obj, {}, "last", function (new_node) {
							setTimeout(function () { inst.edit(new_node); },0);
						});
					}
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Rename",
					/*
					"shortcut"			: 113,
					"shortcut_label"	: 'F2',
					"icon"				: "glyphicon glyphicon-leaf",
					*/
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.edit(obj);
					}
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Delete",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						if(inst.is_selected(obj)) {
							inst.delete_node(inst.get_selected());
						}
						else {
							inst.delete_node(obj);
						}
					}
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : {
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.cut(inst.get_top_selected());
								}
								else {
									inst.cut(obj);
								}
							}
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.copy(inst.get_top_selected());
								}
								else {
									inst.copy(obj);
								}
							}
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"_disabled"			: function (data) {
								return !$.jstree.reference(data.reference).can_paste();
							},
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								inst.paste(obj);
							}
						}
					}
				}
			};
		}
	};

	$.jstree.plugins.contextmenu = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			var last_ts = 0, cto = null, ex, ey;
			this.element
				.on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
						e.preventDefault();
						last_ts = e.ctrlKey ? +new Date() : 0;
						if(data || cto) {
							last_ts = (+new Date()) + 10000;
						}
						if(cto) {
							clearTimeout(cto);
						}
						if(!this.is_loading(e.currentTarget)) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
							$.vakata.context.hide();
						}
						last_ts = 0;
					}, this))
				.on("touchstart.jstree", ".jstree-anchor", function (e) {
						if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
							return;
						}
						ex = e.pageX;
						ey = e.pageY;
						cto = setTimeout(function () {
							$(e.currentTarget).trigger('contextmenu', true);
						}, 750);
					})
				.on('touchmove.vakata.jstree', function (e) {
						if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.pageX) > 50 || Math.abs(ey - e.pageY) > 50)) {
							clearTimeout(cto);
						}
					})
				.on('touchend.vakata.jstree', function (e) {
						if(cto) {
							clearTimeout(cto);
						}
					});

			/*
			if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
				var el = null, tm = null;
				this.element
					.on("touchstart", ".jstree-anchor", function (e) {
						el = e.currentTarget;
						tm = +new Date();
						$(document).one("touchend", function (e) {
							e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
							e.currentTarget = e.target;
							tm = ((+(new Date())) - tm);
							if(e.target === el && tm > 600 && tm < 1000) {
								e.preventDefault();
								$(el).trigger('contextmenu', e);
							}
							el = null;
							tm = null;
						});
					});
			}
			*/
			$(document).on("context_hide.vakata.jstree", $.proxy(function () { this._data.contextmenu.visible = false; }, this));
		};
		this.teardown = function () {
			if(this._data.contextmenu.visible) {
				$.vakata.context.hide();
			}
			parent.teardown.call(this);
		};

		/**
		 * prepare and show the context menu for a node
		 * @name show_contextmenu(obj [, x, y])
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Object} e the event if available that triggered the contextmenu
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 */
		this.show_contextmenu = function (obj, x, y, e) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var s = this.settings.contextmenu,
				d = this.get_node(obj, true),
				a = d.children(".jstree-anchor"),
				o = false,
				i = false;
			if(s.show_at_node || x === undefined || y === undefined) {
				o = a.offset();
				x = o.left;
				y = o.top + this._data.core.li_height;
			}
			if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
				this.activate_node(obj, e);
			}

			i = s.items;
			if($.isFunction(i)) {
				i = i.call(this, obj, $.proxy(function (i) {
					this._show_contextmenu(obj, x, y, i);
				}, this));
			}
			if($.isPlainObject(i)) {
				this._show_contextmenu(obj, x, y, i);
			}
		};
		/**
		 * show the prepared context menu for a node
		 * @name _show_contextmenu(obj, x, y, i)
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Number} i the object of items to show
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 * @private
		 */
		this._show_contextmenu = function (obj, x, y, i) {
			var d = this.get_node(obj, true),
				a = d.children(".jstree-anchor");
			$(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
				var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
				$(data.element).addClass(cls);
			}, this));
			this._data.contextmenu.visible = true;
			$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);
			/**
			 * triggered when the contextmenu is shown for a node
			 * @event
			 * @name show_contextmenu.jstree
			 * @param {Object} node the node
			 * @param {Number} x the x-coordinate of the menu relative to the document
			 * @param {Number} y the y-coordinate of the menu relative to the document
			 * @plugin contextmenu
			 */
			this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
		};
	};

	// contextmenu helper
	(function ($) {
		var right_to_left = false,
			vakata_context = {
				element		: false,
				reference	: false,
				position_x	: 0,
				position_y	: 0,
				items		: [],
				html		: "",
				is_visible	: false
			};

		$.vakata.context = {
			settings : {
				hide_onmouseleave	: 0,
				icons				: true
			},
			_trigger : function (event_name) {
				$(document).triggerHandler("context_" + event_name + ".vakata", {
					"reference"	: vakata_context.reference,
					"element"	: vakata_context.element,
					"position"	: {
						"x" : vakata_context.position_x,
						"y" : vakata_context.position_y
					}
				});
			},
			_execute : function (i) {
				i = vakata_context.items[i];
				return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }))) && i.action ? i.action.call(null, {
							"item"		: i,
							"reference"	: vakata_context.reference,
							"element"	: vakata_context.element,
							"position"	: {
								"x" : vakata_context.position_x,
								"y" : vakata_context.position_y
							}
						}) : false;
			},
			_parse : function (o, is_callback) {
				if(!o) { return false; }
				if(!is_callback) {
					vakata_context.html		= "";
					vakata_context.items	= [];
				}
				var str = "",
					sep = false,
					tmp;

				if(is_callback) { str += "<"+"ul>"; }
				$.each(o, function (i, val) {
					if(!val) { return true; }
					vakata_context.items.push(val);
					if(!sep && val.separator_before) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
					}
					sep = false;
					str += "<"+"li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : vakata_context.reference, "element" : vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
					str += "<"+"a href='#' rel='" + (vakata_context.items.length - 1) + "'>";
					if($.vakata.context.settings.icons) {
						str += "<"+"i ";
						if(val.icon) {
							if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
							else { str += " class='" + val.icon + "' "; }
						}
						str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
					}
					str += ($.isFunction(val.label) ? val.label({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
					if(val.submenu) {
						tmp = $.vakata.context._parse(val.submenu, true);
						if(tmp) { str += tmp; }
					}
					str += "<"+"/li>";
					if(val.separator_after) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
						sep = true;
					}
				});
				str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
				if(is_callback) { str += "</ul>"; }
				/**
				 * triggered on the document when the contextmenu is parsed (HTML is built)
				 * @event
				 * @plugin contextmenu
				 * @name context_parse.vakata
				 * @param {jQuery} reference the element that was right clicked
				 * @param {jQuery} element the DOM element of the menu itself
				 * @param {Object} position the x & y coordinates of the menu
				 */
				if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
				return str.length > 10 ? str : false;
			},
			_show_submenu : function (o) {
				o = $(o);
				if(!o.length || !o.children("ul").length) { return; }
				var e = o.children("ul"),
					x = o.offset().left + o.outerWidth(),
					y = o.offset().top,
					w = e.width(),
					h = e.height(),
					dw = $(window).width() + $(window).scrollLeft(),
					dh = $(window).height() + $(window).scrollTop();
				//        -       
				if(right_to_left) {
					o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
				}
				else {
					o[x + w + 10 > dw ? "addClass" : "removeClass"]("vakata-context-right");
				}
				if(y + h + 10 > dh) {
					e.css("bottom","-1px");
				}
				e.show();
			},
			show : function (reference, position, data) {
				var o, e, x, y, w, h, dw, dh, cond = true;
				if(vakata_context.element && vakata_context.element.length) {
					vakata_context.element.width('');
				}
				switch(cond) {
					case (!position && !reference):
						return false;
					case (!!position && !!reference):
						vakata_context.reference	= reference;
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
					case (!position && !!reference):
						vakata_context.reference	= reference;
						o = reference.offset();
						vakata_context.position_x	= o.left + reference.outerHeight();
						vakata_context.position_y	= o.top;
						break;
					case (!!position && !reference):
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
				}
				if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
					data = $(reference).data('vakata_contextmenu');
				}
				if($.vakata.context._parse(data)) {
					vakata_context.element.html(vakata_context.html);
				}
				if(vakata_context.items.length) {
					vakata_context.element.appendTo("body");
					e = vakata_context.element;
					x = vakata_context.position_x;
					y = vakata_context.position_y;
					w = e.width();
					h = e.height();
					dw = $(window).width() + $(window).scrollLeft();
					dh = $(window).height() + $(window).scrollTop();
					if(right_to_left) {
						x -= (e.outerWidth() - $(reference).outerWidth());
						if(x < $(window).scrollLeft() + 20) {
							x = $(window).scrollLeft() + 20;
						}
					}
					if(x + w + 20 > dw) {
						x = dw - (w + 20);
					}
					if(y + h + 20 > dh) {
						y = dh - (h + 20);
					}

					vakata_context.element
						.css({ "left" : x, "top" : y })
						.show()
						.find('a').first().focus().parent().addClass("vakata-context-hover");
					vakata_context.is_visible = true;
					/**
					 * triggered on the document when the contextmenu is shown
					 * @event
					 * @plugin contextmenu
					 * @name context_show.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("show");
				}
			},
			hide : function () {
				if(vakata_context.is_visible) {
					vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
					vakata_context.is_visible = false;
					/**
					 * triggered on the document when the contextmenu is hidden
					 * @event
					 * @plugin contextmenu
					 * @name context_hide.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("hide");
				}
			}
		};
		$(function () {
			right_to_left = $("body").css("direction") === "rtl";
			var to = false;

			vakata_context.element = $("<ul class='vakata-context'></ul>");
			vakata_context.element
				.on("mouseenter", "li", function (e) {
					e.stopImmediatePropagation();

					if($.contains(this, e.relatedTarget)) {
						//   delegate mouseleave -
						// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
						return;
					}

					if(to) { clearTimeout(to); }
					vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

					$(this)
						.siblings().find("ul").hide().end().end()
						.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
					$.vakata.context._show_submenu(this);
				})
				//  -   ?
				.on("mouseleave", "li", function (e) {
					if($.contains(this, e.relatedTarget)) { return; }
					$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
				})
				.on("mouseleave", function (e) {
					$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
					if($.vakata.context.settings.hide_onmouseleave) {
						to = setTimeout(
							(function (t) {
								return function () { $.vakata.context.hide(); };
							}(this)), $.vakata.context.settings.hide_onmouseleave);
					}
				})
				.on("click", "a", function (e) {
					e.preventDefault();
				//})
				//.on("mouseup", "a", function (e) {
					if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
						$.vakata.context.hide();
					}
				})
				.on('keydown', 'a', function (e) {
						var o = null;
						switch(e.which) {
							case 13:
							case 32:
								e.type = "mouseup";
								e.preventDefault();
								$(e.currentTarget).trigger(e);
								break;
							case 37:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 38:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 39:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 40:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 27:
								$.vakata.context.hide();
								e.preventDefault();
								break;
							default:
								//console.log(e.which);
								break;
						}
					})
				.on('keydown', function (e) {
					e.preventDefault();
					var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
					if(a.parent().not('.vakata-context-disabled')) {
						a.click();
					}
				});

			$(document)
				.on("mousedown.vakata.jstree", function (e) {
					if(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {
						$.vakata.context.hide();
					}
				})
				.on("context_show.vakata.jstree", function (e, data) {
					vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
					if(right_to_left) {
						vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
					}
					// also apply a RTL class?
					vakata_context.element.find("ul").hide().end();
				});
		});
	}($));
	// $.jstree.defaults.plugins.push("contextmenu");

/**
 * ### Drag'n'drop plugin
 *
 * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.
 */

	/**
	 * stores all defaults for the drag'n'drop plugin
	 * @name $.jstree.defaults.dnd
	 * @plugin dnd
	 */
	$.jstree.defaults.dnd = {
		/**
		 * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
		 * @name $.jstree.defaults.dnd.copy
		 * @plugin dnd
		 */
		copy : true,
		/**
		 * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
		 * @name $.jstree.defaults.dnd.open_timeout
		 * @plugin dnd
		 */
		open_timeout : 500,
		/**
		 * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) - return `false` to prevent dragging
		 * @name $.jstree.defaults.dnd.is_draggable
		 * @plugin dnd
		 */
		is_draggable : true,
		/**
		 * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
		 * @name $.jstree.defaults.dnd.check_while_dragging
		 * @plugin dnd
		 */
		check_while_dragging : true,
		/**
		 * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
		 * @name $.jstree.defaults.dnd.always_copy
		 * @plugin dnd
		 */
		always_copy : false,
		/**
		 * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
		 * @name $.jstree.defaults.dnd.inside_pos
		 * @plugin dnd
		 */
		inside_pos : 0,
		/**
		 * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
		 * @name $.jstree.defaults.dnd.drag_selection
		 * @plugin dnd
		 */
		drag_selection : true,
		/**
		 * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
		 * @name $.jstree.defaults.dnd.touch
		 * @plugin dnd
		 */
		touch : true,
		/**
		 * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.
		 * @name $.jstree.defaults.dnd.large_drop_target
		 * @plugin dnd
		 */
		large_drop_target : false,
		/**
		 * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to "selected".
		 * @name $.jstree.defaults.dnd.large_drag_target
		 * @plugin dnd
		 */
		large_drag_target : false
	};
	// TODO: now check works by checking for each node individually, how about max_children, unique, etc?
	$.jstree.plugins.dnd = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
					if(this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
						return true;
					}
					if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
						return true;
					}
					var obj = this.get_node(e.target),
						mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
						txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
					if(this.settings.core.force_text) {
						txt = $.vakata.html.escape(txt);
					}
					if(obj && obj.id && obj.id !== "#" && (e.which === 1 || e.type === "touchstart") &&
						(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]))))
					) {
						this.element.trigger('mousedown.jstree');
						return $.vakata.dnd.start(e, { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_top_selected() : [obj.id] }, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
					}
				}, this));
		};
	};

	$(function() {
		// bind only once for all instances
		var lastmv = false,
			laster = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');

		$(document)
			.on('dnd_start.vakata.jstree', function (e, data) {
				lastmv = false;
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.appendTo('body'); //.show();
			})
			.on('dnd_move.vakata.jstree', function (e, data) {
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }

				// if we are hovering the marker image do nothing (can happen on "inside" drags)
				if(data.event.target.id && data.event.target.id === 'jstree-marker') {
					return;
				}

				var ins = $.jstree.reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm;
				// if we are over an instance
				if(ins && ins._data && ins._data.dnd) {
					marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
					data.helper
						.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
						.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'show' : 'hide' ]();


					// if are hovering the container itself add a new root node
					if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
						ok = true;
						for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
							ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), '#', 'last', { 'dnd' : true, 'ref' : ins.get_node('#'), 'pos' : 'i', 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
							if(!ok) { break; }
						}
						if(ok) {
							lastmv = { 'ins' : ins, 'par' : '#', 'pos' : 'last' };
							marker.hide();
							data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
							return;
						}
					}
					else {
						// if we are hovering a tree node
						ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
						if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
							off = ref.offset();
							rel = data.event.pageY - off.top;
							h = ref.outerHeight();
							if(rel < h / 3) {
								o = ['b', 'i', 'a'];
							}
							else if(rel > h - h / 3) {
								o = ['a', 'i', 'b'];
							}
							else {
								o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
							}
							$.each(o, function (j, v) {
								switch(v) {
									case 'b':
										l = off.left - 6;
										t = off.top;
										p = ins.get_parent(ref);
										i = ref.parent().index();
										break;
									case 'i':
										ip = ins.settings.dnd.inside_pos;
										tm = ins.get_node(ref.parent());
										l = off.left - 2;
										t = off.top + h / 2 + 1;
										p = tm.id;
										i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
										break;
									case 'a':
										l = off.left - 6;
										t = off.top + h;
										p = ins.get_parent(ref);
										i = ref.parent().index() + 1;
										break;
								}
								ok = true;
								for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
									op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
									ps = i;
									if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
										pr = ins.get_node(p);
										if(ps > $.inArray(data.data.nodes[t1], pr.children)) {
											ps -= 1;
										}
									}
									ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
									if(!ok) {
										if(ins && ins.last_error) { laster = ins.last_error(); }
										break;
									}
								}
								if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
									opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
								}
								if(ok) {
									lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
									marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
									data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
									laster = {};
									o = true;
									return false;
								}
							});
							if(o === true) { return; }
						}
					}
				}
				lastmv = false;
				data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
				marker.hide();
			})
			.on('dnd_scroll.vakata.jstree', function (e, data) {
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide();
				lastmv = false;
				data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
			})
			.on('dnd_stop.vakata.jstree', function (e, data) {
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide().detach();
				var i, j, nodes = [];
				if(lastmv) {
					for(i = 0, j = data.data.nodes.length; i < j; i++) {
						nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
					}
					lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
				}
				else {
					i = $(data.event.target).closest('.jstree');
					if(i.length && laster && laster.error && laster.error === 'check') {
						i = i.jstree(true);
						if(i) {
							i.settings.core.error.call(this, laster);
						}
					}
				}
			})
			.on('keyup.jstree keydown.jstree', function (e, data) {
				data = $.vakata.dnd._get();
				if(data && data.data && data.data.jstree) {
					data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
				}
			});
	});

	// helpers
	(function ($) {
		$.vakata.html = {
			div : $('<div />'),
			escape : function (str) {
				return $.vakata.html.div.text(str).html();
			},
			strip : function (str) {
				return $.vakata.html.div.empty().append($.parseHTML(str)).text();
			}
		};
		// private variable
		var vakata_dnd = {
			element	: false,
			target	: false,
			is_down	: false,
			is_drag	: false,
			helper	: false,
			helper_w: 0,
			data	: false,
			init_x	: 0,
			init_y	: 0,
			scroll_l: 0,
			scroll_t: 0,
			scroll_e: false,
			scroll_i: false,
			is_touch: false
		};
		$.vakata.dnd = {
			settings : {
				scroll_speed		: 10,
				scroll_proximity	: 20,
				helper_left			: 5,
				helper_top			: 10,
				threshold			: 5,
				threshold_touch		: 50
			},
			_trigger : function (event_name, e) {
				var data = $.vakata.dnd._get();
				data.event = e;
				$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
			},
			_get : function () {
				return {
					"data"		: vakata_dnd.data,
					"element"	: vakata_dnd.element,
					"helper"	: vakata_dnd.helper
				};
			},
			_clean : function () {
				if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
				if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
				vakata_dnd = {
					element	: false,
					target	: false,
					is_down	: false,
					is_drag	: false,
					helper	: false,
					helper_w: 0,
					data	: false,
					init_x	: 0,
					init_y	: 0,
					scroll_l: 0,
					scroll_t: 0,
					scroll_e: false,
					scroll_i: false,
					is_touch: false
				};
				$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
			},
			_scroll : function (init_only) {
				if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
					if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
					return false;
				}
				if(!vakata_dnd.scroll_i) {
					vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
					return false;
				}
				if(init_only === true) { return false; }

				var i = vakata_dnd.scroll_e.scrollTop(),
					j = vakata_dnd.scroll_e.scrollLeft();
				vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
				vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
				if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
					/**
					 * triggered on the document when a drag causes an element to scroll
					 * @event
					 * @plugin dnd
					 * @name dnd_scroll.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {jQuery} event the element that is scrolling
					 */
					$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
				}
			},
			start : function (e, data, html) {
				if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
				try {
					e.currentTarget.unselectable = "on";
					e.currentTarget.onselectstart = function() { return false; };
					if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
				} catch(ignore) { }
				vakata_dnd.init_x	= e.pageX;
				vakata_dnd.init_y	= e.pageY;
				vakata_dnd.data		= data;
				vakata_dnd.is_down	= true;
				vakata_dnd.element	= e.currentTarget;
				vakata_dnd.target	= e.target;
				vakata_dnd.is_touch	= e.type === "touchstart";
				if(html !== false) {
					vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
						"display"		: "block",
						"margin"		: "0",
						"padding"		: "0",
						"position"		: "absolute",
						"top"			: "-2000px",
						"lineHeight"	: "16px",
						"zIndex"		: "10000"
					});
				}
				$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
				return false;
			},
			drag : function (e) {
				if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(!vakata_dnd.is_down) { return; }
				if(!vakata_dnd.is_drag) {
					if(
						Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
						Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
					) {
						if(vakata_dnd.helper) {
							vakata_dnd.helper.appendTo("body");
							vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
						}
						vakata_dnd.is_drag = true;
						/**
						 * triggered on the document when a drag starts
						 * @event
						 * @plugin dnd
						 * @name dnd_start.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {Object} event the event that caused the start (probably mousemove)
						 */
						$.vakata.dnd._trigger("start", e);
					}
					else { return; }
				}

				var d  = false, w  = false,
					dh = false, wh = false,
					dw = false, ww = false,
					dt = false, dl = false,
					ht = false, hl = false;

				vakata_dnd.scroll_t = 0;
				vakata_dnd.scroll_l = 0;
				vakata_dnd.scroll_e = false;
				$($(e.target).parentsUntil("body").addBack().get().reverse())
					.filter(function () {
						return	(/^auto|scroll$/).test($(this).css("overflow")) &&
								(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
					})
					.each(function () {
						var t = $(this), o = t.offset();
						if(this.scrollHeight > this.offsetHeight) {
							if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
							if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
						}
						if(this.scrollWidth > this.offsetWidth) {
							if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
							if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
						}
						if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
							vakata_dnd.scroll_e = $(this);
							return false;
						}
					});

				if(!vakata_dnd.scroll_e) {
					d  = $(document); w = $(window);
					dh = d.height(); wh = w.height();
					dw = d.width(); ww = w.width();
					dt = d.scrollTop(); dl = d.scrollLeft();
					if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
					if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
					if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
					if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
					if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
						vakata_dnd.scroll_e = d;
					}
				}
				if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

				if(vakata_dnd.helper) {
					ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
					hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
					if(dh && ht + 25 > dh) { ht = dh - 50; }
					if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
					vakata_dnd.helper.css({
						left	: hl + "px",
						top		: ht + "px"
					});
				}
				/**
				 * triggered on the document when a drag is in progress
				 * @event
				 * @plugin dnd
				 * @name dnd_move.vakata
				 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
				 * @param {DOM} element the DOM element being dragged
				 * @param {jQuery} helper the helper shown next to the mouse
				 * @param {Object} event the event that caused this to trigger (most likely mousemove)
				 */
				$.vakata.dnd._trigger("move", e);
				return false;
			},
			stop : function (e) {
				if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) {
					/**
					 * triggered on the document when a drag stops (the dragged element is dropped)
					 * @event
					 * @plugin dnd
					 * @name dnd_stop.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {Object} event the event that caused the stop
					 */
					$.vakata.dnd._trigger("stop", e);
				}
				else {
					if(e.type === "touchend" && e.target === vakata_dnd.target) {
						var to = setTimeout(function () { $(e.target).click(); }, 100);
						$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
					}
				}
				$.vakata.dnd._clean();
				return false;
			}
		};
	}($));

	// include the dnd plugin by default
	// $.jstree.defaults.plugins.push("dnd");


/**
 * ### Massload plugin
 *
 * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).
 */

	/**
	 * massload configuration
	 *
	 * It is possible to set this to a standard jQuery-like AJAX config.
	 * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.
	 *
	 * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.
	 *
	 * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.
	 *
	 *	{
	 *		"id1" : [{ "text" : "Child of ID1", "id" : "c1" }, { "text" : "Another child of ID1", "id" : "c2" }],
	 *		"id2" : [{ "text" : "Child of ID2", "id" : "c3" }]
	 *	}
	 * 
	 * @name $.jstree.defaults.massload
	 * @plugin massload
	 */
	$.jstree.defaults.massload = null;
	$.jstree.plugins.massload = function (options, parent) {
		this.init = function (el, options) {
			parent.init.call(this, el, options);
			this._data.massload = {};
		};
		this._load_nodes = function (nodes, callback, is_callback) {
			var s = this.settings.massload;
			if(is_callback && !$.isEmptyObject(this._data.massload)) {
				return parent._load_nodes.call(this, nodes, callback, is_callback);
			}
			if($.isFunction(s)) {
				return s.call(this, nodes, $.proxy(function (data) {
					if(data) {
						for(var i in data) {
							if(data.hasOwnProperty(i)) {
								this._data.massload[i] = data[i];
							}
						}
					}
					parent._load_nodes.call(this, nodes, callback, is_callback);
				}, this));
			}
			if(typeof s === 'object' && s && s.url) {
				s = $.extend(true, {}, s);
				if($.isFunction(s.url)) {
					s.url = s.url.call(this, nodes);
				}
				if($.isFunction(s.data)) {
					s.data = s.data.call(this, nodes);
				}
				return $.ajax(s)
					.done($.proxy(function (data,t,x) {
							if(data) {
								for(var i in data) {
									if(data.hasOwnProperty(i)) {
										this._data.massload[i] = data[i];
									}
								}
							}
							parent._load_nodes.call(this, nodes, callback, is_callback);
						}, this))
					.fail($.proxy(function (f) {
							parent._load_nodes.call(this, nodes, callback, is_callback);
						}, this));
			}
			return parent._load_nodes.call(this, nodes, callback, is_callback);
		};
		this._load_node = function (obj, callback) {
			var d = this._data.massload[obj.id];
			if(d) {
				return this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(function () { return this.nodeType !== 3; }) : d, function (status) {
					callback.call(this, status);
					delete this._data.massload[obj.id];
				});
			}
			return parent._load_node.call(this, obj, callback);
		};
	};

/**
 * ### Search plugin
 *
 * Adds search functionality to jsTree.
 */

	/**
	 * stores all defaults for the search plugin
	 * @name $.jstree.defaults.search
	 * @plugin search
	 */
	$.jstree.defaults.search = {
		/**
		 * a jQuery-like AJAX config, which jstree uses if a server should be queried for results. 
		 * 
		 * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
		 * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to 
		 * @name $.jstree.defaults.search.ajax
		 * @plugin search
		 */
		ajax : false,
		/**
		 * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
		 * @name $.jstree.defaults.search.fuzzy
		 * @plugin search
		 */
		fuzzy : false,
		/**
		 * Indicates if the search should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.search.case_sensitive
		 * @plugin search
		 */
		case_sensitive : false,
		/**
		 * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers). 
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches
		 * @plugin search
		 */
		show_only_matches : false,
		/**
		 * Indicates if the children of matched element are shown (when show_only_matches is true)
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches_children
		 * @plugin search
		 */
		show_only_matches_children : false,
		/**
		 * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
		 * @name $.jstree.defaults.search.close_opened_onclear
		 * @plugin search
		 */
		close_opened_onclear : true,
		/**
		 * Indicates if only leaf nodes should be included in search results. Default is `false`.
		 * @name $.jstree.defaults.search.search_leaves_only
		 * @plugin search
		 */
		search_leaves_only : false,
		/**
		 * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
		 * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
		 * @name $.jstree.defaults.search.search_callback
		 * @plugin search
		 */
		search_callback : false
	};

	$.jstree.plugins.search = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this._data.search.str = "";
			this._data.search.dom = $();
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.som = false;
			this._data.search.smc = false;

			this.element
				.on('before_open.jstree', $.proxy(function (e, data) {
						var i, j, f, r = this._data.search.res, s = [], o = $();
						if(r && r.length) {
							this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
							this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
							if(this._data.search.som && this._data.search.res.length) {
								for(i = 0, j = r.length; i < j; i++) {
									s = s.concat(this.get_node(r[i]).parents);
								}
								s = $.vakata.array_remove_item($.vakata.array_unique(s),'#');
								o = s.length ? $(this.element[0].querySelectorAll('#' + $.map(s, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))) : $();

								this.element.find(".jstree-node").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
								o = o.add(this._data.search.dom);
								if(this._data.search.smc) {
									this._data.search.dom.children(".jstree-children").find(".jstree-node").show();
								}
								o.parentsUntil(".jstree").addBack().show()
									.filter(".jstree-children").each(function () { $(this).children(".jstree-node:visible").eq(-1).addClass("jstree-last"); });
							}
						}
					}, this))
				.on("search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som) {
							if(data.nodes.length) {
								this.element.find(".jstree-node").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
								if(this._data.search.smc) {
									data.nodes.children(".jstree-children").find(".jstree-node").show();
								}
								data.nodes.parentsUntil(".jstree").addBack().show()
									.filter(".jstree-children").each(function () { $(this).children(".jstree-node:visible").eq(-1).addClass("jstree-last"); });
							}
						}
					}, this))
				.on("clear_search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som && data.nodes.length) {
							this.element.find(".jstree-node").css("display","").filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
						}
					}, this));
		};
		/**
		 * used to search the tree nodes for a given string
		 * @name search(str [, skip_async])
		 * @param {String} str the search string
		 * @param {Boolean} skip_async if set to true server will not be queried even if configured
		 * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
		 * @param {mixed} inside an optional node to whose children to limit the search
		 * @param {Boolean} append if set to true the results of this search are appended to the previous search
		 * @plugin search
		 * @trigger search.jstree
		 */
		this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
			if(str === false || $.trim(str.toString()) === "") {
				return this.clear_search();
			}
			inside = this.get_node(inside);
			inside = inside && inside.id ? inside.id : null;
			str = str.toString();
			var s = this.settings.search,
				a = s.ajax ? s.ajax : false,
				m = this._model.data,
				f = null,
				r = [],
				p = [], i, j;
			if(this._data.search.res.length && !append) {
				this.clear_search();
			}
			if(show_only_matches === undefined) {
				show_only_matches = s.show_only_matches;
			}
			if(show_only_matches_children === undefined) {
				show_only_matches_children = s.show_only_matches_children;
			}
			if(!skip_async && a !== false) {
				if($.isFunction(a)) {
					return a.call(this, str, $.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append);
							}, true);
						}, this), inside);
				}
				else {
					a = $.extend({}, a);
					if(!a.data) { a.data = {}; }
					a.data.str = str;
					if(inside) {
						a.data.inside = inside;
					}
					return $.ajax(a)
						.fail($.proxy(function () {
							this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
							this.settings.core.error.call(this, this._data.core.last_error);
						}, this))
						.done($.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append);
							}, true);
						}, this));
				}
			}
			if(!append) {
				this._data.search.str = str;
				this._data.search.dom = $();
				this._data.search.res = [];
				this._data.search.opn = [];
				this._data.search.som = show_only_matches;
				this._data.search.smc = show_only_matches_children;
			}

			f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });
			$.each(m[inside ? inside : '#'].children_d, function (ii, i) {
				var v = m[i];
				if(v.text && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) ) {
					r.push(i);
					p = p.concat(v.parents);
				}
			});
			if(r.length) {
				p = $.vakata.array_unique(p);
				this._search_open(p);
				if(!append) {
					this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
					this._data.search.res = r;
				}
				else {
					this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))));
					this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
				}
				this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes
			 * @param {String} str the search string
			 * @param {Array} res a collection of objects represeing the matching nodes
			 * @plugin search
			 */
			this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
		};
		/**
		 * used to clear the last search (removes classes and shows all nodes if filtering is on)
		 * @name clear_search()
		 * @plugin search
		 * @trigger clear_search.jstree
		 */
		this.clear_search = function () {
			this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
			if(this.settings.search.close_opened_onclear) {
				this.close_node(this._data.search.opn, 0);
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name clear_search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
			 * @param {String} str the search string (the last search string)
			 * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
			 * @plugin search
			 */
			this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
			this._data.search.str = "";
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.dom = $();
		};
		/**
		 * opens nodes that need to be opened to reveal the search results. Used only internally.
		 * @private
		 * @name _search_open(d)
		 * @param {Array} d an array of node IDs
		 * @plugin search
		 */
		this._search_open = function (d) {
			var t = this;
			$.each(d.concat([]), function (i, v) {
				if(v === "#") { return true; }
				try { v = $('#' + v.replace($.jstree.idregex,'\\$&'), t.element); } catch(ignore) { }
				if(v && v.length) {
					if(t.is_closed(v)) {
						t._data.search.opn.push(v[0].id);
						t.open_node(v, function () { t._search_open(d); }, 0);
					}
				}
			});
		};
	};

	// helpers
	(function ($) {
		// from http://kiro.me/projects/fuse.html
		$.vakata.search = function(pattern, txt, options) {
			options = options || {};
			options = $.extend({}, $.vakata.search.defaults, options);
			if(options.fuzzy !== false) {
				options.fuzzy = true;
			}
			pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
			var MATCH_LOCATION	= options.location,
				MATCH_DISTANCE	= options.distance,
				MATCH_THRESHOLD	= options.threshold,
				patternLen = pattern.length,
				matchmask, pattern_alphabet, match_bitapScore, search;
			if(patternLen > 32) {
				options.fuzzy = false;
			}
			if(options.fuzzy) {
				matchmask = 1 << (patternLen - 1);
				pattern_alphabet = (function () {
					var mask = {},
						i = 0;
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] = 0;
					}
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
					}
					return mask;
				}());
				match_bitapScore = function (e, x) {
					var accuracy = e / patternLen,
						proximity = Math.abs(MATCH_LOCATION - x);
					if(!MATCH_DISTANCE) {
						return proximity ? 1.0 : accuracy;
					}
					return accuracy + (proximity / MATCH_DISTANCE);
				};
			}
			search = function (text) {
				text = options.caseSensitive ? text : text.toLowerCase();
				if(pattern === text || text.indexOf(pattern) !== -1) {
					return {
						isMatch: true,
						score: 0
					};
				}
				if(!options.fuzzy) {
					return {
						isMatch: false,
						score: 1
					};
				}
				var i, j,
					textLen = text.length,
					scoreThreshold = MATCH_THRESHOLD,
					bestLoc = text.indexOf(pattern, MATCH_LOCATION),
					binMin, binMid,
					binMax = patternLen + textLen,
					lastRd, start, finish, rd, charMatch,
					score = 1,
					locations = [];
				if (bestLoc !== -1) {
					scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
					if (bestLoc !== -1) {
						scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					}
				}
				bestLoc = -1;
				for (i = 0; i < patternLen; i++) {
					binMin = 0;
					binMid = binMax;
					while (binMin < binMid) {
						if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
							binMin = binMid;
						} else {
							binMax = binMid;
						}
						binMid = Math.floor((binMax - binMin) / 2 + binMin);
					}
					binMax = binMid;
					start = Math.max(1, MATCH_LOCATION - binMid + 1);
					finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
					rd = new Array(finish + 2);
					rd[finish + 1] = (1 << i) - 1;
					for (j = finish; j >= start; j--) {
						charMatch = pattern_alphabet[text.charAt(j - 1)];
						if (i === 0) {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
						} else {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
						}
						if (rd[j] & matchmask) {
							score = match_bitapScore(i, j - 1);
							if (score <= scoreThreshold) {
								scoreThreshold = score;
								bestLoc = j - 1;
								locations.push(bestLoc);
								if (bestLoc > MATCH_LOCATION) {
									start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
								} else {
									break;
								}
							}
						}
					}
					if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
						break;
					}
					lastRd = rd;
				}
				return {
					isMatch: bestLoc >= 0,
					score: score
				};
			};
			return txt === true ? { 'search' : search } : search(txt);
		};
		$.vakata.search.defaults = {
			location : 0,
			distance : 100,
			threshold : 0.6,
			fuzzy : false,
			caseSensitive : false
		};
	}($));

	// include the search plugin by default
	// $.jstree.defaults.plugins.push("search");

/**
 * ### Sort plugin
 *
 * Automatically sorts all siblings in the tree according to a sorting function.
 */

	/**
	 * the settings function used to sort the nodes.
	 * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
	 * @name $.jstree.defaults.sort
	 * @plugin sort
	 */
	$.jstree.defaults.sort = function (a, b) {
		//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
		return this.get_text(a) > this.get_text(b) ? 1 : -1;
	};
	$.jstree.plugins.sort = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this.element
				.on("model.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, true);
					}, this))
				.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent || data.node.parent, false);
						this.redraw_node(data.parent || data.node.parent, true);
					}, this))
				.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, false);
						this.redraw_node(data.parent, true);
					}, this));
		};
		/**
		 * used to sort a node's children
		 * @private
		 * @name sort(obj [, deep])
		 * @param  {mixed} obj the node
		 * @param {Boolean} deep if set to `true` nodes are sorted recursively.
		 * @plugin sort
		 * @trigger search.jstree
		 */
		this.sort = function (obj, deep) {
			var i, j;
			obj = this.get_node(obj);
			if(obj && obj.children && obj.children.length) {
				obj.children.sort($.proxy(this.settings.sort, this));
				if(deep) {
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						this.sort(obj.children_d[i], false);
					}
				}
			}
		};
	};

	// include the sort plugin by default
	// $.jstree.defaults.plugins.push("sort");

/**
 * ### State plugin
 *
 * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)
 */

	var to = false;
	/**
	 * stores all defaults for the state plugin
	 * @name $.jstree.defaults.state
	 * @plugin state
	 */
	$.jstree.defaults.state = {
		/**
		 * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
		 * @name $.jstree.defaults.state.key
		 * @plugin state
		 */
		key		: 'jstree',
		/**
		 * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
		 * @name $.jstree.defaults.state.events
		 * @plugin state
		 */
		events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
		/**
		 * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
		 * @name $.jstree.defaults.state.ttl
		 * @plugin state
		 */
		ttl		: false,
		/**
		 * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
		 * @name $.jstree.defaults.state.filter
		 * @plugin state
		 */
		filter	: false
	};
	$.jstree.plugins.state = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			var bind = $.proxy(function () {
				this.element.on(this.settings.state.events, $.proxy(function () {
					if(to) { clearTimeout(to); }
					to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
				}, this));
				/**
				 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
				 * @event
				 * @name state_ready.jstree
				 * @plugin state
				 */
				this.trigger('state_ready');
			}, this);
			this.element
				.on("ready.jstree", $.proxy(function (e, data) {
						this.element.one("restore_state.jstree", bind);
						if(!this.restore_state()) { bind(); }
					}, this));
		};
		/**
		 * save the state
		 * @name save_state()
		 * @plugin state
		 */
		this.save_state = function () {
			var st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
			$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
		};
		/**
		 * restore the state from the user's computer
		 * @name restore_state()
		 * @plugin state
		 */
		this.restore_state = function () {
			var k = $.vakata.storage.get(this.settings.state.key);
			if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
			if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
			if(!!k && k.state) { k = k.state; }
			if(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
			if(!!k) {
				this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });
				this.set_state(k);
				return true;
			}
			return false;
		};
		/**
		 * clear the state on the user's computer
		 * @name clear_state()
		 * @plugin state
		 */
		this.clear_state = function () {
			return $.vakata.storage.del(this.settings.state.key);
		};
	};

	(function ($, undefined) {
		$.vakata.storage = {
			// simply specifying the functions in FF throws an error
			set : function (key, val) { return window.localStorage.setItem(key, val); },
			get : function (key) { return window.localStorage.getItem(key); },
			del : function (key) { return window.localStorage.removeItem(key); }
		};
	}($));

	// include the state plugin by default
	// $.jstree.defaults.plugins.push("state");

/**
 * ### Types plugin
 *
 * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.
 */

	/**
	 * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
	 *
	 * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
	 * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
	 * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
	 * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
	 *
	 * There are two predefined types:
	 *
	 * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
	 * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
	 *
	 * @name $.jstree.defaults.types
	 * @plugin types
	 */
	$.jstree.defaults.types = {
		'#' : {},
		'default' : {}
	};

	$.jstree.plugins.types = function (options, parent) {
		this.init = function (el, options) {
			var i, j;
			if(options && options.types && options.types['default']) {
				for(i in options.types) {
					if(i !== "default" && i !== "#" && options.types.hasOwnProperty(i)) {
						for(j in options.types['default']) {
							if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
								options.types[i][j] = options.types['default'][j];
							}
						}
					}
				}
			}
			parent.init.call(this, el, options);
			this._model.data['#'].type = '#';
		};
		this.refresh = function (skip_loading, forget_state) {
			parent.refresh.call(this, skip_loading, forget_state);
			this._model.data['#'].type = '#';
		};
		this.bind = function () {
			this.element
				.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							dpc = data.nodes,
							t = this.settings.types,
							i, j, c = 'default';
						for(i = 0, j = dpc.length; i < j; i++) {
							c = 'default';
							if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
								c = m[dpc[i]].original.type;
							}
							if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
								c = m[dpc[i]].data.jstree.type;
							}
							m[dpc[i]].type = c;
							if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
								m[dpc[i]].icon = t[c].icon;
							}
						}
						m['#'].type = '#';
					}, this));
			parent.bind.call(this);
		};
		this.get_json = function (obj, options, flat) {
			var i, j,
				m = this._model.data,
				opt = options ? $.extend(true, {}, options, {no_id:false}) : {},
				tmp = parent.get_json.call(this, obj, opt, flat);
			if(tmp === false) { return false; }
			if($.isArray(tmp)) {
				for(i = 0, j = tmp.length; i < j; i++) {
					tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
					if(options && options.no_id) {
						delete tmp[i].id;
						if(tmp[i].li_attr && tmp[i].li_attr.id) {
							delete tmp[i].li_attr.id;
						}
						if(tmp[i].a_attr && tmp[i].a_attr.id) {
							delete tmp[i].a_attr.id;
						}
					}
				}
			}
			else {
				tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
				if(options && options.no_id) {
					tmp = this._delete_ids(tmp);
				}
			}
			return tmp;
		};
		this._delete_ids = function (tmp) {
			if($.isArray(tmp)) {
				for(var i = 0, j = tmp.length; i < j; i++) {
					tmp[i] = this._delete_ids(tmp[i]);
				}
				return tmp;
			}
			delete tmp.id;
			if(tmp.li_attr && tmp.li_attr.id) {
				delete tmp.li_attr.id;
			}
			if(tmp.a_attr && tmp.a_attr.id) {
				delete tmp.a_attr.id;
			}
			if(tmp.children && $.isArray(tmp.children)) {
				tmp.children = this._delete_ids(tmp.children);
			}
			return tmp;
		};
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
			m = m && m._model && m._model.data ? m._model.data : null;
			switch(chk) {
				case "create_node":
				case "move_node":
				case "copy_node":
					if(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
						tmp = this.get_rules(par);
						if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(m && obj.children_d && obj.parents) {
							d = 0;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								d = Math.max(d, m[obj.children_d[i]].parents.length);
							}
							d = d - obj.parents.length + 1;
						}
						if(d <= 0 || d === undefined) { d = 1; }
						do {
							if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							par = this.get_node(par.parent);
							tmp = this.get_rules(par);
							d++;
						} while(par);
					}
					break;
			}
			return true;
		};
		/**
		 * used to retrieve the type settings object for a node
		 * @name get_rules(obj)
		 * @param {mixed} obj the node to find the rules for
		 * @return {Object}
		 * @plugin types
		 */
		this.get_rules = function (obj) {
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var tmp = this.get_type(obj, true);
			if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
			if(tmp.max_children === undefined) { tmp.max_children = -1; }
			if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
			return tmp;
		};
		/**
		 * used to retrieve the type string or settings object for a node
		 * @name get_type(obj [, rules])
		 * @param {mixed} obj the node to find the rules for
		 * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
		 * @return {String|Object}
		 * @plugin types
		 */
		this.get_type = function (obj, rules) {
			obj = this.get_node(obj);
			return (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
		};
		/**
		 * used to change a node's type
		 * @name set_type(obj, type)
		 * @param {mixed} obj the node to change
		 * @param {String} type the new type
		 * @plugin types
		 */
		this.set_type = function (obj, type) {
			var t, t1, t2, old_type, old_icon;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_type(obj[t1], type);
				}
				return true;
			}
			t = this.settings.types;
			obj = this.get_node(obj);
			if(!t[type] || !obj) { return false; }
			old_type = obj.type;
			old_icon = this.get_icon(obj);
			obj.type = type;
			if(old_icon === true || (t[old_type] && t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
				this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
			}
			return true;
		};
	};
	// include the types plugin by default
	// $.jstree.defaults.plugins.push("types");

/**
 * ### Unique plugin
 *
 * Enforces that no nodes with the same name can coexist as siblings.
 */

	/**
	 * stores all defaults for the unique plugin
	 * @name $.jstree.defaults.unique
	 * @plugin unique
	 */
	$.jstree.defaults.unique = {
		/**
		 * Indicates if the comparison should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.unique.case_sensitive
		 * @plugin unique
		 */
		case_sensitive : false,
		/**
		 * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
		 * @name $.jstree.defaults.unique.duplicate
		 * @plugin unique
		 */
		duplicate : function (name, counter) {
			return name + ' (' + counter + ')';
		}
	};

	$.jstree.plugins.unique = function (options, parent) {
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			if(!par || !par.children) { return true; }
			var n = chk === "rename_node" ? pos : obj.text,
				c = [],
				s = this.settings.unique.case_sensitive,
				m = this._model.data, i, j;
			for(i = 0, j = par.children.length; i < j; i++) {
				c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
			}
			if(!s) { n = n.toLowerCase(); }
			switch(chk) {
				case "delete_node":
					return true;
				case "rename_node":
					i = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "create_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "copy_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "move_node":
					i = ( (obj.parent === par.id && (!more || !more.is_multi)) || $.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
			}
			return true;
		};
		this.create_node = function (par, node, pos, callback, is_loaded) {
			if(!node || node.text === undefined) {
				if(par === null) {
					par = "#";
				}
				par = this.get_node(par);
				if(!par) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				pos = pos === undefined ? "last" : pos;
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				if(!node) { node = {}; }
				var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
				n = tmp = this.get_string('New node');
				dpc = [];
				for(i = 0, j = par.children.length; i < j; i++) {
					dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
				}
				i = 1;
				while($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
					n = cb.call(this, tmp, (++i)).toString();
				}
				node.text = n;
			}
			return parent.create_node.call(this, par, node, pos, callback, is_loaded);
		};
	};

	// include the unique plugin by default
	// $.jstree.defaults.plugins.push("unique");


/**
 * ### Wholerow plugin
 *
 * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.
 */

	var div = document.createElement('DIV');
	div.setAttribute('unselectable','on');
	div.setAttribute('role','presentation');
	div.className = 'jstree-wholerow';
	div.innerHTML = '&#160;';
	$.jstree.plugins.wholerow = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('ready.jstree set_state.jstree', $.proxy(function () {
						this.hide_dots();
					}, this))
				.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
						//div.style.height = this._data.core.li_height + 'px';
						this.get_container_ul().addClass('jstree-wholerow-ul');
					}, this))
				.on("deselect_all.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
					}, this))
				.on("changed.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
						var tmp = false, i, j;
						for(i = 0, j = data.selected.length; i < j; i++) {
							tmp = this.get_node(data.selected[i], true);
							if(tmp && tmp.length) {
								tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
							}
						}
					}, this))
				.on("open_node.jstree", $.proxy(function (e, data) {
						this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
					}, this))
				.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
						if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
						this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
					}, this))
				.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
						e.preventDefault();
						var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
					}, this))
				/*!
				.on("mousedown.jstree touchstart.jstree", ".jstree-wholerow", function (e) {
						if(e.target === e.currentTarget) {
							var a = $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor");
							e.target = a[0];
							a.trigger(e);
						}
					})
				*/
				.on("click.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					}, this))
				.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if(!this.is_disabled(e.currentTarget)) {
							this.hover_node(e.currentTarget);
						}
						return false;
					}, this))
				.on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		};
		this.teardown = function () {
			if(this.settings.wholerow) {
				this.element.find(".jstree-wholerow").remove();
			}
			parent.teardown.call(this);
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var tmp = div.cloneNode(true);
				//tmp.style.height = this._data.core.li_height + 'px';
				if($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
				if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
				obj.insertBefore(tmp, obj.childNodes[0]);
			}
			return obj;
		};
	};
	// include the wholerow plugin by default
	// $.jstree.defaults.plugins.push("wholerow");
	if(document.registerElement && Object && Object.create) {
		var proto = Object.create(HTMLElement.prototype);
		proto.createdCallback = function () {
			var c = { core : {}, plugins : [] }, i;
			for(i in $.jstree.plugins) {
				if($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
					c.plugins.push(i);
					if(this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
						c[i] = JSON.parse(this.getAttribute(i));
					}
				}
			}
			for(i in $.jstree.defaults.core) {
				if($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
					c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
				}
			}
			$(this).jstree(c);
		};
		// proto.attributeChangedCallback = function (name, previous, value) { };
		try {
			document.registerElement("vakata-jstree", { prototype: proto });
		} catch(ignore) { }
	}

}));

// new treedata

it.TreeView = function(mainPane){
    this.mainPane = mainPane;
    if(!this.mainPane){
        this.mainPane = $('body');
    }
    var self = this;
    this.treeView = $('<div id = "plugin_tree_view_id" class="black-font-color"></div>');
        // onsetData
    this.treeView
        .on("changed.jstree", function(e, data){
            self.clickNode(e, data);
        })
        .on("hover_node.jstree", function(e, data){
            self.mouseover(e, data);
        })
        .jstree({
                'core' : {
                    'data' : [],
                    "themes": { "theme": "default", "dots": false, "icons": true } //"dots": false,
               }
       });
    this.treePane = $('<div id="tree-content" class="scroll-class" style="height:100px;overflow:auto; position: relative;display: block;top:15px"></div>');
    this.treePane.append(this.treeView);
    this.mainPane.append(this.treePane);
    this.dataSet = null;

    this.clickNodeFunction = null;
    this.mouseoverNodeFunction = null;
    this.sortFunction = null;

};

mono.extend(it.TreeView,Object,{

    isClick : function(data){
        return true;
    },

    clickNode : function(e, data){
        if(data.selected.length) {
            var asset = data.instance.get_node(data.selected[0]);
            if(asset.select_flag){ // 
                delete asset.select_flag;
                return;
            }
            if(asset.original) {
                if(this.clickNodeFunction){
                    this.clickNodeFunction(asset.original,data);
                }
            }
        }
    },

    mouseover : function(e,data){
        if(!data || !data.node || !data.node.original){
            return ;
        }
        if(this.mouseoverNodeFunction){
            this.mouseoverNodeFunction(data.node.original);
        }
        var tooltopText = data.node.original.text;
        if(tooltopText){
            tooltopText = tooltopText.replace('<label color=#F00>','');
            tooltopText = tooltopText.replace('</label>','');
            var nodeId = data.node.id;
            if (nodeId) {
                nodeId = nodeId.replaceAll('/','\\/');
                // nodeId = nodeId.replace('\\','\\\\');
                nodeId = nodeId.replaceAll('@','\\@');
            }
            $("#"+nodeId).prop('title',tooltopText);
        }
    },

    isSortById : function(){
        return false;
    },

    /**
     * tree
     * @param treeNode1 tree
     * @param treeNode2 tree
     * @returns {number}
     */
    sort: function(treeNode1, treeNode2) {
        if (this.sortFunction) {
            return this.sortFunction(treeNode1, treeNode2);
        }
        // if (treeNode1 && treeNode2 && treeNode1.text && treeNode2.text) {
        //     if (treeNode1.text > treeNode2.text) {
        //         return 1;
        //     }else if (treeNode2.text > treeNode1.text) {
        //         return -1;
        //     }else {
        //         return 0;
        //     }
        // }
        // return 0;
        var text1, text2;
        if (treeNode1) {
            if (this.isSortById()) {
                text1 = treeNode1.id;
            } else {
                text1 = treeNode1.text;
            }
        } else {
            text1 = treeNode1;
        }
        if (treeNode2) {
            if (this.isSortById()) {
                text1 = treeNode2.id;
            } else {
                text2 = treeNode2.text;
            }
        } else {
            text2 = treeNode2;
        }
        return it.Util.compare(text1, text2);
    },

    /**
     * tree
     * @param data{[]} 
     * @param withIcon truefalse
     */
    setData: function (data, withIcon) {
        if(!this.dataSet && !data) return ;
        this.dataSet = data;
        if (this.treeView.jstree(false)
            && this.treeView.jstree(false)._model
            && this.treeView.jstree(false)._model.data) {
            this.treeView.jstree(false)._model.data = {}; //model
        }
        this.treeView.data('jstree', false).empty();
        if (!data) return;
        var icons = true;
        if (withIcon != undefined) {
            icons = withIcon;
        }

        var self = this;

        this.treeView.data('jstree', false).empty()
            .jstree({
                'core': {
                    'data': data,
                    "themes": { "theme": "default", "dots": true, "icons": icons } //"dots": false
                },

                "plugins": ["sort"],

                'sort': function (a, b) {
                    var a_org_node = this.get_node(a) ? this.get_node(a).original : null;
                    var b_org_node = this.get_node(b) ? this.get_node(b).original : null;
                    return self.sort(a_org_node,b_org_node);
                }

            });

    },

    setSelectNode : function(nodeId){
        if (!nodeId) return;
        var mainTree = this.treeView.jstree(true);
        var var_node = mainTree.get_node(nodeId);
        if (var_node) {
            var_node.select_flag = true; // ,
        }
        mainTree.deselect_all();
        mainTree.select_node(nodeId);
        this.scrollTreeByNodeId(nodeId);
    },

    getNodeById : function(nodeId){
        if (!nodeId) return;
        var mainTree = this.treeView.jstree(true);
        return mainTree.get_node(nodeId);
    },

    clearTreeData: function () {
        this.treeView.data('jstree', false).empty();
    },

    show: function () {
        this.treeView.show();
    },

    hidden: function () {
        this.treeView.hide();
    },

    /**
     * 
     * @param idOrNode
     */
    open : function(idOrNode){

    },

    /**
     * 
     * @param idOrNode
     */
    close : function(idOrNode){

    },

    /**
     * 
     * @param nodeId
     */
    scrollTreeByNodeId: function (nodeId) {
        if (!nodeId) return;
        var div_select_row = $('#' + nodeId);
        if (!div_select_row || div_select_row.length < 1) {
            return;
        }

        var min_top_offset =  0;
        if(this.treePane.parent() && this.treePane.parent().height() > 0){
            min_top_offset = this.treePane.parent().height() - this.treePane.height();
        }

        var tree_content = this.treePane; // $('#tree-content');
        var tree_content_height = tree_content[0].clientHeight;//$('#tree-content').height();
        if (!tree_content_height) {
            tree_content_height = 400;
        }
        var select_row_offset_top = 0;
        if (div_select_row.offset()) {
            select_row_offset_top = div_select_row.offset().top;
        }

        if (select_row_offset_top < min_top_offset) { // rowtree+
            var new_scrollTop = tree_content.scrollTop() - (min_top_offset - select_row_offset_top);
            if (new_scrollTop) {
                tree_content.scrollTop(new_scrollTop);
            }
        } else if (select_row_offset_top > tree_content_height + min_top_offset) {
            //,tree-
            var new_scrollTop = tree_content.scrollTop() + (select_row_offset_top - (tree_content_height + min_top_offset) + 70 );
            if (new_scrollTop) {
                tree_content.scrollTop(new_scrollTop);
            }
        }
    },

    /**
     * height
     * @private
     */
    setTreeHeight: function (height) {
        if(height && height > 15){
            this.treePane.height(height-15);
        }
    }

});


/**
 * 
 */
/**
 *
 * @param dataManager
 * @param dataType it.Datait.Link
 * @constructor
 */
it.OrganizeTreeManager = function(dataManager,dataType){
    if(!dataManager){
        console.log('dataManager can not be null');
    }
    this.dataManager = dataManager;
    this.dataType = dataType;
};

mono.extend(it.OrganizeTreeManager,Object,{

    includeParent : function(data){
        return true;
    },

    getDataByNode : function(treeNode){
        if(treeNode && treeNode.id){
            return this.getDataById(treeNode.id);
        }
        return null;
    },

    /**
     * 
     * @param id
     * @returns {*}
     */
    getDataById : function(id){
        if(!id) return null;
        if(this.dataType && this.dataType === 'link'){
            return this.dataManager.getLinkById(id);
        }else{
            return this.dataManager.getDataById(id);
        }
    },

    isOpen : function(data){
        return true;
    },

    /**
     * 
     * @param data
     * @returns {*}
     */
    createLabel : function(data){
        if(data){
            return data.getId();
        }else{
            return "";
        }
    },

    /**
     * 
     * @param data
     * @returns {*}
     */
    getParentIdByData : function(data){
        if(!data){
            return null;
        }
        if(data instanceof it.Link){
            return null;
        }else{
            return data.getParentId();
        }
    },

    /**
     * tree
     * @param data
     * @param children
     * @returns {*}
     */
    createNode : function(data,children){
        if(data){
//            var obj = {id:data.getId(),text:data.getId(),parentId:data.getParentId(),o_data:data};
            var obj = {id:data.getId(),text:this.createLabel(data),parentId:this.getParentIdByData(data)};
            if(children){
                obj.children = children;
            }else{
                obj.children = [];
            }
            if(this.isOpen(data)){
                var state = obj.state;
                if(state){
                    state['opened'] = true;
                }else{
                    obj.state = {"opened":true};
                }
            }
            return obj;
        }
        return null;
    },

    /**
     * node
     * @param data
     * @param child
     */
    addChild : function(node,child){
        if(!node || !child){
            return node;
        }
        var children = this.getChildren(node);
        if(children){
            children.push(child);
        }else {
            node.children = [child];
        }
        return node;
    },

    /**
     * 
     * @param node
     */
    getChildren : function(node){
        return node.children;
    },

    /**
     * 
     *
     * 
     * 1datasdataparentid
     * 2parentiddatanew
     * 3parentiddata
     * 4parentroot
     * 5parentparents parent
     *
     * parent
     *
     */
    organizeTree : function(datas){
        if(!datas || datas.length < 1) return null;
        var results = {}; //obj = {id:id,data:data,children:children}
        for(var i = 0 ; i < datas.length ; i++){
            var data = datas[i];
            if(!data) continue;
            var obj = this.createNode(data);
            results[data.getId()] = obj;
        }
        var treeData = [];
        var treeMap = it.Util.clone(results);
        for(var id in results){
//            var obj = results[id];
            var obj = treeMap[id]; // treeMapresults,parenttreeDatatreeMap
            this.organizeParent(obj,treeData,treeMap);
        }
        return treeData;
    },

    /**
     * obj
     * @param obj
     * @param treeData
     * @param treeMap
     * @returns {root} root
     */
    organizeParent : function(obj,treeData,treeMap){
        if(!obj) return null;
        var pid = obj.parentId;
        if(!pid){
            treeData.push(obj);
            return obj;
        }
        var parent = treeMap[pid]; // parent
        if(parent){
            this.addChild(parent,obj);
        }else if(this.includeParent(obj.data)){
            var parentData = this.getDataById(pid);
            if(!parentData){
                treeData.push(obj);
            }else{
                var pObj = this.createNode(parentData,[obj]);
                treeMap[parentData.getId()] = pObj;
                this.organizeParent(pObj,treeData,treeMap,this);
            }
        }else{ // data
            var ancestorObj = this.getAncestorInTreeMap(pid,treeMap);
            if(ancestorObj){
                this.addChild(ancestorObj,obj);
            }else{
                treeData.push(obj);
            }
        }
    },

    /**
     * 
     * @param parentid
     * @param treeMap
     * @returns {*}
     */
    getAncestorInTreeMap : function(parentid,treeMap){
        if(!parentid || !treeMap) return null;
        if(treeMap[parentid]){
            return treeMap[parentid];
        }else{
            var parentData = this.getDataById(parentid);
            if(!parentData || !this.getParentIdByData(parentData)){
                return null;
            }else{
                return this.getAncestorInTreeMap(this.getParentIdByData(parentData),treeMap,this);
            }
        }
    }

});
/**
 * Created by macpro2 on 7/7/15.
 */
/*  */

var $Diagram = function (options) {
    options = options || {};
    this.diagramPane = $('<div class="diagram"></div>');
    if(options.width){
        this.diagramPane.css('width', options.width)
    }
    this.diagramContentPane = $('<div class="diagram-content"></div>'); //itemdiv
    var main = $('#itv-main');
    main.append(this.diagramPane);
    this.serialNumColorMap = {};
    this.num = 1; //(U1)
    this.hideDiagram();
};

mono.extend($Diagram, Object, {

    /**
     * @param data[{color:#00000,value:0-5},...]
     */
    setData: function (datas, titleText, mouseOverCb, mouseoutCb) {
        if (!datas || datas.length < 1) {
            return;
        }
        this.diagramPane.empty();
        this.diagramContentPane.empty();
        this.diagramPane.show();
        if (!titleText) {
            titleText = '';
        }
        var title = $('<div class="title">' + titleText + '</div>');
        this.diagramPane.append(title);
        this.diagramPane.append(this.diagramContentPane);
        // var width = 100 / datas.length + '%';
        if (datas instanceof Array) {
            for (var i = 0; i < datas.length; i++) {
                var data = datas[i];
                this.createItem(data);//, width
            }
        }
        if(mouseOverCb){
            this.diagramPane.mouseover(function(event) {
                var $target = $(event.target).parent();
                if($target.hasClass('diagram-item')){
                    var index = $target.index();
                    mouseOverCb(index, $target);
                }
            });
        }
        if(mouseoutCb){
            this.diagramPane.mouseout(function(event) {
                var $target = $(event.target).parent();
                if($target.hasClass('diagram-item')){
                    var index = $target.index();
                    mouseoutCb(index, $target);
                }
            });
        }
        
    },

    createItem: function (data) {
        if (!data) return;
        var value = data.value;
        var color = data.color;
        var width = data.width;
        if (!value || !color) {
            return;
        }
        var row = $('<div class="diagram-item"></div>');
        // row.css('width', width); //, update by Kevin 2016-11-23
        if (width) {
            row.css('width', width);
        }
        var div_color = $('<div class="cl"></div>');
        div_color.css('background-color', color);
        row.append(div_color);
        var label_Name = $('<label class="lb">' + value + '</label>');
        row.append(label_Name);
        this.diagramContentPane.append(row);
    },

    /**
     *
     * @param num 47U
     * 
     */
    showSerialDiagram: function (num) {
        var datas = [];
        this.serialNumColorMap = {};
        num = parseInt(num);
        if (!num) {
            num = 1;
        }
        this.num = num;
        var total_count = Math.floor(47 / num);
        var unit_count = Math.floor(total_count / 4); //ceil

        var color = this.getCapacityColor(null, 0.1);
        var data = {color: color, value: (unit_count * 3 + 1) + '-' + total_count};
        if (total_count <= 4) {
            data.value = total_count;
            this.serialNumColorMap[total_count] = color;
        } else {
            for (var i = (unit_count * 3 + 1); i <= total_count; i++) {
                this.serialNumColorMap[i] = color;
            }
        }

        datas.push(data);


        color = this.getCapacityColor(null, 0.3);
        data = {color: color, value: (unit_count * 2 + 1) + '-' + (unit_count * 3)};
        if (total_count > 1 && total_count <= 4) {
            data.value = total_count - 1;
            this.serialNumColorMap[total_count - 1] = color;
        } else {
            for (var i = (unit_count * 2 + 1); i <= (unit_count * 3); i++) {
                this.serialNumColorMap[i] = color;
            }
        }
        if (total_count > 1) {
            datas.push(data);
        }


        color = this.getCapacityColor(null, 0.6);
        data = {color: color, value: (unit_count + 1) + '-' + (unit_count * 2)};
        if (total_count > 2 && total_count <= 4) {
            data.value = total_count - 2;
            this.serialNumColorMap[total_count - 2] = color;
        } else {
            for (var i = (unit_count + 1); i <= (unit_count * 2); i++) {
                this.serialNumColorMap[i] = color;
            }
        }
        if (total_count > 2) {
            datas.push(data);
        }

        color = this.getCapacityColor(null, 0.8);
        data = {color: color, value: '1-' + unit_count};
        if (total_count > 3 && total_count <= 4) {
            data.value = total_count - 3;
            this.serialNumColorMap[total_count - 3] = color;
        } else {
            for (var i = 1; i <= unit_count; i++) {
                this.serialNumColorMap[i] = color;
            }
        }
        if (total_count > 3) {
            datas.push(data);
        }

        this.setData(datas, '');
    },


//value 
    showTotalSpaceDiagram: function () {
        var datas = [];
        this.num = 1;
        var color = this.getCapacityColor(null, 0.1);
        var data = {color: color, value: '1-25%'};
        datas.push(data);
        color = this.getCapacityColor(null, 0.3);
        data = {color: color, value: '25-50%'};
        datas.push(data);
        color = this.getCapacityColor(null, 0.6);
        data = {color: color, value: '50-75%'};
        datas.push(data);
        color = this.getCapacityColor(null, 0.8);
        data = {color: color, value: '75-100%'};
        datas.push(data);
        this.setData(datas, '');
    },

    hideDiagram: function () {
        this.diagramPane.empty();
        this.diagramPane.hide();
    },

    getCapacityColor: function (rack, ratio) {
        // ratio 
        if (!ratio) {
            return '#5DBDE0';//'#BEEB9F';
        } else if (ratio <= 0.25) {
            return '#5DBDE0';//'#BEEB9F'; 
        } else if (ratio <= 0.5) {
            return '#6FD772';  // FFFF99 
        } else if (ratio <= 0.75) {
            return '#FFC95A';//'#FFBB11'; 
        } else {
            return '#Fd674F';// FF3357 '#FF6138'; //
        }
    }

});

it.Diagram = $Diagram;







/**
 * IT
 * 
 * SpaceSearchManagerITSearchManager
 * @param sceneManager
 * @param itSearchInputPanel
 * @param spaceSearchInputPanel
 * @constructor
 */

it.SearchManager = function(sceneManager,itSearchInputPanel,spaceSearchInputPanel,spaceMode){
    this.sceneManager = sceneManager;
    this.itSearchManager = null;//new it.ITSearchManager(this.sceneManager);
    this.spaceSearchManager = null;//new it.SpaceSearchManager(this.sceneManager);
    this.itSearchInputPanel = itSearchInputPanel;
    this.spaceSearchInputPanel = spaceSearchInputPanel;
    this.showModel = '';
    this.spaceMode = spaceMode || 1;
    this.init();
};

mono.extend(it.SearchManager,Object,{

    init : function(){
        this.spaceSearchManager = new it.SpaceSearchManager(this.sceneManager,this.spaceSearchInputPanel,this.spaceMode);
        this.itSearchManager = new it.ITSearchManager(this.sceneManager,this.itSearchInputPanel);
        this.itSearchManager.clearAll(); // 
        this.itSearchManager.clearAllVirtual();
        this.itSearchManager.hide();
        this.spaceSearchManager.clearAll(); // 
        this.spaceSearchManager.clearAllVirtual();
        this.spaceSearchManager.hide();
    },

    /**
     * IT
     */
    showITSearch : function(){
        this.switch(false);
    },

    /**
     * IT
     */
    hideITSearch : function(){
        if(this.itSearchManager){
            this.itSearchManager.clearAll(); // 
            this.itSearchManager.clearAllVirtual();
            this.itSearchManager.hide();
        }
    },

    /**
     * 
     */
    showSpaceSearch : function(){
        this.switch(true);
    },

    /**
     * 
     */
    hideSpaceSearch : function(){
        if(this.spaceSearchManager){
            this.spaceSearchManager.clearAll(); // 
            this.spaceSearchManager.clearAllVirtual();
            this.spaceSearchManager.hide();
        }
    },

    /**
     * 
     * @param isSpace
     */
    switch : function(isSpace){
        if (isSpace) {
            if (this.showModel === 'S') {
                return;
            }
            this.showModel = 'S';
            this.itSearchManager.clearAll(); // 
            this.itSearchManager.clearAllVirtual();
            this.itSearchManager.hide();
            this.spaceSearchManager.virtualAllNodes();
            this.spaceSearchManager.setupInit();
            this.spaceSearchManager.show();
        } else {
            if (this.showModel === 'IT') {
                return ;
            }
            this.showModel = 'IT';
            this.spaceSearchManager.clearAll(); // 
            this.spaceSearchManager.clearAllVirtual();
            this.spaceSearchManager.clearInit();
            this.spaceSearchManager.hide();
            this.itSearchManager.show();
        }
    },

    getITSearchTree : function(){
        if(this.itSearchManager){
            return this.itSearchManager.getTreeView();
        }
        return null;
    },

    getSpaceSearchTree : function(){
        if(this.spaceSearchManager){
           return this.spaceSearchManager.getTreeView();
        }
        return null;
    },

    getITSearchOrganizeTreeManager : function(){
        if(this.itSearchManager){
            return this.itSearchManager.getOrganizeTreeManager();
        }
        return null;
    },

    getSpaceSearchOrganizeTreeManager : function(){
        if(this.spaceSearchManager){
            return this.spaceSearchManager.getOrganizeTreeManager();
        }
        return null;
    },

    setPanelLocation:function(obj){
        this.setITSearchPanelLocation(obj);
        this.setSpaceSearchPanelLocation(obj);
    },

    setITSearchPanelLocation : function(obj){
        var searPanel = this.itSearchManager.searPanel;
        if(obj){
            searPanel.css('left','auto');
            searPanel.css('right','auto');
            searPanel.css('bottom','auto');
            searPanel.css('top','auto');
            if(obj.left != null && obj.left != undefined){
                searPanel.css('left',parseInt(obj.left)+'px');
            }
            if(obj.right != null && obj.right != undefined){
                searPanel.css('right',parseInt(obj.right)+'px');
            }
            if(obj.bottom != null && obj.bottom != undefined){
                searPanel.css('bottom',parseInt(obj.bottom)+'px');
            }
            if(obj.top != null && obj.top != undefined){
                searPanel.css('top',parseInt(obj.top)+'px');
            }
        }
    },

    setSpaceSearchPanelLocation : function(obj){
        var searPanel = this.spaceSearchManager.searPanel;
        if(obj){
            searPanel.css('left','auto');
            searPanel.css('right','auto');
            searPanel.css('bottom','auto');
            searPanel.css('top','auto');
            if(obj.left != null && obj.left != undefined){
                searPanel.css('left',parseInt(obj.left)+'px');
            }
            if(obj.right != null && obj.right != undefined){
                searPanel.css('right',parseInt(obj.right)+'px');
            }
            if(obj.bottom != null && obj.bottom != undefined){
                searPanel.css('bottom',parseInt(obj.bottom)+'px');
            }
            if(obj.top != null && obj.top != undefined){
                searPanel.css('top',parseInt(obj.top)+'px');
            }
        }
    },

    getItSearchPane : function(){
        return this.itSearchManager.searPanel;
    },

    getSpaceSearchPane : function(){
        return this.spaceSearchManager.searPanel;
    },

    setParent : function(parent){
        if(parent && $(parent)){
            parent = $(parent);
            parent.append(this.itSearchManager.searPanel);
            parent.append(this.spaceSearchManager.searPanel);
        }else{
            $('body').append(this.itSearchManager.searPanel);
            $('body').append(this.spaceSearchManager.searPanel);
        }
    }

});

// /**
//  *
//  * @param sceneManager
//  * @param inputPane
//  * @constructor
//  */
// it.BaseSearch = function(sceneManager,inputPane){
//     if(!sceneManager) {
//         console.error("agument sceneManager can not be null");
//         return;
//     }
//     this.sceneManager = sceneManager;
//     this.dataManager = this.sceneManager.dataManager;
//     this.dataFinder = new it.DataFinder(this.sceneManager.dataManager);
//     var self = this;
//     this.dataFinder.filter = function(data){
//         return self.filter(data);
//     };
// //    this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
//     this.virtualManager = this.getVirtualManager() || new it.VirtualManager(sceneManager);
//     this.virtualManager.isDealWithFunction = function(data){ // 
//         if(!data) return false;
//         var category = self.dataManager.getCategoryForData(data);
//         if(category
//             && category.getId().indexOf('room') >=0 ){
//             return false;
//         }
//         return true;
//     }
//     this.sceneManager.viewManager3d.addMaterialFilter(this.virtualManager);
//     this.treeView = null;
//     this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
//     this.defaultEventHandler = sceneManager.viewManager3d.getDefaultEventHandler();
//     this.inputPane = inputPane||this.createInputPane();
//     this.searPanel = null;
//     this.clearAllFunction = null;
//     this.initSearchPane();
// };

// mono.extend(it.BaseSearch,Object,{

//     createInputPane : function(){
//         return new it.BasePanel();
//     },

//     getVirtualManager : function(){
//         return new it.VirtualManager(this.sceneManager);
//     },

//     removeVirtualManager : function(){
//         this.sceneManager.viewManager3d.removeMaterialFilter(this.virtualManager);
//     },

//     filter:function(data){
//        return true;
//     },

//     clearAllVirtual : function(){
//         this.virtualManager.clearAll();
//     },

//     initSearchPane : function(){
//         this.searPanel = $('.search-main-pane');
//         var paneIndex = 0;
//         if(this.searPanel && this.searPanel.length > 0){
//             paneIndex = this.searPanel.length;
//         }
//         this.searPanel = $('<div id = "search-main-pane_'+paneIndex+'" class="search-main-pane"></div>');
// //        this.searPanel.css('left',10);
// //        this.searPanel.css('top',10);
//         this.searPanel.append(this.inputPane.getContentPane());
//         this.treeView = new it.TreeView(this.searPanel);
// //        $('body').append(this.searPanel);
//         var self = this;
//         this.treeView.clickNodeFunction = function(treeData){
//             self.clickTreeNode(treeData);
//         };

//         this.treeView.mouseoverNodeFunction = function(treeData){
//             self.mouseOverTreeNode(treeData);
//         };

//         this.inputPane.doClickFunction = function(values){
// //            var values = [{key:'u:userId',value:'aaa',operation:'like'}];
//             self.beforeDoClick();
//             self.setData(values);
//             var height = self.searPanel.height() - self.inputPane.getContentPane().height();
//             self.treeView.setTreeHeight(height);
//         };

//         this.inputPane.doClearFunction = function(){
//             self.clearSearch();
//         };
//     },

//     beforeDoClick : function(){

//     },

//     show : function(){
//         this.searPanel.show();
//     },

//     beforHide : function(){

//     },

//     hide : function(){
//         this.beforHide();
//         this.searPanel.hide();
//     },

//     /**
//      * tree
//      * @param conditions
//      */
//     setData : function(conditions){
//         var results = this.dataFinder.find(conditions);
//         var treeNodes = null;
//         if (!results || results.length < 1) {
//             this.treeView.clearTreeData();
// //            return;
//         }else{
//             treeNodes = this.orgTreeManager.organizeTree(results);
//             this.treeView.setData(treeNodes, false);
//         }
//         this.setResult(results,treeNodes);
//     },

//     /**
//      * 
//      * @param results
//      * @param treeNodes
//      */
//     setResult : function(results,treeNodes){

//     },

//     clearSearch : function(){
//         this.treeView.setData(null);
//         this.clearSearchData();
//         this.sceneManager.network3d.dirtyNetwork();
//     },

//     /**
//      * 
//     */
//     clearSearchData : function(){

//     },

//     /**
//      * ,
//      */
//     clearAll : function(){
//         this.treeView.setData(null);
//         if(this.inputPane.clearInput){
//             this.inputPane.clearInput();
//         }
//         if(this.clearAllFunction){
//             this.clearAllFunction();
//         }else{
//             this.clearSearchData();
//         }
//     },

//     getRootDataBySceneAndData : function(scene,data,scope){
//         if(!scene || !data){
//             return null;
//         }
//         scope = scope || this;
//         var dataType = this.sceneManager.dataManager.getDataTypeForData(data);
//         if(dataType && dataType.getCategoryId() === scene.getCategoryId()){
//             return data;
//         }else if(data.getParentId()){
//             var parent = this.sceneManager.dataManager.getDataById(data.getParentId());
//             if(parent){
//                 return scope.getRootDataBySceneAndData(scene,parent,scope);
//             }
//         }
//         return null;
//     },

//     /**
//      * camera
//      * dcnode;
//      * 2nodeScenecurrentScenerootNode12;
//      *
//      * @param treeData
//      */
//     clickTreeNode : function(treeData){
//         var id = treeData.id;
//         if(!id) return;
//         var data = this.sceneManager.dataManager.getDataById(id);
//         if(!data || !this.treeView.isClick(data)) return;
//         var assetNode = this.sceneManager.dataNodeMap[id];
// //        var nodeData = this.sceneManager.getNodeData(assetNode);

//         if(!this.sceneManager.isCurrentSceneInstance(data)){ //
//             var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
//             if(sceneAndRootData){
//                 this.sceneManager.gotoScene(sceneAndRootData.scene,sceneAndRootData.rootData);
//                 //lookAt(Dataroot)
//                 if(sceneAndRootData.rootData != data){
//                     assetNode = this.sceneManager.dataNodeMap[id];
//                     if(!assetNode){
//                         this.sceneManager.loadLazyData(data);
//                     }
//                 }else{
//                     assetNode = null;
//                 }
//             }
//         }
//         //
//         //1lazyablefocus()box
//         //2boxlazyable
//         var box3d = this.sceneManager.network3d.getDataBox();
//         if(!assetNode || !box3d.getDataById(assetNode.getId())){
//             this.sceneManager.loadLazyData(data);
//             if(!assetNode){
//                 assetNode = this.sceneManager.dataNodeMap[data.getId()];
//             }
//         }
//         if(this.defaultEventHandler){
//             this.defaultEventHandler.lookAt(assetNode);
//         }
//     },

//     mouseOverTreeNode : function(treeData){
//         var id = treeData.id;
//         if (id) {
//             var assetNode = this.sceneManager.dataNodeMap[id];
//             if (assetNode) {
//                 this.sceneManager.network3d.getDataBox().getSelectionModel().clearSelection();
//                 assetNode.setSelected(true);
//             }
//         }
//     },

//     getTreeView : function(){
//         return this.treeView;
//     },

//     getOrganizeTreeManager : function(){
//         return this.orgTreeManager;
//     },

// });

// /**
//  * 
//  * @param sceneManager
//  * @constructor
//  */
// it.ITSearchManager = function(sceneManager,inputPane){
//     it.ITSearchManager.superClass.constructor.call(this, sceneManager,inputPane);
//     this._assetImage = "data:image/png;base64,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";
// }

// mono.extend(it.ITSearchManager,it.BaseSearch,{

//     createInputPane : function(){
//         return new it.ITSearchPanel();
//     },

//     clearSearchData : function(){
//         this.clearBillboard();
//     },

//     setResult : function(results,treeNodes){
//         this.clearBillboard();
//         this.virtualManager.addAll();
//         if(!treeNodes) return;
//         for(var i = 0 ; i < treeNodes.length; i++){
//             var treeNode = treeNodes[i];
//             this.showData(treeNode);
//         }
//     },

//     showData : function(treeNode){
//         var data = this.orgTreeManager.getDataByNode(treeNode);
//         if(!data) return;
//         if(this.showBillboard(data)){
//             this.addDataBillBoard(data);
//         }
//         this.virtualManager.remove(data); // removeByDescendant
//         var children = this.orgTreeManager.getChildren(treeNode);
//         if(children && children.length > 0){
//             for(var i = 0 ;i < children.length ; i++){
//                 var child = children[i];
//                 if(child){
//                     this.showData(child,this);
//                 }
//             }
//         }
//     },

//     /***
//      * Databillboard
//      * @param data
//      * @returns {boolean}
//      */
//     showBillboard : function(data){
//         if(!data) return false;
//         var assetType = data.getDataTypeId();
//         if(assetType){
//             if(assetType.indexOf('equipment') >=0){
//                 return false;
//             }
//             if(assetType.indexOf('room') >=0){
//                 return false;
//             }
//             if(assetType.indexOf('floor') >=0){
//                 return false;
//             }
//         }
//         return true;
//     },

//     clearBillboard : function(){
//         if(this.sceneManager.dataNodeMap){
//             for(var id in this.sceneManager.dataNodeMap){
//                 var node = this.sceneManager.dataNodeMap[id];
//                 if(node && node.getClient('asset_billboard')){
//                     var billboard = node.getClient('asset_billboard');
//                     billboard.setParent(null);
//                     this.sceneManager.network3d.getDataBox().remove(billboard);
//                 }
//             }
//         }
//         this.virtualManager.clearAll();
//     },

//     /**
//      * Billboard
//      * @param data
//      */
//     addDataBillBoard : function(data){
//         if(!data) return;
//         var node = this.sceneManager.dataNodeMap[data.getId()];
//         if(!node) return;
//         var box = this.sceneManager.network3d.getDataBox();
//         if(!box.getDataById(node.getId())){
//             return ;
//         }
//         var billboard = new mono.Billboard();
//         billboard.setPosition(0, node.getBoundingBox().max.y + 20, 0);
//         billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
//         billboard.setStyle('m.transparent', true);
// //        billboard.setStyle('m.texture.image', TML.Factory3D.getImagePath('asset.png'));
//         billboard.setStyle('m.texture.image', this._assetImage);
//         billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
//         // billboard.setStyle('m.vertical', true);
//         billboard.setScale(40, 50, 1);
//         billboard.setParent(node);
//         billboard.setClient('it_data',data);
//         box.add(billboard);
//         node.setClient('asset_billboard', billboard);
//     }

// });

// it.SpaceSearchVirtualManager = function(sceneManager,spaceManager){
//     it.VirtualManager.call(this,sceneManager);
//     this.spaceManager = spaceManager;
// }

// mono.extend(it.SpaceSearchVirtualManager,it.VirtualManager,{

//     beforeAdd: function(data) {
//         if (data) {
//             // delete data._userDataMap['dyna_user_data_totalSpace']; //
//             // delete data._userDataMap['dyna_user_data_totalOccupation']; //
//             delete data._userDataMap['dyna_user_data_maxSerSpace']; //
//             // delete data._userDataMap['dyna_user_data_totalEmpSpace']; //
//             delete data._userDataMap['dyna_user_data_totalCount']; //uNumberU
//             delete data._userDataMap['dyna_user_data_empCount']; //uNumberU
//         }
//     },

//     filterMaterial : function(originalMaterial,filterdMaterial,node){

//         var sm = this.sceneManager;
// //        var vm = sm.viewManager3d;
//         var sm2 = this.spaceManager;
// //        var focusNode = vm.getFocusNode();
//         var map = this.materialMap;

//         if(sm.getNodeData(node)){
//             return filterdMaterial;
//         }
//         if(sm2.isSpaceNode(node)){
//             var parent = node.getParent();
//             if(sm2.isSpaceNode(parent)){
//                 parent = parent.getParent();
//             }
//             var transFlag = false;
//             if(parent){
//                 var data = this.getDataByNode(parent);
//                 if(data){
//                     id = this.getBId(data);
//                     if(this._global_tmap[id]){ // global
//                         transFlag = this._global_tmap[id];
//                     }else if(this._tmap[id]){
//                         transFlag = this._tmap[id];
//                     }
//                 }
//             }
//             if(!transFlag){
//                 return filterdMaterial;
//             }

// //                if(node.isDescendantOf(focusNode)){
// //                    return filterdMaterial;
// //                }else{
//                     var id = originalMaterial.getUniqueCode();
//                     var m = this.materialMap[id];
//                     if(!m){
//                         m = originalMaterial.clone();
//                         this.materialMap[id] = m;
//                         m.transparent = true;
//                         m.opacity = 0.05;
//                     }
//                     return m;
// //                }
//         }
//     }

// });

// /**
//  *  
//  *  
//  * @param sceneManager
//  * @constructor
//  */
// it.SpaceSearchManager = function(sceneManager,inputPane,mode){
//     it.BaseSearch.call(this,sceneManager,inputPane);
//     this.spaceManager = new it.SpaceManager(this.dataManager,this.sceneManager);
//     this.diagram = new it.Diagram();
//     this.isVirtualFunction = null;
//     this.virtualNode = [];
//     this.spaceMap = {};
//     this.mode = mode || 1;
//     var self = this;
//     this.spaceManager.spaceNodeColorFunction = function(percent,data,space){
//         // ratio 
//         if (space) {
//             // var occupationCount = parseInt(space.getTotal()/self.getUNumber());
//             if (data && data.getUserData('dyna_user_data_empCount')) {
//                 var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
//                 // var totalCount = parseInt(space.getTotal()/self.getUNumber());
//                 // if (totalCount) {
//                 // percent = 1-occupationCount/totalCount;
//                 // }
//                 var num = self.getUNumber()||1;
//                 var total_count = Math.floor(47 / num);
//                 var unit_count = Math.floor(total_count / 4); //ceil
//                 if (total_count <= 4) {
//                     if (occupationCount === 1) {
//                         return '#5DBDE0';
//                     } else if (occupationCount === 2) {
//                         return '#6FD772';
//                     } else if (occupationCount === 3) {
//                         return '#FFC95A';
//                     } else {
//                         return '#Fd674F';
//                     }
//                 } else {
//                     if (occupationCount <= unit_count) {
//                         return '#Fd674F';
//                     } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
//                         return '#FFC95A';
//                     } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
//                         return '#6FD772';
//                     } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
//                         return '#5DBDE0';
//                     }else{
//                         console.log('can not compute the spaceNodeColorFunction color !');
//                     }
//                 }
//             }
//         }
//         if(!percent){ //
//             return '#5DBDE0';//'#BEEB9F';
//         }else if(percent <= 0.25){
//             return '#5DBDE0';//'#BEEB9F'; 
//         }else if(percent <= 0.5){
//             return '#6FD772';  // FFFF99 
//         }else if(percent <= 0.75){
//             return '#FFC95A';//'#FFBB11'; 
//         }else{
//             return '#Fd674F';// FF3357 '#FF6138'; //
//         }
//     };
//     this.spaceManager.spaceNodeFrameColorFunction = function(percent,data,space){
//         if (space) {
//             // var occupationCount = parseInt(space.getTotal()/self.getUNumber());
//             if (data && data.getUserData('dyna_user_data_empCount')) {
//                 var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
//                 var num = self.getUNumber()||1;
//                 var total_count = Math.floor(47 / num);
//                 var unit_count = Math.floor(total_count / 4); //ceil
//                 if (total_count <= 4) {
//                     if (occupationCount === 1) {
//                         return '#018ABD';
//                     } else if (occupationCount === 2) {
//                         return '#1A920A';
//                     } else if (occupationCount === 3) {
//                         return '#E68D00';
//                     } else {
//                         return '#CE3118';
//                     }
//                 } else {
//                     if (occupationCount <= unit_count) {
//                         return '#CE3118';
//                     } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
//                         return '#E68D00';
//                     } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
//                         return '#1A920A';
//                     } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
//                         return '#018ABD';
//                     }else{
//                         console.log('can not compute the spaceNodeFrameColorFunction color !');
//                     }
//                 }
//             }
//         }
//         if(!percent){ //
//             return '#018ABD';//'#BEEB9F';
//         }else if(percent <= 0.25){
//             return '#018ABD';//'#BEEB9F'; 
//         }else if(percent <= 0.5){
//             return '#1A920A';  // FFFF99 
//         }else if(percent <= 0.75){
//             return '#E68D00';//'#FFBB11'; 
//         }else{
//             return '#CE3118';// FF3357 '#FF6138'; //
//         }
//     };
//     this.resetTreeLabel();
//     this.virtualAllNodes();
//     this.clearAllFunction = function(){
//         this.clearSpaceNode();
//     }
//     this.sceneChangeListener = function(eve){
//         if (eve.data && eve.data.getCategoryId() && eve.data.getCategoryId().toLowerCase() == 'floor') {
//             self.showSpaceNode();
//         }
//     }
//     //,Remove
// }

// mono.extend(it.SpaceSearchManager,it.BaseSearch,{

//     /**
//      * 
//      */
//     setupInit : function(){
//         this.sceneManager.addSceneChangeListener(this.sceneChangeListener);
//         if(!this.visOrVirtFilter){ // 
//             this.visOrVirtFilter = this.setVisibleOrVirtualData(this.sceneManager);
//             if(this.visOrVirtFilter){
//                 if(this.visOrVirtFilter instanceof it.VisibleManager){
//                     this.sceneManager.viewManager3d.addVisibleFilter(this.visOrVirtFilter);
//                 }else if(this.visOrVirtFilter instanceof it.VirtualManager){
//                     this.sceneManager.viewManager3d.addMaterialFilter(this.visOrVirtFilter);
//                 }
//             }
//         }
//         this.setupDoOther(this.sceneManager);
//     },

//     /**
//      * IT
//      * floor clear
//      *         buildingsceneChangeListener
//      * */
//     clearInit : function(){
//         this.sceneManager.removeSceneChangeListener(this.sceneChangeListener);
//         if(this.visOrVirtFilter){
//             if(this.visOrVirtFilter instanceof it.VisibleManager){
//                 this.sceneManager.viewManager3d.removeVisibleFilter(this.visOrVirtFilter);
//             }else if(this.visOrVirtFilter instanceof it.VirtualManager){
//                 this.sceneManager.viewManager3d.removeMaterialFilter(this.visOrVirtFilter);
//             }
//         }
//         this.clearDoOther(this.sceneManager);
//     },

//     /**
//      * 
//      * @param dataTypeId
//      * @param data
//      * @returns {boolean}
//      */
//     invisibleOrVirtualData : function(dataTypeId,data){
//         if(!dataTypeId && !data){
//             return false;
//         }
//         var category = this.sceneManager.dataManager.getCategoryForDataType(dataTypeId);
//         if(category && category.getId() && category.getId().toLowerCase().indexOf('channel') >=0 ){
//             return true;
//         }
//         return false;
//     },

//     /**
//      * ()data
//      * @param visibleFiltervirtualManager
//      */
//     setVisibleOrVirtualData: function(sceneManager){
//         var visibleFilter = new it.VisibleManager(sceneManager);
//         var groupByType = this.dataManager._dataTypeDatas;
//         if(groupByType){
//             for(var typeId in groupByType){
//                 if(this.invisibleOrVirtualData(typeId)){
//                     var datas = groupByType[typeId];
//                     if(datas){
//                         for(var id in datas){
//                             visibleFilter.setVisible(datas[id],false);
//                         }
//                     }
//                 }
//             }
//         }
//         return visibleFilter;
//     },

//     /**
//      * 
//      * @param sceneManager
//      */
//     setupDoOther : function(sceneManager){

//     },

//     /**
//      * 
//      * @param sceneManager
//      */
//     clearDoOther : function(sceneManager){

//     },

//     createInputPane : function(){
//         this.inputPane = new it.SpaceSearchPanel();
//         return this.inputPane;
//     },

//     getVirtualManager : function(){
//         return new it.SpaceSearchVirtualManager(this.sceneManager, new it.SpaceManager(this.dataManager,this.sceneManager));
//     },

//     resetTreeLabel : function(){
//         var self = this;
//         this.orgTreeManager.createLabel = function(treeData){
//             return self.setLabel(treeData);
//         }
//     },

//     getUNumber : function(){
//         if(this.inputPane){
//           return parseInt(this.inputPane.getUNumber());
//         }else{
//            return 1;
//         }
//     },

//     setLabel : function(treeData){
//         if(!treeData || !treeData.getId()){
//             return null;
//         }
//         var id = treeData.getId();
//         var data = this.dataManager.getDataById(id);//data
//         // var space = this.spaceMap[id];
//         var prex = this.getTreeNodeLabel(treeData);
//         if (!prex) {
//             prex = id;
//         }
//         var count = 0;
//         // var uNumber = this.getUNumber();
//         // if(space && uNumber){
//             // var count = 0;
//             // var empList = space.getEmptyList();
//             // if(empList && empList.length > 0){
//             //     for(var i = 0 ; i < empList.length ; i++){
//             //         var ep = empList[i];
//             //         if(ep.total >= uNumber){
//             //             count += Math.floor(ep.total/uNumber);
//             //         }
//             //     }
//             // }
//             if (data) {
//                 // data.setUserData('dyna_user_data_totalCount',parseInt(space.getTotal()/uNumber));//uNumberU
//                 count = parseInt(data.getUserData('dyna_user_data_empCount'));//uNumberU
//             }
//             // return prex + '('+count+')';
//         // }else{
//             // return prex;
//         // }
//         if (count) {
//             prex +=  '('+count+')';
//         }
//         return prex;
//     },

//     /**
//      * 
//      */
//     getTreeNodeLabel : function(treeData){
//         if (treeData) {
//             return treeData.getId();
//         }
//         return "";
//     },

//     /**
//      * datatree
//      */
//     setData : function(conditions){
//         var results = this.dataFinder.find(conditions);
//         var treeNodes = null;
//         this.setResult(results);
//         if (!results || results.length < 1) {
//             this.treeView.clearTreeData();
//         }else{
//             treeNodes = this.orgTreeManager.organizeTree(results);
//             this.treeView.setData(treeNodes, false);
//         }
//     },

//     setResult : function(result,treeNodes){
//         this.clearSpaceNode(); // 
//         this.virtualManager.addAll();
//         if(!result) return;
//         var nodes = [];
//         for(var i = 0 ; i < result.length; i++){
//             var data = result[i];
//             var node = this.sceneManager.dataNodeMap[data.getId()];
//             //nodecolor Cube
// //            var spaceNode = this.getSpaceNode(node);
//             this.virtualManager.remove(data);
//             if(node){
//                 this._dealWithOneNode(node);
//                 nodes.push(node);
//             }
//         }
//         this.showSpaceNode(); //sceneData,20161025scenenodesbox
//     },

//     beforHide : function(){
//         this.diagram.hideDiagram();
//     },

//     /**
//      * 
//       */
//     clearSearchData : function(){
//         this.initAllNodes();
//         this.showSpaceNode();
//         this.virtualManager.clearAll();
//     },

//     clearSpaceNode : function(){
//         var nodes = this.getAllNodes();//this.virtualNode;
//         this.spaceManager.remove1DSpaceNodeForNodes(nodes);
//         this.spaceManager.hideSpaceMode();
//         this.showSerialDiagram(1,nodes);
//     },

//     virtualAllNodes : function(){
//         this.initAllNodes();
//         this.showSpaceNode();
//     },

//     showSpaceNode : function(nodes){
//         nodes = nodes || this.getSceneNodes();
//         if(nodes && nodes.length > 0){
//             this.showSerialDiagram(this.getUNumber(),nodes);
//         }else{ //node
//             this.diagram.hideDiagram();
//         }
// //        this.spaceManager.remove1DSpaceNodeForNodes(nodes);//create
//         this.spaceManager.create1DSpaceNodeForNodes(nodes,this.mode); // 
//         this.spaceManager.showSpaceMode();
//     },

//     /**
//      * 
//      * @param num 47U
//      * 
//      */
//     showSerialDiagram : function (num,nodes) {
//         var datas = [];
//         var serialNumColorMap = {};
//         num = parseInt(num);
//         if (!num) {
//             num = 1;
//         }
//         this.num = num;
//         var total_count = Math.floor(47 / num);
//         var unit_count = Math.floor(total_count / 4); //ceil

//         var color = this.getCapacityColor(0.1);
//         var data = {color: color, 
//                     minCount:(unit_count * 3 + 1),
//                     maxCount:total_count,
//                     value: (unit_count * 3 + 1) + '-' + total_count
//                 };
//         if (total_count <= 4) {
//             data.value = total_count;
//             data.minCount = total_count;
//             data.maxCount = total_count;
//             serialNumColorMap[total_count] = color;
//         } else {
//             for (var i = (unit_count * 3 + 1); i <= total_count; i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         datas.push(data);


//         color = this.getCapacityColor(0.3);
//         data = {color: color, 
//                 minCount:(unit_count * 2 + 1),
//                 maxCount: unit_count * 3,
//                 value: (unit_count * 2 + 1) + '-' + (unit_count * 3)
//             };
//         if (total_count > 1 && total_count <= 4) {
//             data.value = total_count - 1;
//             data.minCount = total_count-1;
//             data.maxCount = total_count-1;
//             serialNumColorMap[total_count - 1] = color;
//         } else {
//             for (var i = (unit_count * 2 + 1); i <= (unit_count * 3); i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         if (total_count > 1) {
//             datas.push(data);
//         }

//         color = this.getCapacityColor(0.6);
//         data = {color: color, 
//                 minCount:(unit_count + 1),
//                 maxCount: unit_count * 2,
//                 value: (unit_count + 1) + '-' + (unit_count * 2)
//             };
//         if (total_count > 2 && total_count <= 4) {
//             data.value = total_count - 2;
//             data.minCount = total_count - 2;
//             data.maxCount = total_count - 2;
//             serialNumColorMap[total_count - 2] = color;
//         } else {
//             for (var i = (unit_count + 1); i <= (unit_count * 2); i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         if (total_count > 2) {
//             datas.push(data);
//         }

//         color = this.getCapacityColor(0.8);
//         data = {color: color, 
//                 minCount: 1,
//                 maxCount: unit_count,
//                 value: '1-' + unit_count };
//         if (total_count > 3 && total_count <= 4) {
//             data.value = total_count - 3 ;
//             data.minCount = total_count - 3;
//             data.maxCount = total_count - 3;
//             serialNumColorMap[total_count - 3] = color;
//         } else {
//             for (var i = 1; i <= unit_count; i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         if (total_count > 3) {
//             datas.push(data);
//         }
//         if (nodes && nodes.length > 0) {
//             var totalMap = {};
//             for(var i = 0 ; i < nodes.length ;i++){
//                 var data = this.sceneManager.getNodeData(nodes[i]);
//                 var dColor = serialNumColorMap[data.getUserData('dyna_user_data_empCount')];
//                 if (dColor) {
//                     if(totalMap[dColor]){
//                         totalMap[dColor]  ++;
//                     }else{
//                         totalMap[dColor]  = 1;
//                     }
//                 }
//             }
//             for (var i = 0; i < datas.length; i++) {
//                 var itemData = datas[i];
//                 if (!itemData) {
//                     continue;
//                 }
//                 if (totalMap[itemData.color]) {
//                     var strValue = '';
//                     if (itemData.minCount) {
//                         strValue = itemData.minCount;
//                     }
//                     if (itemData.minCount != itemData.maxCount) {
//                         strValue += '-' + itemData.maxCount;
//                     }
//                     strValue += '('+ totalMap[itemData.color] +')';
//                     itemData.value = strValue;
//                 }
//             }
//         }
//         this.diagram.setData(datas, '');
//     },

//     getCapacityColor: function (ratio) {
//         // ratio 
//         if (!ratio) {
//             return '#5DBDE0';//'#BEEB9F';
//         } else if (ratio <= 0.25) {
//             return '#5DBDE0';//'#BEEB9F'; 
//         } else if (ratio <= 0.5) {
//             return '#6FD772';  // FFFF99 
//         } else if (ratio <= 0.75) {
//             return '#FFC95A';//'#FFBB11'; 
//         } else {
//             return '#Fd674F';// FF3357 '#FF6138'; //
//         }
//     },

//     isDealwith : function(node){
//         if(!node) return false;
//         if(this.isVirtualFunction){
//             return this.isVirtualFunction(node);
//         }
//         var data = this.sceneManager.getNodeData(node);
//         if(!data) return false;
//         // var type = this.sceneManager.dataManager.getDataTypeForData(data);
//         // if(!type) return false;
//         // if(type._model.indexOf('.rack') >0){
//         //     return true;
//         // }
//         var category = this.sceneManager.dataManager.getCategoryForData(data);
//         if (category && category.getId().toLowerCase() == 'rack') {
//             return true;
//         }
//         return false;
//     },

//     getDataSpace : function(data){
//         if (!data) {
//             return null;
//         }
//         var space = this.spaceMap[data.getId()];
//         if (!space) {
//             var dataSpace = this.spaceManager.computeSpace(data);
//              if(dataSpace && (dataSpace instanceof it.Space1)){
//                 this.spaceMap[data.getId()] = dataSpace;
//                 space = dataSpace;
//              }
//         }
//         return space;
//     },

//     _dealWithOneNode : function(node){
//         var uNumber = this.getUNumber();
//         if (!uNumber) {
//             uNumber = 1;
//         }
//         if(node){
//             if(this.isDealwith(node)){
//                 var data = this.sceneManager.getNodeData(node);
//                 if(!data) return ;
//                 // var space = this.spaceMap[data.getId()]; 
//                 // if (!space) {
//                 //     space = this.spaceManager.computeSpace(data);
//                 //     if(space && (space instanceof it.Space1)){
//                 //        this.spaceMap[data.getId()] = space;
//                 //     }
//                 // }
//                 var space = this.getDataSpace(data);
//                 var count = 0;
//                 // if(space && (space instanceof it.Space1)){
//                 if (space) {
//                     // this.spaceMap[it.SceneManager.getNodeDataId(node)] = space;
//                     var maxEmpSerSpace = 0,totalEmpSpace = space.getTotal() - space.getOccupation();
//                     var empList = space.getEmptyList();
//                     if(empList && empList.length > 0){
//                         for(var i = 0 ; i < empList.length ; i++){
//                             var ep = empList[i];
//                             if(ep.total > maxEmpSerSpace){
//                                 maxEmpSerSpace = ep.total;
//                             }
//                             if(ep.total >= uNumber){
//                                count += Math.floor(ep.total/uNumber);
//                             }  
//                         }
//                     }
//                     data.setUserData('dyna_user_data_totalSpace',space.getTotal());//
//                     data.setUserData('dyna_user_data_totalOccupation',space.getOccupation());//
//                     data.setUserData('dyna_user_data_maxSerSpace',maxEmpSerSpace);//
//                     data.setUserData('dyna_user_data_totalEmpSpace',totalEmpSpace);//
//                     data.setUserData('dyna_user_data_totalCount',parseInt(space.getTotal()/uNumber));//uNumberU
//                     data.setUserData('dyna_user_data_empCount',count);//uNumberU
//                     this.virtualNode.push(node);
//                 }
//             }
//         }
//     },

//     /**
//      * Node
//      * @returns {*}
//      */
//     getAllNodes : function(){
//         var nodeMap = this.sceneManager.dataNodeMap;
//         if(!nodeMap) return null;
//         var allNodes = [];
//         for(var id in nodeMap){
//             var node = nodeMap[id];
//             if(node && this.isDealwith(node)) {
//                 var data = this.sceneManager.getNodeData(node);
//                 if (!data) return;
//                 // var space = this.spaceManager.computeSpace(data);
//                 // if (space && (space instanceof it.Space1)) {
//                 var space = this.getDataSpace(data);
//                 if (space) {
//                     allNodes.push(node);
//                 }
//             }
//         }
//         return allNodes;
//     },

//     /**
//      * node
//      */
//     getSceneNodes : function(){
//         var sceneNodes = [];
//         var sceneDatas = this.sceneManager.getSceneDatas();
//         if(sceneDatas){
//             var nodeMaps = this.sceneManager.dataNodeMap;
//             for(var id in sceneDatas){
//                 var node = nodeMaps[id];
//                 var data = sceneDatas[id];
//                 if(node && data && this.isDealwith(node)){
//                     // var space = this.spaceManager.computeSpace(data);
//                     var space = this.getDataSpace(data);
//                     // if (space && (space instanceof it.Space1)) {
//                     if (space) {
//                         this._dealWithOneNode(node);
//                         sceneNodes.push(node);
//                     }
//                 }
//             }
//         }
//         return sceneNodes;
//     },

//     initAllNodes : function(){
//         var nodeMap = this.sceneManager.dataNodeMap;
//         if(!nodeMap) return null;
//         this.virtualNode = [];
//         for(var id in nodeMap){
//             var node = nodeMap[id];
//             var data = this.sceneManager.getNodeData(node);
//             if (data) {
//                 data.setUserData('dyna_user_data_totalCount',null);//
//                 data.setUserData('dyna_user_data_empCount',null);
//             }
//             this._dealWithOneNode(node);
//         }
//         return this.virtualNode;
//     }

// });
/**
 *
 * @param sceneManager
 * @param inputPane
 * @constructor
 */
it.BaseSearch = function(sceneManager,inputPane){
    if(!sceneManager) {
        console.error("agument sceneManager can not be null");
        return;
    }
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.dataFinder = new it.DataFinder(this.sceneManager.dataManager);
    var self = this;
    this.dataFinder.filter = function(data){
        return self.filter(data);
    };
//    this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
    this.virtualManager = this.getVirtualManager() || new it.VirtualManager(sceneManager);
    this.virtualManager.isDealWithFunction = function(data){ // 
        if(!data) return false;
        var category = self.dataManager.getCategoryForData(data);
        if (category) {
            var catId = category.getId().toLowerCase();
            if (catId.indexOf('room') >= 0) {
                return false;
            } else if (catId.indexOf('datacenter') >= 0) {
                return false;
            } else if (catId.indexOf('building') >= 0) {
                return false;
            }else if (catId.indexOf('earth') >= 0) {
                return false;
            }
        }
        return true;
    }
    this.sceneManager.viewManager3d.addMaterialFilter(this.virtualManager);
    this.treeView = null;
    this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
    this.defaultEventHandler = sceneManager.viewManager3d.getDefaultEventHandler();
    this.inputPane = inputPane||this.createInputPane();
    this.searPanel = null;
    this.clearAllFunction = null;
    this.initSearchPane();
};

mono.extend(it.BaseSearch,Object,{

    createInputPane : function(){
        return new it.BasePanel();
    },

    getVirtualManager : function(){
        return new it.VirtualManager(this.sceneManager);
    },

    addVirtualManager : function(){
        this.sceneManager.viewManager3d.addMaterialFilter(this.virtualManager);
    },

    removeVirtualManager : function(){
        this.sceneManager.viewManager3d.removeMaterialFilter(this.virtualManager);
    },

    filter:function(data){
       return true;
    },

    clearAllVirtual : function(){
        this.virtualManager.clearAll();
    },
    
    /**
     * 
     */
    showNoData : function(){
        
    },

    initSearchPane : function(){
        this.searPanel = $('.search-main-pane');
        var paneIndex = 0;
        if(this.searPanel && this.searPanel.length > 0){
            paneIndex = this.searPanel.length;
        }
        this.searPanel = $('<div id = "search-main-pane_'+paneIndex+'" class="search-main-pane"></div>');
//        this.searPanel.css('left',10);
//        this.searPanel.css('top',10);
        this.searPanel.append(this.inputPane.getContentPane());
        this.treeView = new it.TreeView(this.searPanel);
//        $('body').append(this.searPanel);
        var self = this;
        this.treeView.clickNodeFunction = function(treeData){
            self.clickTreeNode(treeData);
        };

        this.treeView.mouseoverNodeFunction = function(treeData){
            self.mouseOverTreeNode(treeData);
        };

        this.inputPane.doClickFunction = function(values){
//            var values = [{key:'u:userId',value:'aaa',operation:'like'}];
            self.beforeDoClick();
            self.setData(values);
            var height = self.searPanel.height() - self.inputPane.getContentPane().height();
            self.treeView.setTreeHeight(height);
            self.sceneManager.viewManager3d.clearVisibleMap();
        };

        this.inputPane.doClearFunction = function(){
            self.clearSearch();
        };
    },

    beforeDoClick : function(){

    },

    show : function(){
        this.searPanel.show();
    },

    beforHide : function(){

    },

    hide : function(){
        this.beforHide();
        this.searPanel.hide();
    },

    /**
     * tree
     * @param conditions
     */
    setData : function(conditions){
        // var results = this.dataFinder.find(conditions);
        var results = this.getResultByConditions(conditions);
        var treeNodes = null;
        if (!results || results.length < 1) {
            this.treeView.clearTreeData();
//            return;
        }else{
            treeNodes = this.orgTreeManager.organizeTree(results);
            this.treeView.setData(treeNodes, false);
        }
        this.setResult(results,treeNodes);
    },

    /**
     * 
     * 
     */
    getResultByConditions : function(conditions){
        return this.dataFinder.find(conditions);
    },

    /**
     * 
     * @param results
     * @param treeNodes
     */
    setResult : function(results,treeNodes){

    },

    clearSearch : function(){
        this.treeView.setData(null);
        this.clearSearchData();
        this.sceneManager.network3d.dirtyNetwork();
    },

    /**
     * 
    */
    clearSearchData : function(){

    },

    /**
     * ,
     */
    clearAll : function(){
        this.treeView.setData(null);
        if(this.inputPane.clearInput){
            this.inputPane.clearInput();
        }
        // this.removeVirtualManager();
        if(this.clearAllFunction){
            this.clearAllFunction();
        }else{
            this.clearSearchData();
        }
    },

    shouldClick : function(data){
        return true;
    },

    getRootDataBySceneAndData : function(scene,data,scope){
        if(!scene || !data){
            return null;
        }
        scope = scope || this;
        var dataType = this.sceneManager.dataManager.getDataTypeForData(data);
        if(dataType && dataType.getCategoryId() === scene.getCategoryId()){
            return data;
        }else if(data.getParentId()){
            var parent = this.sceneManager.dataManager.getDataById(data.getParentId());
            if(parent){
                return scope.getRootDataBySceneAndData(scene,parent,scope);
            }
        }
        return null;
    },

    /**
     * camera
     * dcnode;
     * 2nodeScenecurrentScenerootNode12;
     *
     * @param treeData
     */
    clickTreeNode : function(treeData){
        var id = treeData.id;
        if(!id) return;
        if(!this.sceneManager.viewManager3d.enableDBLClick){ //
            return;
        }
        var data = this.sceneManager.dataManager.getDataById(id);
        if(!data || !this.treeView.isClick(data)) return;
        var assetNode = this.sceneManager.dataNodeMap[id];
//        var nodeData = this.sceneManager.getNodeData(assetNode);
        if(!this.shouldClick(data)){
            return;
        }
        if(!this.sceneManager.isCurrentSceneInstance(data,true)){ //
            var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
            if(sceneAndRootData){
                this.sceneManager.gotoScene(sceneAndRootData.scene,sceneAndRootData.rootData,null,false);
                //gotoScene
                //lookAt(Dataroot)
                if(sceneAndRootData.rootData != data){
                    assetNode = this.sceneManager.dataNodeMap[id];
                    if(!assetNode){
                        this.sceneManager.loadLazyData(data);
                    }
                }else{
                    return ; //clickData
                }
            }
        }
        //
        //1lazyablefocus()box
        //2boxlazyable
        var box3d = this.sceneManager.network3d.getDataBox();
        if(!assetNode || !box3d.getDataById(assetNode.getId())){
            this.sceneManager.loadLazyData(data);
            if(!assetNode){
                assetNode = this.sceneManager.dataNodeMap[data.getId()];
            }
        }
        if(this.defaultEventHandler 
            && assetNode != this.sceneManager.getCurrentRootNode()){ //gotoScenesetFocus
            this.defaultEventHandler.lookAt(assetNode);
        }
    },

    mouseOverTreeNode : function(treeData){
        var id = treeData.id;
        this.sceneManager.network3d.getDataBox().getSelectionModel().clearSelection();
        if (id) {
            var assetNode = this.sceneManager.dataNodeMap[id];
            if (assetNode) {
                assetNode.setSelected(true);
            }
        }
    },

    getTreeView : function(){
        return this.treeView;
    },

    getOrganizeTreeManager : function(){
        return this.orgTreeManager;
    },

});

/**
 * 
 * @param sceneManager
 * @constructor
 */
it.ITSearchManager = function(sceneManager,inputPane){
    it.ITSearchManager.superClass.constructor.call(this, sceneManager,inputPane);
    this._assetImage = "data:image/png;base64,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";
}

mono.extend(it.ITSearchManager,it.BaseSearch,{

    createInputPane : function(){
        return new it.ITSearchPanel();
    },

    clearSearchData : function(){
        this.clearBillboard();
    },

    setResult : function(results,treeNodes){
        this.clearBillboard();
        this.virtualManager.addAll();
        if(!treeNodes) {
            this.showNoData();
            return;
        }
        for(var i = 0 ; i < treeNodes.length; i++){
            var treeNode = treeNodes[i];
            this.showData(treeNode);
        }
    },

    showData : function(treeNode){
        var data = this.orgTreeManager.getDataByNode(treeNode);
        if(!data){
            return;
        }
        if(this.showBillboard(data)){
            this.addDataBillBoard(data);
        }
        this.virtualManager.remove(data); // removeByDescendant
        var children = this.orgTreeManager.getChildren(treeNode);
        if(children && children.length > 0){
            for(var i = 0 ;i < children.length ; i++){
                var child = children[i];
                if(child){
                    this.showData(child,this);
                }
            }
        }
    },

    /***
     * Databillboard
     * @param data
     * @returns {boolean}
     */
    showBillboard : function(data){
        if(!data) return false;
        var assetType = data.getDataTypeId();
        if(assetType){
            if(assetType.indexOf('equipment') >=0){
                return false;
            }
            if(assetType.indexOf('room') >=0){
                return false;
            }
            if(assetType.indexOf('floor') >=0){
                return false;
            }
        }
        return true;
    },

    clearBillboard : function(){
        if(this.sceneManager.dataNodeMap){
            for(var id in this.sceneManager.dataNodeMap){
                var node = this.sceneManager.dataNodeMap[id];
                if(node && node.getClient('asset_billboard')){
                    var billboard = node.getClient('asset_billboard');
                    billboard.setParent(null);
                    this.sceneManager.network3d.getDataBox().remove(billboard);
                }
            }
        }
        this.virtualManager.clearAll();
    },

    /**
     * Billboard
     * @param data
     */
    addDataBillBoard : function(data){
        if(!data) return;
        var node = this.sceneManager.dataNodeMap[data.getId()];
        if(!node) return;
        var box = this.sceneManager.network3d.getDataBox();
        if(!box.getDataById(node.getId())){
            return ;
        }
        var billboard = new mono.Billboard();
        billboard.setPosition(0, node.getBoundingBox().max.y + 20, 0);
        billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
        billboard.setStyle('m.transparent', true);
//        billboard.setStyle('m.texture.image', TML.Factory3D.getImagePath('asset.png'));
        billboard.setStyle('m.texture.image', this._assetImage);
        billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
        // billboard.setStyle('m.vertical', true);
        billboard.setScale(40, 50, 1);
        billboard.setParent(node);
        billboard.setClient('it_data',data);
        box.add(billboard);
        node.setClient('asset_billboard', billboard);
    }

});

it.SpaceSearchVirtualManager = function (sceneManager, spaceManager) {
    it.VirtualManager.call(this, sceneManager);
    this.spaceManager = spaceManager;
}

mono.extend(it.SpaceSearchVirtualManager, it.VirtualManager, {

    beforeAdd: function (data) {
        if (data) {
            // delete data._userDataMap['dyna_user_data_totalSpace']; //
            // delete data._userDataMap['dyna_user_data_totalOccupation']; //
            delete data._userDataMap['dyna_user_data_maxSerSpace']; //
            // delete data._userDataMap['dyna_user_data_totalEmpSpace']; //
            delete data._userDataMap['dyna_user_data_totalCount']; //uNumberU
            delete data._userDataMap['dyna_user_data_empCount']; //uNumberU
        }
    },

    filterMaterial: function (originalMaterial, filterdMaterial, node) {
        var sm = this.sceneManager;
        var sm2 = this.spaceManager;
        var map = this.materialMap;
        if (sm.getNodeData(node)) {
            return filterdMaterial;
        }
        if (sm2.isSpaceNode(node)) {
            var parent = node.getParent();
            if (sm2.isSpaceNode(parent)) {
                parent = parent.getParent();
            }
            var transFlag = false;
            if (parent) {
                var data = this.getDataByNode(parent);
                if (data) {
                    id = this.getBId(data);
                    if (this._global_tmap[id]) { // global
                        transFlag = this._global_tmap[id];
                    } else if (this._tmap[id]) {
                        transFlag = this._tmap[id];
                    }
                }
            }
            if (!transFlag) {
                return filterdMaterial;
            }
            var id = originalMaterial.getUniqueCode();
            var m = this.materialMap[id];
            if (!m) {
                m = originalMaterial.clone();
                this.materialMap[id] = m;
                m.transparent = true;
                m.opacity = 0.05;
            }
            return m;
        }
    }

});

/**
 *  
 *  
 * @param sceneManager
 * @constructor
 */
it.SpaceSearchManager = function (sceneManager, inputPane, mode) {
    it.BaseSearch.call(this, sceneManager, inputPane);
    this.spaceManager = new it.SpaceManager(this.dataManager, this.sceneManager);
    this.diagram = new it.Diagram();
    this.isVirtualFunction = null;
    this.virtualNode = [];
    this.spaceMap = {};
    this.mode = mode || 1;
    this.maxRackUSize = 47;
    var self = this;
    this.spaceManager.spaceNodeColorFunction = function (percent, data, space) {
        // ratio 
        // if (space) {
        if (data && data.getUserData('dyna_user_data_empCount')) {
            var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
            var num = self.getUNumber() || 1;
            var total_count = Math.floor(self.maxRackUSize/num);
            var unit_count = Math.floor(total_count / 4); //ceil
            if (total_count <= 4) {
                if (occupationCount === total_count) {
                    return '#5DBDE0'; //
                } else if ((total_count - 1) > 0 && occupationCount === (total_count - 1)) {
                    return '#6FD772';
                } else if ((total_count - 2) > 0 && occupationCount === (total_count - 2)) {
                    return '#FFC95A';
                } else {
                    return '#Fd674F';
                }
            } else {
                if (occupationCount <= unit_count) {
                    return '#Fd674F';
                } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
                    return '#FFC95A';
                } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
                    return '#6FD772';
                } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
                    return '#5DBDE0';
                } else {
                    console.log('can not compute the spaceNodeColorFunction color !');
                }
            }
        }
        // }
        if (!percent) { //
            return '#5DBDE0'; //'#BEEB9F';
        } else if (percent <= 0.25) {
            return '#5DBDE0'; //'#BEEB9F'; 
        } else if (percent <= 0.5) {
            return '#6FD772'; // FFFF99 
        } else if (percent <= 0.75) {
            return '#FFC95A'; //'#FFBB11'; 
        } else {
            return '#Fd674F'; // FF3357 '#FF6138'; //
        }
    };

    this.spaceManager.spaceNodeFrameColorFunction = function (percent, data, space) {
        // if (space) {
        if (data && data.getUserData('dyna_user_data_empCount')) {
            var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
            var num = self.getUNumber() || 1;
            var total_count = Math.floor(self.maxRackUSize/num);
            var unit_count = Math.floor(total_count / 4); //ceil
            if (total_count <= 4) {
                if (occupationCount === 1) {
                    return '#018ABD';
                } else if (occupationCount === 2) {
                    return '#1A920A';
                } else if (occupationCount === 3) {
                    return '#E68D00';
                } else {
                    return '#CE3118';
                }
            } else {
                if (occupationCount <= unit_count) {
                    return '#CE3118';
                } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
                    return '#E68D00';
                } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
                    return '#1A920A';
                } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
                    return '#018ABD';
                } else {
                    console.log('can not compute the spaceNodeFrameColorFunction color !');
                }
            }
        }
        // }
        if (!percent) { //
            return '#018ABD'; //'#BEEB9F';
        } else if (percent <= 0.25) {
            return '#018ABD'; //'#BEEB9F'; 
        } else if (percent <= 0.5) {
            return '#1A920A'; // FFFF99 
        } else if (percent <= 0.75) {
            return '#E68D00'; //'#FFBB11'; 
        } else {
            return '#CE3118'; // FF3357 '#FF6138'; //
        }
    };

    this.resetTreeLabel();
    this.virtualAllNodes();
    this.clearAllFunction = function () {
        this.clearSpaceNode();
    }
}

mono.extend(it.SpaceSearchManager, it.BaseSearch, {
    beforeDoClick: function () {
        var cn = this.sceneManager._currentRootNode;
        this.sceneManager.viewManager3d.defaultEventHandler.lookAt(cn);
    },
    /**
     * 
     */
    setupInit: function () {
        if (!this.visOrVirtFilter) { // 
            this.visOrVirtFilter = this.setVisibleOrVirtualData(this.sceneManager);
        }
        if (this.visOrVirtFilter instanceof it.VisibleManager) {
            this.sceneManager.viewManager3d.addVisibleFilter(this.visOrVirtFilter);
        } else if (this.visOrVirtFilter instanceof it.VirtualManager) {
            this.sceneManager.viewManager3d.addMaterialFilter(this.visOrVirtFilter);
        }
        
        this.addVirtualManager();
        this.setupDoOther(this.sceneManager);
    },

    /**
     * IT
     * floor clear
     *         buildingsceneChangeListener
     * */
    clearInit: function () {
        this.sceneManager.removeSceneChangeListener(this.sceneChangeListener);
        if (this.visOrVirtFilter) {
            if (this.visOrVirtFilter instanceof it.VisibleManager) {
                this.sceneManager.viewManager3d.removeVisibleFilter(this.visOrVirtFilter);
            } else if (this.visOrVirtFilter instanceof it.VirtualManager) {
                this.sceneManager.viewManager3d.removeMaterialFilter(this.visOrVirtFilter);
            }
        }
        this.removeVirtualManager();
        this.clearDoOther(this.sceneManager);
    },

    /**
     * 
     * @param dataTypeId
     * @param data
     * @returns {boolean}
     */
    invisibleOrVirtualData: function (dataTypeId, data) {
        if (!dataTypeId && !data) {
            return false;
        }
        var category = this.sceneManager.dataManager.getCategoryForDataType(dataTypeId);
        if (category && category.getId() && category.getId().toLowerCase().indexOf('channel') >= 0) {
            return true;
        }
        return false;
    },

    /**
     * ()data
     * @param visibleFiltervirtualManager
     */
    setVisibleOrVirtualData: function (sceneManager) {
        var visibleFilter = new it.VisibleManager(sceneManager);
        var groupByType = this.dataManager._dataTypeDatas;
        if (groupByType) {
            for (var typeId in groupByType) {
                if (this.invisibleOrVirtualData(typeId)) {
                    var datas = groupByType[typeId];
                    if (datas) {
                        for (var id in datas) {
                            visibleFilter.setVisible(datas[id], false);
                        }
                    }
                }
            }
        }
        return visibleFilter;
    },

    /**
     * 
     * @param sceneManager
     */
    setupDoOther: function (sceneManager) {

    },

    /**
     * 
     * @param sceneManager
     */
    clearDoOther: function (sceneManager) {

    },

    createInputPane: function () {
        this.inputPane = new it.SpaceSearchPanel();
        return this.inputPane;
    },

    getVirtualManager: function () {
        return new it.SpaceSearchVirtualManager(this.sceneManager, new it.SpaceManager(this.dataManager, this.sceneManager));
    },

    resetTreeLabel: function () {
        var self = this;
        this.orgTreeManager.createLabel = function (treeData) {
            return self.setLabel(treeData);
        }
    },

    getUNumber: function () {
        if (this.inputPane) {
            return parseInt(this.inputPane.getUNumber());
        } else {
            return 1;
        }
    },

    setLabel: function (treeData) {
        if (!treeData || !treeData.getId()) {
            return null;
        }
        var id = treeData.getId();
        var data = this.dataManager.getDataById(id);//data
        // var space = this.spaceMap[id];
        var prex = this.getTreeNodeLabel(treeData);
        if (!prex) {
            prex = id;
        }
        var count = 0;
        if (data) {
            count = parseInt(data.getUserData('dyna_user_data_empCount'));//uNumberU
        }
        if (count) {
            prex += '(' + count + ')';
        }
        return prex;
    },

    /**
     * 
     */
    getTreeNodeLabel: function (treeData) {
        if (treeData) {
            return treeData.getId();
        }
        return "";
    },

    /**
     * datatree
     */
    setData: function (conditions) {
        var results = this.dataFinder.find(conditions);
        var treeNodes = null;
        this.setResult(results);
        if (!results || results.length < 1) {
            this.showNoData();
            this.treeView.clearTreeData();
        } else {
            treeNodes = this.orgTreeManager.organizeTree(results);
            this.treeView.setData(treeNodes, false);
        }
    },

    setResult: function (result, treeNodes) {
        this.clearSpaceNode(); // 
        this.virtualManager.addAll();
        if (!result) return;
        var nodes = [];
        for (var i = 0; i < result.length; i++) {
            var data = result[i];
            var node = this.sceneManager.dataNodeMap[data.getId()];
            //nodecolor Cube
            //            var spaceNode = this.getSpaceNode(node);
            this.virtualManager.remove(data);
            if (node) {
                this._dealWithOneNode(node);
                nodes.push(node);
            }
        }
        this.showSpaceNode(nodes);
    },

    beforHide: function () {
        this.diagram.hideDiagram();
    },

    /**
     * 
      */
    clearSearchData: function () {
        this.initAllNodes();
        this.showSpaceNode();
        this.virtualManager.clearAll();
    },

    clearSpaceNode: function () {
        var nodes = this.getAllNodes();//this.virtualNode;
        this.spaceManager.remove1DSpaceNodeForNodes(nodes);
        this.spaceManager.hideSpaceMode();
        this.showSerialDiagram(1, nodes);
    },

    virtualAllNodes: function () {
        this.initAllNodes();
        this.showSpaceNode();
    },

    /**
     * 
     * @result 
     * create1DSpaceNodeForNodesnodes
     */
    showSpaceNode: function (result) {
        var nodes = this.getSceneNodes();
        if (!result || result.length < 1) {
            result = nodes;
        }
        if (nodes && nodes.length > 0) {
            this.showSerialDiagram(this.getUNumber(), result);
        } else { //node
            this.diagram.hideDiagram();
        }
        //        this.spaceManager.remove1DSpaceNodeForNodes(nodes);//create
        this.spaceManager.create1DSpaceNodeForNodes(nodes, this.mode); // 
        this.spaceManager.showSpaceMode();
    },

    /**
     * 
     * @param num maxRackUSize
     * 
     */
    showSerialDiagram: function (num, nodes) {
        var datas = [];
        var serialNumColorMap = {};
        num = parseInt(num);
        if (!num) {
            num = 1;
        }
        this.num = num;
        var total_count = Math.floor(this.maxRackUSize/num);
        var unit_count = Math.floor(total_count / 4); //ceil

        var color = this.getCapacityColor(0.1);
        var data = {
            color: color,
            minCount: (unit_count * 3 + 1),
            maxCount: total_count,
            value: (unit_count * 3 + 1) + '-' + total_count
        };
        if (total_count <= 4) {
            data.value = total_count;
            data.minCount = total_count;
            data.maxCount = total_count;
            serialNumColorMap[total_count] = color;
        } else {
            for (var i = (unit_count * 3 + 1); i <= total_count; i++) {
                serialNumColorMap[i] = color;
            }
        }
        datas.push(data);


        color = this.getCapacityColor(0.3);
        data = {
            color: color,
            minCount: (unit_count * 2 + 1),
            maxCount: unit_count * 3,
            value: (unit_count * 2 + 1) + '-' + (unit_count * 3)
        };
        if (total_count > 1 && total_count <= 4) {
            data.value = total_count - 1;
            data.minCount = total_count - 1;
            data.maxCount = total_count - 1;
            serialNumColorMap[total_count - 1] = color;
        } else {
            for (var i = (unit_count * 2 + 1); i <= (unit_count * 3); i++) {
                serialNumColorMap[i] = color;
            }
        }
        if (total_count > 1) {
            datas.push(data);
        }

        color = this.getCapacityColor(0.6);
        data = {
            color: color,
            minCount: (unit_count + 1),
            maxCount: unit_count * 2,
            value: (unit_count + 1) + '-' + (unit_count * 2)
        };
        if (total_count > 2 && total_count <= 4) {
            data.value = total_count - 2;
            data.minCount = total_count - 2;
            data.maxCount = total_count - 2;
            serialNumColorMap[total_count - 2] = color;
        } else {
            for (var i = (unit_count + 1); i <= (unit_count * 2); i++) {
                serialNumColorMap[i] = color;
            }
        }
        if (total_count > 2) {
            datas.push(data);
        }

        color = this.getCapacityColor(0.8);
        data = {
            color: color,
            minCount: 1,
            maxCount: unit_count,
            value: '1-' + unit_count
        };
        if (total_count > 3 && total_count <= 4) {
            data.value = total_count - 3;
            data.minCount = total_count - 3;
            data.maxCount = total_count - 3;
            serialNumColorMap[total_count - 3] = color;
        } else {
            for (var i = 1; i <= unit_count; i++) {
                serialNumColorMap[i] = color;
            }
        }
        if (total_count > 3) {
            datas.push(data);
        }
        var usedP = {};
        var totalMap = {};
        if (nodes && nodes.length > 0) {
            for (var i = 0; i < nodes.length; i++) {
                var data = this.sceneManager.getNodeData(nodes[i]);
                var dColor = serialNumColorMap[data.getUserData('dyna_user_data_empCount')];
                var space = data.getUserData('dyna_user_data_totalSpace');//
                var occupation = data.getUserData('dyna_user_data_totalOccupation');//

                if (dColor) {
                    if (totalMap[dColor]) {
                        totalMap[dColor]++;
                    } else {
                        totalMap[dColor] = 1;
                    }
                    if (usedP[dColor]) {
                        var us = usedP[dColor];
                        var percent = Math.round(occupation / space * 100);
                        if (percent < us.minP) us.minP = percent;
                        if (percent > us.maxP) us.maxP = percent;
                    } else {
                        var percent = Math.round(occupation / space * 100);
                        usedP[dColor] = { 'minP': percent, 'maxP': percent };
                    }
                }
            }
            for (var i = 0; i < datas.length; i++) {
                var itemData = datas[i];
                if (!itemData) {
                    continue;
                }
                if (totalMap[itemData.color]) {
                    var strValue = '';
                    if (itemData.minCount) {
                        strValue = itemData.minCount;
                    }
                    if (itemData.minCount != itemData.maxCount) {
                        strValue += '-' + itemData.maxCount;
                    }
                    strValue += '(' + totalMap[itemData.color] + ')';
                    itemData.value = strValue;
                }

            }
        }
        $.each(datas, function (index, val) {
            var used = usedP[val.color];
            var count = totalMap[val.color] || 0;
            val.tip = '' + val.minCount + '-' + val.maxCount + '' + num + 'U' + count + '';
            if (used) {
                val.tip += ', ' + used.minP + '% - ' + used.maxP + '%';
            }
        });

        this.diagram.setData(datas, '', function (index, el) {
            var data = datas[index];
            layer.tips(data.tip, el, { tips: [3, data.color], time: 30000 });//'#428BCA'
        }, function (index, el) {
            layer.closeAll();
        });
    },

    getCapacityColor: function (ratio) {
        // ratio 
        if (!ratio) {
            return '#5DBDE0';//'#BEEB9F';
        } else if (ratio <= 0.25) {
            return '#5DBDE0';//'#BEEB9F'; 
        } else if (ratio <= 0.5) {
            return '#6FD772';  // FFFF99 
        } else if (ratio <= 0.75) {
            return '#FFC95A';//'#FFBB11'; 
        } else {
            return '#Fd674F';// FF3357 '#FF6138'; //
        }
    },

    isDealwith: function (node) {
        if (!node) return false;
        if (this.isVirtualFunction) {
            return this.isVirtualFunction(node);
        }
        var data = this.sceneManager.getNodeData(node);
        if (!data) return false;
        // var type = this.sceneManager.dataManager.getDataTypeForData(data);
        // if(!type) return false;
        // if(type._model.indexOf('.rack') >0){
        //     return true;
        // }
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId().toLowerCase() == 'rack') {
            return true;
        }
        return false;
    },

    getDataSpace: function (data) {
        if (!data) {
            return null;
        }
        var space = this.spaceMap[data.getId()];
        if (!space) {
            var dataSpace = this.spaceManager.computeSpace(data);
            if (dataSpace && (dataSpace instanceof it.Space1)) {
                this.spaceMap[data.getId()] = dataSpace;
                space = dataSpace;
            }
        }
        return space;
    },

    _dealWithOneNode: function (node) {
        var uNumber = this.getUNumber();
        if (!uNumber) {
            uNumber = 1;
        }
        if (node) {
            if (this.isDealwith(node)) {
                var data = this.sceneManager.getNodeData(node);
                if (!data) return;
                // var space = this.spaceMap[data.getId()]; 
                // if (!space) {
                //     space = this.spaceManager.computeSpace(data);
                //     if(space && (space instanceof it.Space1)){
                //        this.spaceMap[data.getId()] = space;
                //     }
                // }
                var space = this.getDataSpace(data);
                var count = 0;
                // if(space && (space instanceof it.Space1)){
                if (space) {
                    // this.spaceMap[it.SceneManager.getNodeDataId(node)] = space;
                    var maxEmpSerSpace = 0, totalEmpSpace = space.getTotal() - space.getOccupation();
                    var empList = space.getEmptyList();
                    if (empList && empList.length > 0) {
                        for (var i = 0; i < empList.length; i++) {
                            var ep = empList[i];
                            if (ep.total > maxEmpSerSpace) {
                                maxEmpSerSpace = ep.total;
                            }
                            if (ep.total >= uNumber) {
                                count += Math.floor(ep.total / uNumber);
                            }
                        }
                    }
                    data.setUserData('dyna_user_data_totalSpace', space.getTotal());//
                    data.setUserData('dyna_user_data_totalOccupation', space.getOccupation());//
                    data.setUserData('dyna_user_data_maxSerSpace', maxEmpSerSpace);//
                    data.setUserData('dyna_user_data_totalEmpSpace', totalEmpSpace);//
                    data.setUserData('dyna_user_data_totalCount', parseInt(space.getTotal() / uNumber));//uNumberU
                    data.setUserData('dyna_user_data_empCount', count);//uNumberU
                    this.virtualNode.push(node);
                }
            }
        }
    },

    /**
     * Node
     * @returns {*}
     */
    getAllNodes: function () {
        var nodeMap = this.sceneManager.dataNodeMap;
        if (!nodeMap) return null;
        var allNodes = [];
        for (var id in nodeMap) {
            var node = nodeMap[id];
            if (node && this.isDealwith(node)) {
                var data = this.sceneManager.getNodeData(node);
                if (!data) return;
                // var space = this.spaceManager.computeSpace(data);
                // if (space && (space instanceof it.Space1)) {
                var space = this.getDataSpace(data);
                if (space) {
                    allNodes.push(node);
                }
            }
        }
        return allNodes;
    },

    /**
     * node
     */
    getSceneNodes: function () {
        var sceneNodes = [];
        var sceneDatas = this.sceneManager.getSceneDatas();
        if (sceneDatas) {
            var nodeMaps = this.sceneManager.dataNodeMap;
            for (var id in sceneDatas) {
                var node = nodeMaps[id];
                var data = sceneDatas[id];
                if (node && data && this.isDealwith(node)) {
                    // var space = this.spaceManager.computeSpace(data);
                    var space = this.getDataSpace(data);
                    // if (space && (space instanceof it.Space1)) {
                    if (space) {
                        this._dealWithOneNode(node);
                        sceneNodes.push(node);
                    }
                }
            }
        }
        return sceneNodes;
    },

    initAllNodes: function () {
        var nodeMap = this.sceneManager.dataNodeMap;
        if (!nodeMap) return null;
        this.virtualNode = [];
        for (var id in nodeMap) {
            var node = nodeMap[id];
            var data = this.sceneManager.getNodeData(node);
            if (data) {
                data.setUserData('dyna_user_data_totalCount', null);//
                data.setUserData('dyna_user_data_empCount', null);
            }
            this._dealWithOneNode(node);
        }
        return this.virtualNode;
    }

});
it.Tab = function () {

};

mono.extend(it.Tab, Object, {

    _getTargetLi: function (element) {
        if (!element) return null;
        if (element.tagName && element.tagName.toUpperCase() == 'LI') {
            return element;
        } else if (element.parentElement) {
            return arguments.callee(element.parentElement);
        }
        return null;
    },

    _onclick: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        }
        var targetLi = this._getTargetLi(event.originalEvent.target);
        var href = targetLi.getAttribute('href'); // 
        if (!href) {
            href = targetLi.childNodes[0].getAttribute('href');
        }

        if (href && href.length > 0) {
            var id = href.substring(1, href.length);

            if ($('#' + id)[0] && $('#' + id)[0].children && $('#' + id)[0].children.length > 0) { //tabtabcontent
                //lihover,
                this._clearHover();
                targetLi.className = 'hover';
                //contentitem
                $('.contentbox div.tab-pane').hide(); // contentboxdiv
                $('#' + id).show();
            }
        }
    },

    _clearHover: function () {
        var menuItems = $('.property-pane-tab .menu ul li');
        if (menuItems && menuItems.length > 0) {
            for (var i = 0; i < menuItems.length; i++) {
                var menuItem = menuItems[i];
                if (menuItem && menuItem.className) {
                    menuItem.className = "";
                }
            }
        }
    },

    initAll: function () {
        var self = this;
        $('.property-pane-tab .menu ul li').click(function (event) {
            self._onclick(event);
        });
    }

});

it.PropertyPane = function (parentDiv) {
    this.propertyPane = $("<div class='property-pane it-shadow'></div>");
    this.propertyTab = $("<div class='property-pane-tab'></div>");
    this.propertyItemsDiv = $("<div class='menu'></div>");//it-shadow
    this.propertyItemsPane = $("<ul></ul>");
    this.propertyTabContent = $('<div class="contentbox scroll-class">'); //tab-content scroll-class  it-shadow
    this.propertyItemsDiv.append(this.propertyItemsPane);
    this.propertyTab.append(this.propertyItemsDiv);
    this.propertyTab.append(this.propertyTabContent);
    this.propertyPane.append(this.propertyTab);
    if (!parentDiv) {
        parentDiv = document.body;
    }
    parentDiv.appendChild(this.propertyPane[0]);
    this.closeDiv = $('<div class="it-property-title"></div>'); //it-property-title it-shadow it-shadow
    this.propertyPane.prepend(this.closeDiv);

    this.isvisible;
    this.tab = new it.Tab();
    this.hide();
};

mono.extend(it.PropertyPane, Object, {

    _createTitle: function (titleText) {
        if (!titleText) {
            titleText = '';
        }
        var titleDiv = $('<span>' + titleText + '</span>');
        var closeIcon = $('<div class="close"></div>');
        var self = this;
        closeIcon.click(function (e) {
            self.hide();
        });
        this.closeDiv.append(titleDiv);
        this.closeDiv.append(closeIcon);
    },

    clear: function () {
        this.propertyItemsPane.empty();
        this.propertyTabContent.empty();
        this.closeDiv.empty();
    },

//{title:title,items:[{icon:icon,onclick:callback,title:t,properties:pro/[{key:value},{}]},{icon:icon.....}]}
    /**
     * showIndextab
     */
    setData: function (contents, node, titleText, showIndex) {
        this.clear();
        this._createTitle(titleText);
        if (!contents || !contents.items || contents.items < 1) return;
        var self = this;
        var items = contents.items;
        for (var i = 0; i < items.length; i++) {
            var item = items[i]; //{icon:icon,title:t,propertyObj:pro/[{key:value},{}]}
            if (!item) {
                continue;
            }
            if (item.isShow && !item.isShow(node)) {
                continue;
            }
            var href = "tab_" + i;
            var title = item.title;
            //  var icon = item.icon;
            var className = item.className;
            var on_click = item.onclick;
            var propertyObj = item.properties;
            var isGroup = item.isGroup || item.isGrop;
            if (i == 0) {
                //        this.addTab(href,title,propertyObj,icon,true,isGroup,on_click);
                this.addTab(href, title, propertyObj, className, true, isGroup, on_click, node);
            } else {
                //    this.addTab(href,title,propertyObj,icon,false,isGroup,on_click);
                this.addTab(href, title, propertyObj, className, false, isGroup, on_click, node);
            }
        }

        //tooltip
        this.showTooltip({
            id: '.menu ul li a',
            parent: this.propertyPane,
            offsetY: 10
        });

        this.tab.initAll();
        this.showTabByIndex(showIndex);
    },

    /**
     *
     * @param href
     * @param title
     * @param contentObj
     * @param icon
     * @param visible
     * @param onclick
     * @param isButton buttonbutton,tab
     * @param data
     */
    addTab: function (href, title, contentObj, className, visible, isGroup, onclick, node) {
        var tabItem = $('<li ><a href="#' + href + '" rel = "' + title + '" class= ' + className + ' ></a></li>');

        if (visible) {
            tabItem.show();
            tabItem.attr('class', 'hover');
        }
        if (onclick) {
            tabItem.click(onclick);
        }

        this.propertyItemsPane.append(tabItem);
        var tabItemContent = $('<div class="tab-pane" id="' + href + '"></div>');
        if (visible) {
            tabItemContent.show();
        }
        tabItemContent.append(this.createTableItemContentByObj(contentObj, isGroup, node));
        this.propertyTabContent.append(tabItemContent);
    },

    showTabByIndex: function (index) {
        // var tab = $('[href="#tab_"'+index+']');
        var id = 'tab_' + parseInt(index || 0);
        // $('[href="#tab_0"]').parent().attr('class','hover')
        if ($('#' + id)[0]
            && $('#' + id)[0].children
            && $('#' + id)[0].children.length > 0
            && $('[href="#' + id + '"]')
            && $('[href="#' + id + '"]').length > 0
        ) {
            this.tab._clearHover();
            // targetLi.className = 'hover';
            $('[href="#' + id + '"]').parent().attr('class', 'hover');
            $('.contentbox div.tab-pane').hide(); // contentboxdiv
            $('#' + id).show();
        }
    },

    createTableItemContentByObj: function (contentObj, isGroup, node) {
        if (!contentObj) {
            return;
        }
        var table = $('<form class="form-horizontal" role="form"></form>');
        var src = contentObj.src;
        if (typeof(src) == 'function') {
            src = src(node);
        }
        if (contentObj.isIframe && src) { //iframeurl
            table = $('<form class="form-horizontal" role="form" style="position:relative;height:100%;width:100%"></form>');
            var pane = '<iframe src="' + src + '" style="position: relative;height: 100%;width: 100%"></iframe>';
            table.append(pane);
        } else if (contentObj instanceof Array) {  //[{name:'name',value:'dddd',callback:callback},{name:'id',value:'ssddfr',callback:callback}]
            if (contentObj.length > 0) {
                if (contentObj.title) {
                    var head = this._createTableRow(contentObj.title);
                    if (head) {
                        table.append(head);
                    }
                }
                for (var i = 0; i < contentObj.length; i++) {
                    var proItem = contentObj[i];
                    if (proItem) {
                        var callback = proItem.callback;
                        var mousemove = proItem.mousemove;
                        if (proItem.values) {
                            var values = proItem.values;
                            var row = this._createTableRow(values, (i + 1), callback, mousemove);
                            if (row) {
                                table.append(row);
                            }
                        } else if (proItem.name) {
                            var name = proItem.name;
                            var value = proItem.value;
                            var row = this._createKeyValueRow(name, value, isGroup, (i + 1), callback, mousemove);//headrow
                            if (row) {
                                table.append(row);
                            }
                        }
                    }
                }
            }
        } else { // objectproperty
            for (var pro in contentObj) {
                if (typeof(contentObj[pro]) != 'function') {
                    var value = contentObj[pro];
                    var valText = value,
                        onclick = null,
                        style = null,
                        classname = null,
                        isButton = false;
                    if (value) {
                        if (value.value != undefined) {
                            valText = value.value;
                        }
                        if (value.onclick) {
                            onclick = value.onclick;
                        }
                        if (value.isButton && value.isButton == true) {
                            isButton = true;
                        }
                        if (value.style) {
                            style = value.style;
                        }
                        classname = value.classname;
                    }
                    var row = this._createKeyValueRow(pro, valText, isGroup, null, onclick, null, isButton, style, classname, node);
                    if (row) {
                        table.append(row);
                    }
                }
            }
        }
        return table;
    },

    _createTableHead: function (titles) {
        if (!titles) return;
        var row = $('<div class="form-group-no-margin"></div>');
        if (titles instanceof Array && titles.length > 0) {
            var count = Math.floor(12 / titles.length);
            if (count > 1) {
                var className = "col-sm-" + count + " table-label-min label-inline-block";
                for (var i = 0; i < titles.length; i++) {
                    var val = titles[i];
                    if (val) {
                        var label_Value = $('<label class="' + className + '">' + val + '</label>');
                        row.append(label_Value);
                    }
                }
                return row;
            }
        }
        else {
            // 
//        for(var pro in titles){
//            if(typeof(titles[pro]) != 'function') {
//                var value = titles[pro];
//                var row = this._createKeyValueRow(pro,value,isGroup);
//                if(row){
//                    table.append(row);
//                }
//            }
//        }
        }
    },

    /**
     *
     * @param label
     * @param value
     * @param isGroup 
     * @param hasHead
     * @param isTableRow
     * @param i
     * @param callback
     * @param mousemove
     * @returns {*}
     * @private
     */
    _createKeyValueRow: function (label, value, isGroup, i, onclick, mousemove, isButton, style, classname, node) {
        if (!label && !value) return null;
        var rowClass = 'form-group-no-margin';
        var row = $('<div class="' + rowClass + '"> </div>');
        var btnClass = '';
        if (isButton) {
            btnClass = 'col-btn';
        }
        var callback = function (e) {
            onclick && onclick(e, node);
        }
        if (value
            && typeof(value) != 'string' //int
            && !(value instanceof Array)) { // key-value
            if (value.isTitle) {
                var size = 15 - label.length;
                var lbText = '';
                if (size > 0) {
                    for (var i = 0; i < size / 2; i++) {
                        lbText += '';
                    }
                    ;
                }
                label = lbText + label + lbText;
                var labelNameClass = btnClass + 'col-sm-12 label-min label-inline-block ';
                var label_Name = $('<label style = "text-align:center" class="' + labelNameClass + '">' + label + '</label>');
                row.append(label_Name);
                return row;
            }
        }
        if (label) {
            label += ':';
        }
        var labelNameClass = 'col-sm-4 label-min label-inline-block';
        var label_Name = $('<label class="' + labelNameClass + '">' + label + '</label>');
        if (this.propertyPane.width() > 300) {
            label_Name.css('max-width', '100px');
        }
        row.append(label_Name);

        if (isGroup == undefined || isGroup == null) {
            isGroup = true;
        }
        var labelClass = 'contral-width label-inline-block';
        var label_Value = null;
        if (value instanceof Array && value.length > 0) {
            var div_Value = $('<div class = "col-sm-8 multi-label-value"></div>');
            if (this.propertyPane.width() > 300) {
                // div_Value.css('width',parseInt(this.propertyPane.width())-120);
            }
            if (!isGroup) {
                for (var i = 0; i < value.length; i++) {
                    var val = value[i];
                    if (val) {
                        var label_Value = $('<label class="' + labelClass + '">' + val + '</label>');
                        div_Value.append(label_Value);
                    }
                }
            } else {
                var step = 2;
                for (var i = 0; i < value.length; i += step) {
                    var val = value[i];
                    if (val) {
                        var val_0 = value[i];
                        var val_1 = value[i + 1];

                        var row_group = $('<div class = "row"></div>');
                        var row_div_0 = $('<div class = "col-xs-6 col-sm-6"></div>');
                        var row_div_1 = $('<div class = "col-xs-6 col-sm-6"></div>');
                        val_0 && row_group.append(row_div_0);
                        val_1 && row_group.append(row_div_1);
                        div_Value.append(row_group);

                        var col_v = $('<label class="' + labelClass + '">' + value[i] + '</label>');
                        row_div_0.append(col_v);

                        var col_v = $('<label class="' + labelClass + '">' + value[i + 1] + '</label>');
                        row_div_1.append(col_v);
                    }
                }
            }
            row.append(div_Value);
        } else {
            style = style || '';
            classname = classname || '';
            var hoverClass = '';
            if (!btnClass && callback) {
                // hoverClass = 'label_hover'; //remark 2016-12-29
            }
            ;
            label_Value = $('<label class=" ' + classname + btnClass + hoverClass + ' col-sm-8 label-value label-inline-block " style="' + style + '">' + value + '</label>');
            if (this.propertyPane.width() > 300) {
                // label_Value.css('width',parseInt(this.propertyPane.width())-120);
            }
            row.append(label_Value);
        }
        if (isButton && label_Value) {
            if (callback) {
                label_Value.click(callback);
            }
            if (mousemove) {
                label_Value.mousemove(mousemove);
            }
        } else {
            if (callback) {
                row.click(callback);
            }
            if (mousemove) {
                row.mousemove(mousemove);
            }
        }

        return row;
    },

    _createTableRow: function (values, i, callback, mousemove) {
        if (!values || values.length <= 0) return null;
        if (!(values instanceof Array)) {
            return;
        }
        var rowClass = 'form-group-no-margin';
        var count = Math.floor(12 / (values.length));
        if (count <= 0) return;
        if (i && i % 2 == 1) {
            rowClass = 'form-group-table-margin t-odd';
        } else {
            rowClass = 'form-group-table-margin';
        }

        var row = $('<div class="' + rowClass + '"> </div>');


        for (var j = 0; j < values.length; j++) {
            var val = values[j];
            if (val) {
                var text = val;
                var columnCount = count;
                if (val.c_width && parseInt(val.c_width)) {
                    columnCount = parseInt(val.c_width);
                }
//                if (val.text) { // 
                if (val.text != undefined) {
                    text = val.text;
                }

                var labelNameClass = 'col-sm-' + columnCount + ' table-label-min label-inline-block';
                var label_Value = $('<label class="' + labelNameClass + '">' + text + '</label>');
                row.append(label_Value);
            }
        }

        if (callback) {
            row.click(callback);
        }
        if (mousemove) {
            row.mousemove(mousemove);
        }
        return row;
    },

    show: function (content, node, title, offset, showIndex) {
        if (offset) {
            this.propertyPane.css('left', 'auto');
            this.propertyPane.css('right', 'auto');
            this.propertyPane.css('top', 'auto');
            this.propertyPane.css('bottom', 'auto');
            if (offset.left != null && offset.left != undefined) {
                this.propertyPane.css('left', parseInt(offset.left) + 'px');
            }
            if (offset.right != null && offset.right != undefined) {
                if (this.propertyPane.parent() && this.propertyPane.parent().css('width')) {
                    var left = parseInt(this.propertyPane.parent().css('width')) - parseInt(this.propertyPane.css('width')) - offset.right;
                    this.propertyPane.css('left', left + 'px');
                } else {
                    this.propertyPane.css('right', parseInt(offset.right) + 'px');
                }
            }
            if (offset.bottom != null && offset.bottom != undefined) {
                if (this.propertyPane.parent() && this.propertyPane.parent().css('height')) {
                    var top = parseInt(this.propertyPane.parent().css('height')) - parseInt(this.propertyPane.css('height')) - offset.bottom;
                    this.propertyPane.css('top', top + 'px');
                } else {
                    this.propertyPane.css('bottom', parseInt(offset.bottom) + 'px');
                }
            }
            if (offset.top != null && offset.top != undefined) {
                this.propertyPane.css('top', parseInt(offset.top) + 'px');
            }
        }
        this.setData(content, node, title, showIndex);
        this.propertyPane.show();
        this.isvisible = true;
    },

    hide : function () {
        this.propertyPane.hide();
        this.clear(); //htmlhtmlclickclicknode2017-10-13
        this.isvisible = false;
    },

    /**
     * tooltip
     * @param obj
     * {
     * id::'.menu ul li a''#maindivId'
     * selector,item$('.menu ul li a')$('#maindivId')
     * text:,tooltiptextidtargetrel
     * parent:,toolTippanel
     * offsetY:,y
     * offsetX:x
     * }
     */
    showTooltip: function (obj) {
        if (!obj || !obj.parent) {
            return;
        }
        var offsetY = obj.offsetY ? obj.offsetY : 0, offsetX = obj.offsetX ? obj.offsetX : 0;
        if (obj.id) {
            $(obj.id).mouseover(
                function (e) {
                    var myTitle = e.target.rel;
                    var tooltip = $("<div id='tooltip' class='tap-tooltip-content it-shadow'>" + myTitle + "</div>");
                    obj.parent.append(tooltip);
                    var offsetTop = e.target.offsetTop - e.target.offsetHeight + offsetY;
                    var offsetLeft = e.target.offsetLeft + e.target.offsetWidth + offsetX;
                    tooltip.css('top', offsetTop);
                    tooltip.css('left', offsetLeft);
                }
            ).mouseout(
                function () {
                    $("#tooltip").remove();
                }
            );
        } else if (obj.selector) {
            if (!obj.text) {
                return;
            }
            obj.selector.mouseover(
                function (e) {
                    var tooltip = $("<div id='tooltip' class='tap-tooltip-content it-shadow'>" + obj.text + "</div>");
                    obj.parent.append(tooltip);
                    var offsetTop = e.target.offsetTop - e.target.offsetHeight + offsetY;
                    var offsetLeft = e.target.offsetLeft + e.target.offsetWidth + offsetX;
                    tooltip.css('top', offsetTop);
                    tooltip.css('left', offsetLeft);
                }
            ).mouseout(
                function () {
                    $("#tooltip").remove();
                }
            );
        }
    },

    setWidthForPropertyPane: function (width) { //setPanelWidth
        var width = width || "23%";
        this.propertyPane.css('width', width);
    },

    setHeightForPropertyPane: function (height) { //setPanelWHeight
        var height = height || "30%";
        this.propertyPane.css('height', height);
    }

});


it.PropertyManager = function (sceneManager,mainParentDiv) {
    this.sceneManager = null;
    this.dataManager = null;
    this.mainParentDiv = mainParentDiv;
    //2Dparent,rootViewdialogrootViewstyle
    var parentDiv = mainParentDiv || (sceneManager != null && sceneManager.network3d !=null ? sceneManager.network3d.getRootView():null);
//    parentDiv.style.position = 'absolute'; // position
    this.propertyPane = new it.PropertyPane(parentDiv);
    this.setSceneManager(sceneManager);
    this.getContentFunction = null; // 
    this.nodeDefaultInfoFunction = null; // node
    this.mouseoverDevFunction = null; //
    this.devClickFunction = null; //camera
//    this.devHeaderFunction = null; //table[{text:'abc'}]
//    this.devColumnFunciton = null; //tableHeader
    this.devListSortFunction = null;//table

//    this.devTableRule['rack'] = [{header:'1',width:'6',property:fun,},{header:'2',..},..];
    this.devTableRule = {};
    this.dataInfoRule = {};
    this.statInfoRule = {};
    this.otherInfoRule = {}; //,,,{'rack':[tab1,tab2],'equipment':{tab1}}
    this.preExtInfoRule = {}; //,,,
    this.width,this.height;
    this.defaultShowIndexFunction = null;
};

mono.extend(it.PropertyManager, Object, {

    /**
     * 1
     * @param rackTypes
     */
    setDefaultRackRule : function(rackTypes){
        if(!rackTypes || rackTypes.length < 1) return;
        if(!(rackTypes instanceof Array)){
            rackTypes = [rackTypes];
        }
        var self = this;
        var dataInfo = [
            {label:'',property:function(data){
                return data.getId();
            }},
            {label:'Id',property:'userId'},//userMapfunction
            {label:'',property:''}
        ];
        var devTable = [
            {header: '', width: '5',
                property: function (childData) {
                    return childData.getId();
                }},
            {header: '', width: 3,
                property: function (childData) {
                    var dataType = self.dataManager.getDataTypeForData(childData);
                    if(dataType && dataType.getDescription()){
                        return dataType.getDescription();
                    }
                    if (dataType && dataType.getModel()) {
                        return dataType.getModel();
                    }
                }
            },
            {header: '', width: 4,
                property: function (childData) {
                    var location = '';
                    var dataType = self.dataManager.getDataTypeForData(childData);
                    var sizeU = 1;
                    if (dataType
                        && dataType.getSize()
                        && dataType.getSize().ySize) {
                        sizeU = dataType.getSize().ySize;
                    }
                    if (childData.getLocation()
                        && childData.getLocation().y) {
                        location = childData.getLocation().y + 'U-' + (childData.getLocation().y + sizeU) + 'U(' + sizeU + 'U)';
                    }
                    return location;
                }}
        ];
        var statInfo = {
            value : function(data){
                var spManager = new it.SpaceManager(self.dataManager,self.sceneManager);
                var spObj = spManager.computeSpace(data);
                if(spObj && spObj instanceof it.Space1){
                    var empty_space_list = [];//['1U-2U(2U)','3U-5U(3U)','10U-12U(2U)'];
                    if(spObj._emptyList && spObj._emptyList.length > 0){
                        for(var i = 0 ;i < spObj._emptyList.length ; i++){
                            var empObj = spObj._emptyList[i];
                            empty_space_list.push(empObj.start+'U-'+empObj.end+'U('+empObj.total+'U)');
                        }
                    }
                    var emp_obj = {};
                    emp_obj.U =  spObj._occupation + 'U';
                    emp_obj.U = (spObj._total - spObj._occupation) + 'U';
                    emp_obj. = empty_space_list;
                    return emp_obj;
                }
            }
        };

        for(var i = 0 ; i <rackTypes.length ; i++){
            var type = rackTypes[i];
            if(type){
                this.dataInfoRule[type] = dataInfo;
                this.devTableRule[type] = devTable;
                this.statInfoRule[type] = statInfo;
            }
        }
    },

    /**
     * 2
     * @param equipTypes
     */
    setDefaultEquipmentRule : function(equipTypes){
        if(!equipTypes || equipTypes.length < 1){
            return;
        }
        if(!(equipTypes instanceof Array)){
            equipTypes = [equipTypes];
        }
        var self = this;
        var infoRule = [
            {label:'',property:function(data){
                return data.getId();
            }},
            { label:'',property:function(data){
                var dataType = self.dataManager.getDataTypeForData(data);
                var sizeU = 1;
                if (dataType
                    && dataType.getSize()
                    && dataType.getSize().ySize) {
                    sizeU = dataType.getSize().ySize;
                }
                return sizeU;
            }
            },
            {label:'',property:''}
        ];
        for(var i = 0 ; i < equipTypes.length; i++){
            var type = equipTypes[i];
            if(type){
                this.dataInfoRule[type] = infoRule;
            }
        }
    },

    /**
     * true
     */
    isShow : function(dataOrId){
        return true;
    },

    show : function(dataOrId,showIndex){
        if(!this.isShow(dataOrId)){
            return ;
        }
        if(!dataOrId){
            return ;
        }
        var data = null,link = null,dataNode = null;
        if(dataOrId instanceof it.Data){
            data = dataOrId;
        }else if(dataOrId instanceof it.Link){
            dataNode = this.sceneManager.getLinkNodeById(dataOrId);
        }else{
            data = this.dataManager.getDataById(dataOrId);
        }
        if(!dataNode){
            dataNode = this.sceneManager.getNodeByDataOrId(data);
        }
        var contents = this.getContentByNode(dataNode);
        var title = this.getTitleByNode(dataOrId);
        var offset = this.getOffset(dataNode);
        this.propertyPane.show({items:contents},dataNode,title,offset,showIndex);
    },

    showTabByIndex : function(index){
        this.propertyPane.showTabByIndex(index);
    },

    getDefaultShowIndex: function(data,node,content){
        if(this.defaultShowIndexFunction){
            return this.defaultShowIndexFunction(data,node,content);
        }
    },

    setSceneManager : function(sceneManager){
        if(!sceneManager) {
            return;
        }
        this.sceneManager = sceneManager;
        this.dataManager = sceneManager.dataManager;
        var defaultEventHandler = this.defaultEventHandler = sceneManager.viewManager3d.getDefaultEventHandler();
        if(defaultEventHandler){
            var self = this;
            var defaultAfterLookAtFun = defaultEventHandler.afterLookAtFunction;
            defaultEventHandler.afterLookAtFunction = function(node,cNode){
                if (defaultAfterLookAtFun) {
                    defaultAfterLookAtFun(node,cNode);
                }
                var itData = null;
                if (node instanceof it.Data) {
                      itData = node;
                    node = self.sceneManager.getNodeByDataOrId(node);
                }else{
                      itData = self.sceneManager.getNodeData(node);
                }
                var data = self.getContentByNode(node);
                if(data && data.length > 0 && self.isShow(data)){
                    var title = self.getTitleByNode(node);
                    var offset = self.getOffset(node);
                    var index = self.getDefaultShowIndex(itData,node,{items:data});
                    self.propertyPane.show({items:data},node,title,offset,index);
                }else{
                    self.propertyPane.hide();
                }
            }
        }
        // 2DNetwork
        var eventHandel = new it.EventHandler();
        eventHandel.shouldHandleDoubleClickElement = function(){
            return true;
        };
        eventHandel.handleDoubleClickElement = function(node,network,data,element){
            var content = self.getContentByNode(node);
            if(content && content.length > 0){
                var title = self.getTitleByNode(data);
                var offset = self.getOffset(node);
                self.propertyPane.show({items:content},title,offset);
            }else{
                self.propertyPane.hide();
            }
        };
        this.sceneManager.addSceneChangeListener(function(e){
            self.propertyPane.hide(); // 
        });
        if (this.sceneManager.viewManager2d) {
            this.sceneManager.viewManager2d.addEventHandler(eventHandel);
        }
    },
    
    setPropertyPaneSize : function(width,height){
        this.width = width;
        this.height = height;
    },

    getContentByNode : function(node){
        if (this.getContentFunction) {
            var obj = this.getContentFunction(node);
            if (!(obj instanceof Array)) {
                return [obj];
            } else {
                return obj;
            }
        }
        // remark by Kevin 2016-11-24 networkrootView()
        if (!this.mainParentDiv) {
            var parentDiv = null;
            if (node instanceof twaver.Element) { //2Dnetwork
                parentDiv = this.sceneManager.network2d.getView();
            } else {
                parentDiv = this.sceneManager.network3d.getRootView();
            }
            if (parentDiv) {
                parentDiv.appendChild(this.propertyPane.propertyPane[0]);
            }
        }
        var link = this.sceneManager.getLinkData(node);
        if (link && (link instanceof it.Link)) {
            this.propertyPane.setWidthForPropertyPane('30%');
            return  this.createDefaultLinkContent(node);
        } else {
            if (this.width && parseInt(this.width)){
                this.propertyPane.setWidthForPropertyPane(parseInt(this.width) + 'px');
            }
            if (this.height &&parseInt(this.height)) {
                this.propertyPane.setHeightForPropertyPane(parseInt(this.height) + 'px');
            }
            // this.propertyPane.setWidthForPropertyPane();
            return this.createDefaultDataContent(node);
        }
    },

    /**
     * nodetitle
     * @param nodeOrData
     * @returns {string}
     */
    getTitleByNode : function(nodeOrData){
        var id = '';
        if(!nodeOrData){
            return '';
        }
        if(nodeOrData instanceof it.Data){
            id = ':' + nodeOrData.getId();
        }else if(this.sceneManager && this.sceneManager.getNodeData(nodeOrData)){
            id = ':' + this.sceneManager.getNodeData(nodeOrData).getId();
        }
        return '' + id;
    },

    getOffset:function(nodeOrData){
        return {left:100,top:100};
    },

    /**
     * 
     * 
     * tab1
     * tab2
     * tab3
     * @param node
     */
    createDefaultDataContent : function(node){
        var preExtInfo = this.getPreExtInfo(node);
        var generalInfo = this.getGeneralInfo(node);
        var devInfo = this.getDevListInfo(node);
        var statInfo = this.getStatInfo(node);
        var others = this.getOthers(node);
        var content = [];
        if (preExtInfo) {
            if(preExtInfo instanceof Array){
                for(var i = 0 ; i < preExtInfo.length ; i++){
                    content.push(preExtInfo[i]);
                }
            }else{
                content.push(preExtInfo);
            }
        }
        if(generalInfo){
            content.push(generalInfo);
        }
        if(devInfo){
            content.push(devInfo);
        }
        if(statInfo){
            content.push(statInfo);
        }
        if(others){
            if(others instanceof Array){
                for(var i = 0 ; i < others.length ; i++){
                    content.push(others[i]);
                }
            }else{
                content.push(others);
            }
        }
        return content;
    },

    /**
     * Link
     * @param linkOrId
     * @returns {null}
     */
    createDefaultLinkContent : function(linkOrId){
        var link = null;
        if(linkOrId instanceof it.Link){
            link = linkOrId;
        }else if(linkOrId instanceof mono.Element){
            link = this.sceneManager.getLinkData(linkOrId);
        }else{
            link = this.dataManager.getLinkById(linkOrId);
        }
        if(!link){
            return null;
        }
        var fromId = link.getFromId(),toId = link.getToId();
        var fromDataType = this.dataManager.getDataTypeForData(fromId);
        var toDataType = this.dataManager.getDataTypeForData(toId);
        var fTypeDesc = fromDataType?fromDataType.getDescription():'';
        var tTypeDesc = toDataType?toDataType.getDescription():'';
        var content = {};
        content. = link.getName();
        content. = link.getType();
        content.A = fromId || '';
        content.A = link.getFromPortId();
        content.B = toId || '';
        content.B = link.getToPortId();
        content.1 = ":"+(fromId || '')+"  :"+fTypeDesc + ' :' + link.getFromPortId();
        content.2 = ":"+(toId || '')+"  :"+tTypeDesc + ' :' + link.getToPortId();
        var baseInfo = {title: '',
            properties: content,
            className:'it-property-basic',
            onclick: function (e) {
            }
        };

        var labelInfo = {
            title:'',
            properties:null,
            className:'it-property-equip',
        }
        return [baseInfo,labelInfo];
    },

    /**
     * rule
     * @param node
     * @returns {*}
     */
    getGeneralInfo: function(node) {
        if (!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        // if (!data) return null;
        var content = null;
        var dataType = this.dataManager.getDataTypeForData(data);
        if (dataType && dataType.getCategoryId()) {
            var ruleInfo = this.dataInfoRule[dataType.getCategoryId()]; //dataType.getModel() dataType.getId()
            if (ruleInfo && ruleInfo.length > 0) {
                for (var i = 0; i < ruleInfo.length; i++) {
                    var rule = ruleInfo[i];
                    if (rule) {
                        var label = rule.label;
                        var value = '';
                        if (rule.property) {
                            if (typeof(rule.property) == 'function') {
                                value = rule.property(data);
                            } else {
                                value = data.getUserData(rule.property);
                            }
                        }
                        var isButton = false;
                        if (rule.isButton) {
                            if (typeof(rule.isButton) == 'function') {
                                isButton = rule.isButton(data);
                            }else{
                                isButton = rule.isButton;
                            }
                        }
                        var style = '';
                        if (rule.style) {
                            if (typeof(rule.style) == 'function') {
                                style = rule.style(data);
                            }else{
                                style = rule.style;
                            }
                        }
                        var classname = rule.classname;
                        var onclick = rule.onclick;
                        if (!content) {
                            content = {};
                        }
                        // content[label] = value || '';
                         content[label] = {value:value||'',isButton:isButton,style:style,onclick:onclick,classname:classname,origin:rule.origin}; //update 2016-12-29 
                    }
                }
            }
        }
        if (!content && this.nodeDefaultInfoFunction && this.nodeDefaultInfoFunction(node)) {
            content = this.nodeDefaultInfoFunction(node);
        }
        if (!content) {
            return null;
        }
        var obj = {
            title: '',
            properties: content,
            className: 'it-property-basic',
            onclick: function(e) {}
        };
        return obj;
    },

    /**
     * 
     * 1
     * 2
     * 3
     * @param node
     * @returns {null}
     */
    getDevListInfo : function(node){
        if(!node || !this.dataManager) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(!data) return null;
        var children = data.getChildren();//this.dataManager.getChildren(data);
        var devList = [];
        var dataType = this.dataManager.getDataTypeForData(data);
        if(!dataType || !dataType.getCategoryId()) return null;
        var ruleInfo = this.devTableRule[dataType.getCategoryId()]; //dataType.getModel() dataType.getId()
        if(!ruleInfo) return null;
        devList.title = this.createTableHeaderByRuleInfo(ruleInfo);
        if(children && children.size() > 0){
            var self = this;
            children.forEach(function(child){
                if(!child) return;
                var conlumns = self.createTableRowByRuleInfo(ruleInfo,child);
                var devInfo = {
                    values:conlumns, //
                    callback:function(){
                        if(self.devClickFunction){
                            return self.devClickFunction(child);
                        }
                        if(self.defaultEventHandler && self.sceneManager){
                            var childNode = self.sceneManager.dataNodeMap[child.getId()];
                            if(childNode){
                                self.defaultEventHandler.lookAt(childNode);
                            }
                        }
                    },
                    mousemove:function(){
                        if(self.mouseoverDevFunction){
                            self.mouseoverDevFunction(child);
                        }
                    }
                };
                devList.push(devInfo);
            });
        }
        if(this.devListSortFunction){
            var self = this;
            devList.sort(function(a,b){
                return self.devListSortFunction(a,b);
            });
        }
        var obj = {
            title: '',
            properties:devList,
            className:'it-property-equip'
        };
        return obj;
    },


    /**
     * 
     * c_width12
     * @param node
     * @returns {{c_width: number, text: string}[]}
     */
    createTableHeaderByRuleInfo : function(ruleInfo){
        var heads = [];
        if(ruleInfo && ruleInfo instanceof Array){
            for(var i = 0 ; i< ruleInfo.length ; i++){
                var columnInfo = ruleInfo[i];
                if(columnInfo){
                    var obj = {};
                    if(columnInfo.width){
                        obj.c_width = columnInfo.width;
                    }
                    if(columnInfo.header){
                        obj.text = columnInfo.header;
                    }
                    heads.push(obj);
                }
            }
        }
        return heads;
//        return [{c_width:6,text:''},{c_width:3,text:''},{c_width:3,text:''}];
    },

    /**
     * childData
     * @param childData
     * @returns {*}
     */
    createTableRowByRuleInfo : function(ruleInfo,childData){
        if(!childData) return null;

        var columns = [];
        if(ruleInfo && ruleInfo instanceof Array){
            for(var i = 0 ; i < ruleInfo.length ; i++){
                var columnInfo = ruleInfo[i];
                if(columnInfo){
                    var col = {};
                    if(columnInfo.width){
                        col.c_width = columnInfo.width;
                    }
                    if(columnInfo.property){
                        if(typeof(columnInfo.property) == 'function'){
                            col.text = columnInfo.property(childData);
                        }
                    }
                    columns.push(col);
                }
            }
        }
        return columns;
    },

    /**
     * 
     * @param node
     */
    getStatInfo : function(node){
        if(!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(!data) return null;
        var dataType = this.dataManager.getDataTypeForData(data);
        if(!dataType || !dataType.getCategoryId()) return null;
        var ruleInfo = this.statInfoRule[dataType.getCategoryId()]; //dataType.getId() dataType.getModel()
        var emp_obj = null;
        if(ruleInfo && ruleInfo.value){
            if(typeof(ruleInfo.value) == 'function'){
                 emp_obj = ruleInfo.value(data);
            }else{
                emp_obj = ruleInfo.value;
            }
        }
        if(emp_obj){
            var obj = {
                title: '',
                properties: emp_obj,
                isGrop: false,
                className: 'it-property-chart'
            };
            return obj;
        }
    },

    getPreExtInfo : function(node){
        // if(this.getPreExtInfoFunction){ //addtab
        //     var preExtInfoResult = this.getPreExtInfoFunction(node);
        //     if (preExtInfoResult != undefined) {
        //         return preExtInfoResult;
        //     }
        // }
        if(!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(!data) return null;
        var result = [];
        var dataType = this.dataManager.getDataTypeForData(data);
        if(dataType && dataType.getCategoryId()) {
            var preExtInfoRule = this.preExtInfoRule[dataType.getCategoryId()];
            if (preExtInfoRule) {
                if (preExtInfoRule instanceof Array) {
                    result = preExtInfoRule;
                }else{
                    result.push(preExtInfoRule);
                }
            }
        }
        if(this.getPreExtInfoFunction){ //addtab
            var preExtInfoResult = this.getPreExtInfoFunction(node);
            if (preExtInfoResult) {
                if (preExtInfoResult instanceof Array) {
                    for (var i = 0; i < preExtInfoResult.length; i++) {
                        result.push(preExtInfoResult[i]);
                    }
                }else{
                    result.push(preExtInfoResult);
                }
            }
        }
        return result;
    },

    /**
     * 
     * @param node
     */
    getOthers: function(node) {
        if (!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if (!data) return null;
        var result = [];
        var dataType = this.dataManager.getDataTypeForData(data);
        if (dataType && dataType.getCategoryId()) {
            var otherInfoRule = this.otherInfoRule[dataType.getCategoryId()];
            if (otherInfoRule) {
                if (otherInfoRule instanceof Array) {
                    result = otherInfoRule;
                } else {
                    result.push(otherInfoRule);
                }
            }
        }
        if (this.getExtInfoFunction) { // addtab
            var extInfoResult = this.getExtInfoFunction(node);
            if (extInfoResult) {
                if (extInfoResult instanceof Array) {
                    for (var i = 0; i < extInfoResult.length; i++) {
                        result.push(extInfoResult[i]);
                    }
                } else {
                    result.push(extInfoResult);
                }
            }
        }
        return result;
    }


});

//it.Size 
// xSize U
var $Size = function (parameters) {
   parameters = parameters || {};
   this.xSize = parameters.x ;
   this.ySize = parameters.y ;
   this.zSize = parameters.z ;

   this.xPadding = parameters.xPadding || [0,0];
   this.yPadding = parameters.yPadding || [0,0];
   this.zPadding = parameters.zPadding || [0,0];

   this.xGap = 0;
   this.yGap = 0;
   this.zGap = 0;
};
mono.extend($Size,Object,{
    __accessor : ['xSize','ySize','zSize','xPadding','yPadding','zPadding'],
     
    parse : function(){ //
       
    }, 
});

it.Size =  $Size;
// 
// x,y,z 3 
// x,y,z y  U
// x,z   it.Location.Align;
var $Location = function (parameters) {
  this.parse(parameters);

};
it.Location = $Location;

var $Align = it.Location.Align = {};
$Align.pos_neg = -1;
$Align.center_neg = -2;
$Align.neg_neg = -3;
$Align.center = -4;
$Align.pos_pos = -5;
$Align.center_pos = -6;
$Align.neg_pos = -7;

mono.extend($Location,Object,{

    set : function(key,value){
        var result = value;
        if(typeof value === "string"){// pos_neg 
            result = it.Location.Align[value];
            if(!result){
                result = value;
            }
        }
        this[key] = result;
    },

	setX: function(x){
        this.set('x',x);
	},

	setY : function(y){
       this.set('y',y);
	},

	setZ : function(z){
       this.set('z',z);
	},

  getX : function () {
    return this.x;
  },

  getY : function () {
    return this.y;
  },

  getZ : function () {
    return this.z;
  },

  parse : function(parameters){
    if(!parameters){
      return;
    }
    // if(parameters instanceof it.Location){
    //     this.x = parameters.x;
    //     this.y = parameters.y;
    //     this.z = parameters.z;
    //     return;
    // }
    if(it.defaultLocatonParser){
       var loc = it.defaultLocatonParser.parse(parameters);
       if(loc == null || !(loc instanceof it.Location)){
          throw 'it.defaultLocatonParser.parse() does not return a it.Location';
       }else{
          this.location = loc;
       }
       this.x = loc.x;
       this.y = loc.y;
       this.z = loc.z;
    }else{
       throw 'it.defaultLocatonParser is null'; 
    }
  },

});
$Location.getAlignName  = function(value){
   for(var name in $Align){
       if($Align[name] === value){
          return name;
       }
   }
};
//  Location
it.LocationParser = function () {
};

mono.extend(it.LocationParser,Object,{
    parse : function(source){ // parse source(maybe json,maybe text) to it.Location
      return null;
    },
});

it.DefaultLocatonParser = function(){
   it.LocationParser.call(this);
};

mono.extend(it.DefaultLocatonParser,it.LocationParser,{
   parse : function(source){
   	  var l = new it.Location();
      if(source instanceof it.Location){
          l.x = source.x;
          l.y = source.y;
          l.z = source.z;
      }else if(source.x !== undefined || source.y !== undefined || source.z !== undefined){
         l.setX(source.x);
         l.setY(source.y);
         l.setZ(source.z);
      }else if(typeof source ==='string'){
        l = this.parseText(source);
      }
      return l;
   },

   parseText : function(source){
       var source = JSON.parse(source);
       if(!source) return null;
       if(source.x !== undefined || source.y !== undefined || source.z !== undefined){
           var l = new it.Location();
           l.setX(source.x);
           l.setY(source.y);
           l.setZ(source.z);
           return l;
       }
       return null;
   },

   charToNum : function(c){ // a == 1,A === 1
	    if(c && c.toUpperCase && c.length){
	    	c = c.toUpperCase();
	    	return c.chartCodeAt(0) - 96;
	    }
	},
});

it.defaultLocatonParser = new it.DefaultLocatonParser;
var $LocationManager = function (sceneManager) {
    this.sceneManager = sceneManager;
    this.dataManager = sceneManager.dataManager;
    this._positionFunctionMap = {};
    this._rotationFunctionMap = {};
};

mono.extend($LocationManager,Object,{

     registerPositionFunction : function(categoryId,pCategoryId,func){
        var key = pCategoryId + "&" + categoryId;
        this._positionFunctionMap[key] = func;
     },

     registerRotationFunction : function(categoryId,pCategoryId,func){
        var key = pCategoryId + "&" + categoryId;
        this._rotationFunctionMap[key] = func;
     },

     /**
      *  dataNodepbb
      */
     _computePosition : function(data,parentData,node,parentNode,pbb){
         var dm = this.dataManager;
         // var category = dm.getCategoryForData(data);
         // var pCategory = dm.getCategoryForData(parentData);
         // var categoryId = category ? category.getId() : "";
         // var pCategoryId = pCategory ? pCategory.getId() : "";
         // var map = this._positionFunctionMap;
          var location = data.getLocation();
             var dataType = dm.getDataTypeForData(data);
             var parentDataType = dm.getDataTypeForData(parentData);
             var parentCategory = this.dataManager.getCategoryForDataType(parentDataType);
             var size = dataType.getSize();
             var pSize = parentDataType.getChildrenSize() || new it.Size();
             var bb = node.getBoundingBox();
             if (!bb.size() || (!bb.size().x && !bb.size().y && !bb.size().z)) {
                bb = it.Util.getBoundingBox(node);
             }
             var pbb = pbb || parentNode.getBoundingBox();
             var positionExp = dataType.getPositionExp()||{};
             var x = location.getX();
             var y = location.getY();
             var z = location.getZ();
                 var datas = {x:x,y:y,z:z,dataType:dataType,
                     parentDataType:parentDataType,
                     parentCategory : parentCategory,
                     data:data,parentData:parentData,
                     bb:bb,pbb:pbb};
                 if(positionExp.x){
//                 x = eval(positionExp.x);
                     var fun = new Function("x","y","z","data","return " + positionExp.x);
                     x = fun.call(this,x,y,z,datas)||x;
                 }
                 if(positionExp.z){
//                 z = eval(positionExp.z);
                     var fun = new Function("x","y","z","data","return " + positionExp.z);
                     z = fun.call(this,x,y,z,datas)||z;
                 }
                 if(positionExp.y){
//                 y = eval(positionExp.y);
                     var fun = new Function("x","y","z","data","return " + positionExp.y);
                     y = fun.call(this,x,y,z,datas)||y;
                 }

             var px = this._computeOneAxisPosition('x',x,size.getXSize(),pSize.getXSize(),pSize.getXPadding(),bb,pbb) || data.getPosition().x;
             var pz = this._computeOneAxisPosition('z',z,size.getZSize(),pSize.getZSize(),pSize.getZPadding(),bb,pbb) || data.getPosition().z;

             var locationY = location.getY();
             var floor = null;
             if(this._isAlignment(locationY)){
                 floor = this._findFloor(parentNode);
                 pbb = floor.getBoundingBox();
             }
             var py = this._computeOneAxisPosition('y',y,size.getYSize(),pSize.getYSize(),pSize.getYPadding(),bb,pbb) || data.getPosition().y;

            //  U 2018.2.27 add by lyz 
            var modelParameters = parentDataType.getModelParameters();
            if( modelParameters&&modelParameters.uOrder == 'upToDown'){
               py = -1*py;
            }
            
             var position = new mono.Vec3(px,py,pz);
             node.p(position);
     },

     /**
      * nodebillboardboundingBox
     **/
     computePosition : function(data,parentData,node,parentNode){
         var dm = this.dataManager;
         var category = dm.getCategoryForData(data);
         var pCategory = dm.getCategoryForData(parentData);
         var categoryId = category ? category.getId() : "";
         var pCategoryId = pCategory ? pCategory.getId() : "";
         var map = this._positionFunctionMap;
         var self = this;
         var func = map[pCategoryId + "&" + categoryId];
         if(func){
            var flag =  func(data,parentData,node,parentNode);
            if(flag !== false){
               return;
            }
         }       
         if(!parentData){
            node.p(data.getPosition());
            return;
         }
         var location = data.getLocation();
         if(!location){
            node.p(data.getPosition());
            return;
         }
         if(node instanceof mono.Billboard){
            node.p(data.getPosition());
            return;
         }
         if (!parentNode) {
            node.p(data.getPosition());
            return;
         }
         if (parentNode) {
            //node,complexParentNodeunload
             var complexParentNode = parentNode.getClient('complexNode'); 
             if (complexParentNode) {
                if (complexParentNode == 'unload') {
                    this.sceneManager.loadComplexNode(parentData,function(comNode){
                        var pbb = comNode.getBoundingBox();
                        if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                            pbb = it.Util.getBoundingBox(comNode);
                        }
                        self._computePosition(data,parentData,node,parentNode,pbb);
                    });
                }else {
                    pbb = complexParentNode.getBoundingBox();
                    if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                       pbb = it.Util.getBoundingBox(complexParentNode);
                    }
                    self._computePosition(data,parentData,node,parentNode,pbb);
                }
             }else{
                var  pbb = parentNode.getBoundingBox();
                if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                   pbb = it.Util.getBoundingBox(parentNode);
                }
                self._computePosition(data,parentData,node,parentNode,pbb);
             }
         }
         /*
         if(parentNode){ // 2D  3D parentNodenull
             var dataType = dm.getDataTypeForData(data);
             var parentDataType = dm.getDataTypeForData(parentData);
             var parentCategory = this.dataManager.getCategoryForDataType(parentDataType);
             var size = dataType.getSize();
             var pSize = parentDataType.getChildrenSize() || new it.Size();
             var bb = node.getBoundingBox();
             if (!bb.size() || (!bb.size().x && !bb.size().y && !bb.size().z)) {
                bb = it.Util.getBoundingBox(node);
             }
             var pbb = parentNode.getBoundingBox();
             if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                pbb = it.Util.getBoundingBox(parentNode);
             }
             var positionExp = dataType.getPositionExp()||{};
             var x = location.getX();
             var y = location.getY();
             var z = location.getZ();
                 var datas = {x:x,y:y,z:z,dataType:dataType,
                     parentDataType:parentDataType,
                     parentCategory : parentCategory,
                     data:data,parentData:parentData,
                     bb:bb,pbb:pbb};
                 if(positionExp.x){
//                 x = eval(positionExp.x);
                     var fun = new Function("x","y","z","data","return " + positionExp.x);
                     x = fun.call(this,x,y,z,datas)||x;
                 }
                 if(positionExp.z){
//                 z = eval(positionExp.z);
                     var fun = new Function("x","y","z","data","return " + positionExp.z);
                     z = fun.call(this,x,y,z,datas)||z;
                 }
                 if(positionExp.y){
//                 y = eval(positionExp.y);
                     var fun = new Function("x","y","z","data","return " + positionExp.y);
                     y = fun.call(this,x,y,z,datas)||y;
                 }

             var px = this._computeOneAxisPosition('x',x,size.getXSize(),pSize.getXSize(),pSize.getXPadding(),bb,pbb) || data.getPosition().x;
             var pz = this._computeOneAxisPosition('z',z,size.getZSize(),pSize.getZSize(),pSize.getZPadding(),bb,pbb) || data.getPosition().z;

             var locationY = location.getY();
             var floor = null;
             if(this._isAlignment(locationY)){
                 floor = this._findFloor(parentNode);
                 pbb = floor.getBoundingBox();
             }
             var py = this._computeOneAxisPosition('y',y,size.getYSize(),pSize.getYSize(),pSize.getYPadding(),bb,pbb) || data.getPosition().y;
             var position = new mono.Vec3(px,py,pz);
             node.p(position);
        }
        */
     },

     _findFloor : function (node) { //TODO 
        return node;
     },

     _computeOneAxisPosition : function(axis,locationAxis,sizeAxis,pSizeAxis,paddingAxis,bb,pbb){
         locationAxis = parseFloat(locationAxis);
         if(Number.isNaN(locationAxis)){
            return null;
         }
         if(pSizeAxis && !this._isAlignment(locationAxis)){
            paddingAxis = paddingAxis || [0,0];
            var totolLength = pbb.max[axis] - pbb.min[axis] - parseFloat(paddingAxis[0]) - parseFloat(paddingAxis[1]);
            var unit = totolLength / pSizeAxis;
            return pbb.min[axis] - bb.min[axis] + unit * (locationAxis - 1) + parseFloat(paddingAxis[0]);// TODO 
         }else {
            if(this._isAlignment(locationAxis)){
               return this._getAlignPosition(bb,pbb,locationAxis,paddingAxis,axis);
            }
         }
     },

     _isAlignment : function (locationAxis) {
         return !!it.Location.getAlignName(locationAxis);
     },

     _getAlignPosition : function(bb,pbb,align,paddingAxis,axis){
        if(align === $Align.pos_neg){
          return pbb.min[axis] - bb.max[axis] + paddingAxis[0];
        }else if(align === $Align.center_neg){
          return pbb.min[axis];
        }else if(align === $Align.neg_neg){
          return pbb.min[axis] - bb.min[axis] + paddingAxis[0];
        }else if(align === $Align.center){
          return pbb.center()[axis];
        }else if(align === $Align.pos_pos){
          return pbb.max[axis] - bb.max[axis] - paddingAxis[1];
        }else if(align === $Align.center_pos){
          return pbb.max[axis];
        }else if(align === $Align.neg_pos){
          return pbb.max[axis] - bb.min[axis] - paddingAxis[1];
        }
     },

    isNull : function(value){
        if(value==undefined){
            return true;
        }
        if(typeof(value) == 'string' && value.trim() == ""){
            return true;
        }
        return false;
    },

    /**
     * 
     * sdk
     * @param rotation
     */
    translateRotation : function(rotation){
        if(!rotation){
            return rotation;
        }
        var rot = new mono.Vec3();
        if(rotation.x){
            rot.setX(Math.PI*rotation.x/180);
        }else{
            rot.setX(rotation.x);
        }
        if(rotation.y){
            rot.setY(Math.PI*rotation.y/180);
        }else{
            rot.setY(rotation.y);
        }
        if(rotation.z){
            rot.setZ(Math.PI*rotation.z/180);
        }else{
            rot.setZ(rotation.z);
        }
        return rot;
    },

     computeRotation : function(data,parentData,node,parentNode){
         var dm = this.dataManager;
         var location = data.getLocation();
         var dataType = dm.getDataTypeForData(data);
         var rotationExp = dataType.getRotationExp();
         var rotation = this.translateRotation(data.getRotation());
         node.setRotation(new mono.Vec3());  // add By Kevin 2017-07-11
         if(rotation && (!this.isNull(rotation.x)
             || !this.isNull(rotation.y)
             || !this.isNull(rotation.z))){
             node.setRotation(rotation);
             return;
         }
         if(!location || !rotationExp){
             return ;
         }
         var x = location.getX(),y = location.getY(),z = location.getZ();
         var scriptData = {x : x ,y : y ,z : z,data:data,dataType:dataType,parentData:parentData,location:location};
         var position = data.getPosition();
         var px = position.x,py = position.y,pz = position.z;
         var rx ,ry ,rz ;
         if(rotationExp.x){
//           rx = eval('witch'rotationExp.x);
             var func = new Function("x","y","z","data","return " + rotationExp.x);
             rx = func.call(this,x,y,z,scriptData)||0;
         }

         if(rotationExp.y){
//            ry = eval(rotationExp.y);
             var func = new Function("x","y","z","data","return " + rotationExp.y);
             ry = func.call(this,x,y,z,scriptData)||0;
         }
         if(rotationExp.z){
//            rz = eval(rotationExp.z);
             var func = new Function("x","y","z","data","return " + rotationExp.z);
             rz = func.call(this,x,y,z,scriptData)||0;
         }
         // node.setRotation(rx,ry,rz);
         if (rx != undefined && rx != null) {
            node.setRotationX(rx);
         }
         if (ry != undefined && ry != null) {
            node.setRotationY(ry);
         }
         if (rz != undefined && rz != null) {
            node.setRotationZ(rz);
         }
     },
});

it.LocationManager = $LocationManager;
it.Space1 = function (spaceArray,axis) {
   this._spaceArray = spaceArray || [];
   this._axis = axis;
   this.init();
   this.compute();
};

mono.extend(it.Space1,Object,{
	setSpaceArray : function(spaceArray){
		this._spaceArray = spaceArray;
		this.init();
		this.compute();
	},
    getSpaceArray : function(){
       return this._spaceArray;
    },

    getTotal : function(){
    	return this._total;
    },

    getPercent : function(){
    	return this._percent;
    },

    getOccupation : function(){
    	return this._occupation;
    },

    getOccupationList : function(){
    	return this._occupationList;
    },

    getEmptyList : function(){
    	return this._emptyList;
    },

    getAxis : function(){
    	return this._axis;
    },

    isAvailableAt : function(location,size){
       if(location < 1 && location > this._total){
         return false;
       }
       size = size || 1;
       var start = location,end = location + size - 1;
       if(end  > this._total){
         return false;
       }
       
       var i = 0,len = this._occupationList.length,occupation;
       for(;i < len;i ++){
           occupation = this._occupationList[i];
           if( (start >= occupation.start && start <= occupation.end) || (end >= occupation.start && end <= occupation.end) ){
             return false;
           }
       }
       return true;
    },

    isValid : function(){
    	return this._total > 0;
    },

    _addStatistic : function(unit,statistic,end){
       if(unit === 1 || unit === 0){
            statistic.end = end;
            if(statistic.occupation){
    	 	this._occupationList.push(statistic);
    	 	}else{
    	 		this._emptyList.push(statistic);
    	 	}
    	 	statistic.total = statistic.end - statistic.start + 1;
    	 	delete statistic.occupation;
        }
    },

    getCountForSize : function(size){
        var count = 0;
        for(var i = 0;i < this._emptyList.length;i ++){
        	var statistic = this._emptyList[i];
        	count += parseInt(statistic.total / size);
        }
        return count;
    },

    init : function(){
       this._total = 0;
	   this._percent = 0;
	   this._occupation = 0;
	   this._occupationList = [];
	   this._emptyList = [];
    },

    compute : function(){
    	var spaceArray = this._spaceArray,len = spaceArray.length,lastUnit = null,statistic;
    	this._total = len;
        for(var i = 0;i < len;i ++){
            var unit = spaceArray[i];
            if(unit == 1){
               this._occupation ++;
            }
            if(i == 0 || lastUnit != unit){
            	 this._addStatistic(lastUnit,statistic,i);
            	 statistic = {start : i + 1,occupation : unit};
            }
            lastUnit = unit;
            if(i == len - 1){
         	   this._addStatistic(lastUnit,statistic,i + 1);  
            }
        }
        if(this._total > 0){
        	this._percent = this._occupation / this._total;
        }
    },
})
it.Space2 = function (spaceArray,axis,mainAxis) {
	this._spaceArray = spaceArray || [[]]; // spaceArray it.Space1
	this._axis = axis;
	this._mainAxis = mainAxis;

    this.init();
    this.compute();
};

mono.extend(it.Space2,Object,{
    setSpaceArray : function(spaceArray){
		this._spaceArray = spaceArray;
		this.init();
		this.compute();
	},
    getSpaceArray : function(){
       return this._spaceArray;
    },

    getAxis : function(){
    	return this._axis;
    },

    getMainAxis : function(){
    	return this._mainAxis;
    },

    init : function(){
       this._total = 0;
	   this._percent = 0;
	   this._occupation = 0;
	   // this._occupationList = []; 
	   // this._emptyList = [];
    },

    compute : function(){
    	var i = 0,len = this._spaceArray.length,space1;
    	for(;i < len;i ++){
           space1 = this._spaceArray[i];
           this._total += space1.getTotal();
           this._occupation += space1.getOccupation();
    	}

    	if(this._total > 0){
    		this._percent = this._occupation / this._total;
    	}
    },

    getCountForSize : function(size){
        var i = 0,len = this._spaceArray.length,space1,count = 0;
        for(;i < len;i ++){
            space1 = this._spaceArray[i];
        	count += space1.getCountForSize(size);
        }
        return count;
    },
});

// 
var $SpaceManager = function (dataManager, sceneManager) {
    this.dataManager = dataManager;
    this.sceneManager = sceneManager;
    this.nodeMap = {};
    this.spaceNodeColorFunction = null;
    this.spaceNodeFrameColorFunction = null;
    this.spaceVisibleFilter = new it.SpaceVisibleFilter(sceneManager, this); //alarmBillboard
    this.spaceMaterialFilter = new it.SpaceMaterialFilter(sceneManager, this);
    this.spaceAdapter = new $SpaceAdapter(sceneManager, this);
};

mono.extend($SpaceManager, Object, {
    _initArray: function (length, initValue) {
        initValue = initValue || 0;
        var array = [];
        for (var i = 0; i < length; i++) {
            array.push(initValue);
        }
        return array;
    },
    _initArray2: function (length, length2, initValue) {
        initValue = initValue || 0;
        var array = [];
        for (var i = 0; i < length; i++) {
            var subArray = [];
            for (var j = 0; j < length2; j++) {
                subArray.push(0);
            }
            array.push(subArray);
        }
        return array;
    },

    initSpaceArray: function (xSize, ySize, zSize) {

    },

    computeSpace: function (data, mainAxis) {
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        var size = dataType.getChildrenSize();
        var children = data.getChildren(), child;//dm.getChildren(data),child;

        var xSize = size.getXSize();
        var ySize = size.getYSize();
        var zSize = size.getZSize();

        var dimension = 0, sizeArray = [], axis = "", notMainAxis = "";
        if (xSize) {
            dimension++;
            sizeArray.push({ axis: "x", size: xSize });
            axis += "x";
            if (axis !== mainAxis) {
                notMainAxis = "x";
            }
        }
        if (ySize) {
            dimension++;
            sizeArray.push({ axis: "y", size: ySize });
            axis += "y";
            if (axis !== mainAxis) {
                notMainAxis = "y";
            }
        }
        if (zSize) {
            dimension++;
            axis += "z";
            sizeArray.push({ axis: "z", size: zSize });
            if (axis !== mainAxis) {
                notMainAxis = "z";
            }
        }
        if (dimension > 2) {
            console.error("Only support 1 or 2 dimension");
            return;
        } else if (dimension == 2 && !mainAxis) {
            console.error("Main Axis is needed for 2 dimension");
            return;
        }
        var spaceArray = null;
        if (dimension == 1) {
            spaceArray = this._initArray(sizeArray[0].size);
            for (var i = 0; i < children.size(); i++) {
                var child = children.get(i);
                var childType = dm.getDataTypeForData(child);
                var childSize = childType.getSize();
                var locaton = child.getLocation();
                this.computeOneDimesion(spaceArray, childSize['get' + axis.toUpperCase() + 'Size'](), locaton['get' + axis.toUpperCase()]());
            }
            var space = new it.Space1(spaceArray, axis);
            return space
        }
        if (dimension == 2) {
            var notMainAxisSize = size['get' + notMainAxis.toUpperCase() + 'Size']();
            var mainAxisSize = size['get' + mainAxis.toUpperCase() + 'Size']();
            var space1Array = [];
            for (var k = 0; k < notMainAxisSize; k++) {
                var spaceArray = this._initArray(mainAxisSize);
                for (var i = 0; i < children.size(); i++) {
                    var child = children.get(i);
                    var childType = dm.getDataTypeForData(child);
                    var childSize = childType.getSize();
                    var locaton = child.getLocation();
                    if (locaton['get' + notMainAxis.toUpperCase()]() == k + 1) {
                        this.computeOneDimesion(spaceArray, childSize['get' + mainAxis.toUpperCase() + 'Size'](), locaton['get' + mainAxis.toUpperCase()]());
                    }
                }
                var space1 = new it.Space1(spaceArray, mainAxis);
                space1Array.push(space1);
            }
            var space2 = new it.Space2(space1Array, axis, mainAxis);
            return space2;
        }
        return null;
    },

    computeOneDimesion: function (spaceArrayAxis, childSizeAxis, locatonAxis) {
        if (childSizeAxis == null || childSizeAxis == undefined) {
            childSizeAxis = 1;
        }
        if (!spaceArrayAxis || !childSizeAxis || !(locatonAxis > 0)) {
            return;
        }
        for (var i = 0; i < childSizeAxis; i++) {
            spaceArrayAxis[locatonAxis - 1 + i] = 1;
        }
        return spaceArrayAxis;
    },

    getSpaceNodeColor: function (percent, data, space) {
        if (this.spaceNodeColorFunction) {
            var color = this.spaceNodeColorFunction(percent, data, space);

            return color;
        }
        var color = null;
        if (percent <= 0.25) { // TODO

        }
        color = 'orange';
        return color;
    },

    getSpaceNodeFrameColor: function (percent, data, space) {
        if (this.spaceNodeFrameColorFunction) {
            var color = this.spaceNodeFrameColorFunction(percent, data, space);
            return color;
        } else {
            return this.getSpaceNodeColor(percent, data, space);
        }
    },

    showSpaceMode: function () {
        this.sceneManager.viewManager3d.addVisibleFilter(this.spaceVisibleFilter);
        this.sceneManager.viewManager3d.addMaterialFilter(this.spaceMaterialFilter);
        this.sceneManager.adapterManager.register(this.spaceAdapter);
    },

    hideSpaceMode: function () {
        this.sceneManager.viewManager3d.removeVisibleFilter(this.spaceVisibleFilter);
        this.sceneManager.viewManager3d.removeMaterialFilter(this.spaceMaterialFilter);
        this.sceneManager.adapterManager.deregister(this.spaceAdapter);

    },

    getModelParent: function (node) {
        if (node == null) {
            return null;
        }
        var parent = node.getClient('modelParent');
        if (parent == null) {
            return this.getModelParent(node.getParent());
        }
        return parent;
    },

    remove1DSpaceNodeForNodes: function (nodes) {
        if (nodes instanceof mono.List) {
            nodes = nodes.toArray();
        }
        var box = this.sceneManager.network3d.getDataBox();
        var i = 0, j = 0, node, child;
        for (; i < nodes.length; i++) {
            node = nodes[i];
            var spaceNode = null;
            var children = node.getChildren().toArray();
            for (j = 0; j < children.length; j++) {
                child = children[j];
                if (this.isSpaceNode(child) || this.isSpaceChildrenNode(child)) {
                    box.removeByDescendant(child);
                    child.setParent(null);
                    if (this.isSpaceNode(child)) {
                        spaceNode = child;
                    }
                }
            }
            if (spaceNode) {
                var removedNode = spaceNode.getClient("modelRemovedNode");
                if (removedNode) {
                    //focusnode
                    // setParent
                    // removedNode.setParent(node); 
                    // if (box.getDataById(node.getId())) {
                    //     box.addByDescendant(removedNode);
                    // }
                    var complexNode = node.getClient('complexNode');
                    var simpleNode = node.getClient('simpleNode');
                    if (complexNode != 'unload'
                        && complexNode && node.getChildren().contains(complexNode)) { //
                        // 
                        var children = node.getChildren();
                        for (var k = 0; k < children.size(); k++) {
                            var child = children.get(k);
                            if (this.isSpaceChildrenNode(child)) {
                                child.setParent(null);
                                box.removeByDescendant(child);
                            }
                        }
                    } else { //
                        removedNode.setParent(node);
                        if (box.getDataById(node.getId())) {
                            box.addByDescendant(removedNode);
                        }
                    }
                }
            }
        }
    },

    create1DSpaceNodeForNodes: function (nodes, mode) {
        // this.nodeMap = {};
        mode = mode || 1;
        if (nodes instanceof mono.List) {
            nodes = nodes.toArray();
        }
        var box = this.sceneManager.network3d.getDataBox();
        box.startBatch();
        var focusNode = this.sceneManager.viewManager3d._focusNode;
        var i = 0, j = 0, node, data, spaceNode, spaceChildrenNodes, spaceChildNode;
        for (; i < nodes.length; i++) {
            node = nodes[i];
            /**
             * 
             * Author: alex
             */
            if (node === focusNode) continue;
            // SpaceNode
            var children = node.getChildren().toArray();
            for (j = 0; j < children.length; j++) {
                var child = children[j];
                if (this.isSpaceNode(child) || this.isSpaceChildrenNode(child)) {
                    box.removeByDescendant(child);
                    child.setParent(null);
                    if (this.isSpaceNode(child)
                        && child.getClient("modelRemovedNode")) {
                        var removedNode = child.getClient("modelRemovedNode");
                        removedNode.setParent(node);
                        box.addByDescendant(removedNode);
                    }
                }
            }
            data = this.sceneManager.getNodeData(node);
            if (data) {
                spaceNode = mode == 1 ? this.create1DSpaceNode(data) : this.create1DSpaceNode2(data);
                if (!spaceNode) {
                    continue;
                }
                //box --add By Kevin 2016-12-01
                var complexNode = node.getClient('complexNode');
                var simpleNode = node.getClient('simpleNode');
                if (simpleNode && node.getChildren().contains(simpleNode)) {
                    simpleNode.setParent(null);
                    box.removeByDescendant(simpleNode);
                    spaceNode.setClient("modelRemovedNode", simpleNode);
                } else if (complexNode != 'unload' && complexNode && node.getChildren().contains(complexNode)) {
                    complexNode.setParent(null);
                    box.removeByDescendant(complexNode);
                    spaceNode.setClient("modelRemovedNode", complexNode);
                }
                //add 2017-11-18 
                //2018-1-17 nodenodenull  --
                //   var cNodes = node.getChildren();
                //   if (cNodes && cNodes.size()){
                //     for(var k = 0 ; k < cNodes.size() ; k++){
                //         var childNode = cNodes.get(k);
                //         var childData = this.sceneManager.getNodeData(childNode);
                //         if (childData && childData.getParentId() == data.getId()) {
                //            childNode.setParent(null);
                //            box.removeByDescendant(childNode);
                //         }
                //     }
                //   }

                // this.nodeMap[data.getId()] = spaceNode;
                spaceNode.setClient("modelParent", node);
                spaceNode.setParent(node);
                box.addByDescendant(spaceNode);
            }
        }
        box.endBatch();
    },

    isSpaceNode: function (node) {
        return node.getClient("spaceNode");
    },

    hasSpaceNode: function (node) {
        if (!node) {
            return false;
        }
        var children = node.getChildren();
        if (children && children.size() > 0) {
            for (var i = 0; i < children._as.length; i++) {
                var child = children._as[i];
                if (this.isSpaceNode(child)) {
                    return true;
                }
            }
        }
        return false;
    },

    hasSpaceChildrenNode: function (node) {
        if (!node) {
            return false;
        }
        var children = node.getChildren();
        if (children && children.size() > 0) {
            for (var i = 0; i < children._as.length; i++) {
                var child = children._as[i];
                if (this.isSpaceChildrenNode(child)) {
                    return true;
                }
            }
        }
        return false;
    },

    isSpaceChildrenNode: function (node) {
        return node.getClient('spaceChildrenNode');
    },

    /**
     * SpaceNode
     */
    create1DSpaceNode: function (data, parameters) {
        var space = this.computeSpace(data);
        if (!(space instanceof it.Space1)) {
            return;
        }
        var dm = this.dataManager;
        var sm = this.sceneManager;
        var dataType = dm.getDataTypeForData(data);
        var childSize = dataType.getChildrenSize();
        var node = sm.getNodeForDataOrId(data);
        if (!node) {
            return;
        }

        var percent = space.getPercent();
        if (percent == 0) {
            percent = 0.01;
        }
        var color = this.getSpaceNodeColor(percent, data, space);
        var frameColor = this.getSpaceNodeFrameColor(percent, data, space) || color;
        var boundingBox = node.getBoundingBox();
        var width = boundingBox.max.x - boundingBox.min.x;
        var height = boundingBox.max.y - boundingBox.min.y;
        var depth = boundingBox.max.z - boundingBox.min.z;
        var offset = 1;
        width = width - 4;
        height = height - 4;
        var cube = new mono.Cube(width + offset, height + offset, depth + offset);
        // var cube = this.createColorCube(width + offset,height + offset,depth + offset);
        cube.setClient('spaceNode', true);
        cube.s({
            'm.wireframe': true,
            'm.transparent': true,
            // 'm.opacity': 0.1,
            'm.wireframeLineopacity': 0.1,
            //   'm.wireframeLinewidth': 2,
            //   'm.wireframeLinecolor': frameColor,
            //   'm.wireframeLineopacity': 0.5,
        });
        var axis = space.getAxis();
        if (axis === 'x') width = width * percent;
        if (axis === 'y') height = height * percent;
        if (axis === 'z') depth = depth * percent;
        // if(axis === 'x') width = width * percent*cube.getScaleX();
        // if(axis === 'y') height = height * percent*cube.getScaleY();
        // if(axis === 'z') depth = depth * percent * cube.getScaleZ();
        // var cube2 = new mono.Cube(width,height,depth);
        var cube2 = this.createColorCube(width, height, depth);
        cube2.setClient('spaceNode', true);
        cube2.setY(10);
        cube2.setParent(cube);
        var cbb = cube2.getBoundingBox();
        if (axis === 'x') {
            // cube2.setX(boundingBox.min.x - cbb.min.x);
            cube2.setX(boundingBox.min.x - cbb.min.x * cube2.getScaleX());
        } else if (axis === 'y') {
            // cube2.setY(boundingBox.min.y - cbb.min.y);
            cube2.setY(boundingBox.min.y - cbb.min.y * cube2.getScaleY() + 1); //floor+1
        } else {
            // cube2.setZ(boundingBox.min.z - cbb.min.z);
            cube2.setZ(boundingBox.min.z - cbb.min.z * cube2.getScaleZ());
        }
        var lightmap = 'data:image/jpeg;base64,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';
        //   var mColor = new mono.Color(color);
        //   mColor.lerp(mColor,0.5);
        var randomColor = -(Math.random() * 10 + 5);
        color = this.shadeColor(color, randomColor);
        cube2.s({
            'm.type': 'phong',
            'm.color': color,
            'm.ambient': color,
            'm.specularStrength': 20,
            'left.m.lightmap.image': lightmap,
            'right.m.lightmap.image': lightmap,
            'back.m.lightmap.image': lightmap,
            'front.m.lightmap.image': lightmap,
        });
        return cube;
    },
    shadeColor: function (color, percent) {
        var R = parseInt(color.substring(1, 3), 16);
        var G = parseInt(color.substring(3, 5), 16);
        var B = parseInt(color.substring(5, 7), 16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;

        var RR = ((R.toString(16).length == 1) ? "0" + R.toString(16) : R.toString(16));
        var GG = ((G.toString(16).length == 1) ? "0" + G.toString(16) : G.toString(16));
        var BB = ((B.toString(16).length == 1) ? "0" + B.toString(16) : B.toString(16));

        return "#" + RR + GG + BB;
    },

    /**
     * 
     * 
     */
    createColorCube: function (width, height, depth) {
        if (!this.colorCube) {
            this.colorCube = new mono.Cube(1, 1, 1);
        }
        var cloneCube = this.colorCube.clonePrefab();
        cloneCube.setScale(width, height, depth);
        return cloneCube;
    },

    removeSpaceNode: function (dataOrNodeOrId) {
        var sm = this.sceneManager;
        sm.removeNodeChildren(dataOrNodeOrId, function (child) {
            return child.getClient('spaceNode');
        });
    },

    create1DSpaceNode2: function (data, parameters) {
        var node = this.create1DChildrenSpaceNodes2(data, parameters);
        return node;
    },

    removeSpaceChildrenNode: function (dataOrNodeOrId) {
        var sm = this.sceneManager;
        sm.removeNodeChildren(dataOrNodeOrId, function (child) {
            return child.getClient('spaceChildrenNode');
        });
    },

    /**
     * SpaceNode 
     */
    create1DChildrenSpaceNodes2: function (data, parameters) {
        var space = this.computeSpace(data);
        if (!space instanceof it.Space1) {
            return;
        }
        var dm = this.dataManager;
        var sm = this.sceneManager;
        var node = sm.getNodeForDataOrId(data);
        var dataType = dm.getDataTypeForData(data);
        var childSize = dataType.getChildrenSize();
        if (!node) {
            return;
        }
        var axis = space.getAxis();
        if (!axis) {
            return;
        }
        var boundingBox = node.getBoundingBox();
        var size = boundingBox.size();
        var emptyList = space.getEmptyList();
        var occupationList = space.getOccupationList();
        var wrapNode = new mono.Cube(size.x - 2, size.y, size.z - 2);
        wrapNode.setClient('spaceNode', true);
        wrapNode.setParent(node);
        var nodes = [], total, start, end, object;
        for (var i = 0; i < emptyList.length; i++) {
            object = emptyList[i];
            // total = object.total,start = object.start,end = object.end;
            var spaceNode = this.create1DChildrenSpaceNode2(boundingBox, childSize, object, axis, true);
            spaceNode.setParent(wrapNode);
            nodes.push(spaceNode);
        }
        for (var i = 0; i < occupationList.length; i++) {
            object = occupationList[i];
            var spaceNode = this.create1DChildrenSpaceNode2(boundingBox, childSize, object, axis, false);
            spaceNode.setParent(wrapNode);
            nodes.push(spaceNode);
        }
        wrapNode.s({
            'm.transparent': true,
            'm.opacity': 0.1,
        });
        return wrapNode;
    },

    create1DChildrenSpaceNode2: function (boundingBox, childSize, object, axis, empty) {
        var total = object.total, start = object.start, end = object.end;
        var size = boundingBox.size();
        var width = size.x, height = size.y, depth = size.z;
        var xPadding = childSize.getXPadding() || [0, 0],
            yPadding = childSize.getYPadding() || [0, 0],
            zPadding = childSize.getZPadding() || [0, 0];
        var percent = 0, offset = 1;
        if (axis === 'x') {
            width = total * width / childSize.getXSize();
            width -= offset;
            percent = total / childSize.getXSize();
        } else if (axis === 'y') {
            height = total * height / childSize.getYSize();
            height -= offset;
            percent = total / childSize.getYSize();
        } else if (axis === 'z') {
            depth = total * depth / childSize.getZSize();
            depth -= offset;
            percent = total / childSize.getZSize();
        }
        var cube = new mono.Cube(width - 2, height - 2, depth - 2);
        var cbb = cube.getBoundingBox();
        var x = 0, y = 0, z = 0;
        if (axis === 'x') {
            x = boundingBox.min.x - cbb.min.x + size.x / childSize.getXSize() * (start - 1) + offset / 2;
        } else if (axis === 'y') {
            y = boundingBox.min.y - cbb.min.y + size.y / childSize.getYSize() * (start - 1) + offset / 2;
        } else if (axis === 'z') {
            z = boundingBox.min.z - cbb.min.z + size.z / childSize.getZSize() + offset / 2;
        }
        cube.p(x, y, z);
        //TODO  percent empty
        var color = emtpy ? this.getSpaceNodeColor(percent) : '#A4A4A4';
        cube.s({
            'm.type': 'phong',
            'm.specularStrength': 50,
            'm.color': color,
            'm.ambient': color
        });
        if (empty) {
            cube.s({
                'm.transparent': true,
                'm.opacity': 0.6,
            });
        }
        cube.setClient('spaceNode', true);
        return cube;
    },

    create1DChildrenSpaceNodes: function (data, parameters) {
        var space = this.computeSpace(data);
        if (!(space instanceof it.Space1)) {
            return;
        }
        var dm = this.dataManager;
        var sm = this.sceneManager;
        var dataType = dm.getDataTypeForData(data);
        var uOrder = dataType._modelParameters.uOrder;
        var childSize = dataType.getChildrenSize();
        var node = sm.getNodeForDataOrId(data);
        if (!node) {
            return;
        }
        var axis = space.getAxis();
        if (!axis) {
            return;
        }
        var boundingBox = node.getBoundingBox();
        var complexNode = node.getClient('complexNode');
        if (complexNode && complexNode != 'unload') {
            boundingBox = complexNode.getBoundingBox();
            if (!boundingBox.size() || (!boundingBox.size().x && !boundingBox.size().y && !boundingBox.size().z)) {
                boundingBox = it.Util.getBoundingBox(complexNode);
            }
        }
        var bSize = boundingBox.size();
        var width = bSize.x,height = bSize.y,depth = bSize.z;
        var xPadding = childSize.getXPadding() || [0,0],
            yPadding = childSize.getYPadding() || [0,0],
            zPadding = childSize.getZPadding() || [0,0];
        width -= (xPadding[0] + xPadding[1]);
        height -= (yPadding[0] + yPadding[1]);
        depth -= (zPadding[0] + zPadding[1]);
       
        var emptyList = space.getEmptyList();
        var nodes = [],i = 0,object,percent = space.getPercent();
        for(;i < emptyList.length;i ++){
            object = emptyList[i];
            var color = this.getSpaceNodeColor(percent,data);
            var bgColor = this.shadeColor(color, -30);
            var params = {
                object: object,
                width: width,
                height: height,
                depth:  depth,
                childSize: childSize,
                bgColor: bgColor,
                borderColor: color,
                lineColor: color,  
                lineWidth: 4, 
                textSize: '60px', 
                uOrder: uOrder,
                customPro: {
                    spaceChildrenNode: true,
                }
            }
            //nodes.push(this.createEmptyNode(object,width,height,depth,axis,childSize,boundingBox,data,percent));
            nodes.push(it.util.createOccupyPop(params, node));
        }
        return nodes;
    },

    // createEmptyNode : function(object,width,height,depth,axis,childSize,boundingBox,data,percent){
    //     var total = object.total,start = object.start,end = object.end;
    //     var xPadding = childSize.getXPadding() || [0,0],
    //         yPadding = childSize.getYPadding() || [0,0],
    //         zPadding = childSize.getZPadding() || [0,0];
    //     width -= (xPadding[0] + xPadding[1]);
    //     height -= (yPadding[0] + yPadding[1]);
    //     depth -= (zPadding[0] + zPadding[1]);
    //     var offset = 1;
    //     var text = "";
    //     if(axis === 'x'){
    //        width = total * width / childSize.getXSize();
    //        text = total + '('+start+'-' + (start+total-1) + ')';
    //     }else if(axis === 'y'){
    //        height = total * height / childSize.getYSize();
    //        text = total + 'U('+start+'-' + (start+total-1) + ')';//yU
    //     }else if(axis === 'z'){
    //       depth = total * depth / childSize.getZSize();
    //       text = total + '('+start+'-' + (start+total-1) + ')';
    //     }
    //     var cube = new mono.Cube(width - offset,height - offset,depth - offset);
    //     var cbb = cube.getBoundingBox();
    //     var x = 0,y = 0,z = 0
    //     if(axis === 'x'){
    //        x = boundingBox.min.x - cbb.min.x + xPadding[0] + width / total * (start - 1) + offset/2;
    //     }else if(axis === 'y'){
    //        y = boundingBox.min.y - cbb.min.y + yPadding[0] + height / total * (start - 1) + offset/2;
    //     }else if(axis === 'z'){
    //        z = boundingBox.min.z - cbb.min.z + zPadding[0] + depth / total * (start - 1) + offset/2;
    //     }
    //     cube.p(x,y,z);
    //     var color = this.getSpaceNodeColor(percent,data);
    //     cube.setClient('spaceChildrenNode',true);
  
        
    //     var ratio = cube.width / cube.height;
    //     // if(ratio && ratio > 6){ //height
    //     //     ratio = 6;
    //     // }
    //     //   1Uheight2
    //     //   1  2017.12.15 add by lyz 
    //     var image = this.createTextImage(text,{
    //           color : '#000000',//fontColor,
    //           font : '180px "Microsoft YaHei"',//20150420  bold 180px "Microsoft YaHei
    //           ratio : ratio,
    //           background : color,
    //           powerOfTwo : true,
    //     });
    //     var repeat = new mono.Vec3(image.drawRect.width/image.width,image.drawRect.height/image.height);
  
    //      // s_cube.setStyle('front.m.type','basic');
    //      //          s_cube.setStyle('front.m.texture.image',image);
    //      //          s_cube.setStyle('front.m.texture.repeat',repeat);
  
    //     cube.s({
    //         'm.color' : color,
    //         //
    //         // 'm.transparent' : true,
    //         // 'm.opacity' : 1, //0.2
    //         'front.m.type':'basic',
    //         'front.m.texture.image':image,
    //         'front.m.texture.repeat':repeat
    //     });
    //     return cube;
    //   },

    createTextImage: function (text, parameters) {
        text = text || '';
        text += '';
        var font = parameters.font, color = parameters.color;
        var background = parameters.background, powerOfTwo = parameters.powerOfTwo, canvas = parameters.canvas;
        var drawFunction = parameters.drawFunction;
        canvas = canvas || document.createElement('canvas');
        font = font || '20px "Dialog"';
        color = color || 'white';
        background = background === undefined ? '#0F90C4' : background;
        powerOfTwo = powerOfTwo || false;
        var lines = text.split('\n');
        var size = mono.Utils.getMaxTextSize(lines, font);
        // textcubewidth
        // ,10
        //        var size = {width:2048,height:256};
        var ratio = parameters.ratio || size.width / size.height;
        var realSize = canvas.realSize = {
            width: size.width,
            height: size.height,
        };

        // if (powerOfTwo) {
        //     size.width = mono.Utils.nextPowerOfTwo(size.width);
        //     size.height = mono.Utils.nextPowerOfTwo(size.height);
        // }
        var drawRect = canvas.drawRect = {
            width: realSize.width / realSize.height > ratio ? realSize.width : realSize.height * ratio,
            height: realSize.width / realSize.height > ratio ? realSize.width / ratio : realSize.height,
        }
        if (Number.isNaN(drawRect.width)) {
            console.log('debug -- b', realSize.width, realSize.height, ratio);
        }
        // drawRect.width = Math.min(drawRect.width, size.width);
        // drawRect.height = Math.min(drawRect.height, size.height);
        if (powerOfTwo) {
            size.width = mono.Utils.nextPowerOfTwo(drawRect.width);
            size.height = mono.Utils.nextPowerOfTwo(drawRect.height);
        }
        canvas.width = size.width;
        canvas.height = size.height;
        //   1Uheight2
        //   2  2017.12.15 add by lyz 
        // if (ratio) {
        //     canvas.height = size.width / ratio;
        //     drawRect.height = drawRect.width / ratio;
        // }
        if (Number.isNaN(drawRect.width)) {
            console.log('debug -- a');
        }

        var ctx = canvas.getContext("2d");
        background && (ctx.fillStyle = background);
        if (drawFunction) {
            drawFunction(ctx, canvas.width, canvas.height);
        } else {
            background && (ctx.fillRect(0, 0, canvas.width, canvas.height));
            // drawText(ctx, text, font, color, can;vas, 'center');
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.strokeStyle = 'gray';
            ctx.textBaseline = 'middle';
            // ctx.textAlign = 'center';
            var lineCount = lines.length, averageHeight = realSize.height / lineCount
            for (var i = 0; i < lineCount; i++) {
                var width = mono.Utils.getTextSize(font, lines[i]).width;
                var height = canvas.height;
                var x = (drawRect.width - realSize.width) / 2;
                var y = (drawRect.height - realSize.height) / 2 + averageHeight / 2 + i * averageHeight + (canvas.height - drawRect.height);

                ctx.strokeText(lines[i], x, y);
                ctx.fillText(lines[i], x, y);
            }
        }
        return canvas;
    },

});

it.SpaceManager = $SpaceManager;

var $SpaceVisibleFilter = function(sceneManager,spaceManager){
   this.sceneManager = sceneManager;
   this.spaceManager = spaceManager;
   this.visibleMap = {};
   var self = this;
   this.sceneManager.viewManager3d.addPropertyChangeListener(function(event){
       if(event.property == "focusNode"){
         self.visibleMap = {};
       }
   });
};

mono.extend($SpaceVisibleFilter,$VisibleFilter,{
  
    isVisible: function(node,data,network){
        var id = node.getId();
        // if(this.visibleMap[id] != undefined){
        //      return this.visibleMap[id];
        // }
        // var sm = this.sceneManager;
        // var sm2 = this.spaceManager;
        // var dm = sm.dataManager;
        // var focusNode = sm.viewManager3d.getFocusNode();
        // var root = node.getClient("modelParent") || node;
        // if(sm2.isSpaceNode(node) && root == node){
        //     root = node.getParent().getClient("modelParent") || root;
        // }
        if(node instanceof mono.Billboard){
            this.visibleMap[id] = false;
        	return false;
        }
        // if(focusNode === node){
        //     this.visibleMap[id] = true;
        // 	return true;
        // }
        // if(sm2.isSpaceNode(node)){
        // 	if(focusNode == root){
        //         this.visibleMap[id] = false;
        // 		return false;
        // 	}else{
        //         this.visibleMap[id] = true;
        // 		return true;
        // 	}
        // }
        // if(sm2.isSpaceChildrenNode(node)){
        // 	if(focusNode == node.getParent()){
        //         this.visibleMap[id] = true;
        // 		return true;
        // 	}
        //     this.visibleMap[id] = false;
        // 	return false;
        // }
        // if((node === root || sm.getMainNode(node) === root) && sm2.hasSpaceNode(root)){
        // 	if(focusNode == root){
        //         this.visibleMap[id] = true;
        // 		return true;
        // 	}else{
        //         this.visibleMap[id] = false;
        // 		return false;
        // 	}
        // }
        // if(data){
        //   var parent = sm.getParentNode(data);
        //   var parentData = dm.getParent(data);
        //   if(parent && parentData){
        //   	  var flag = this.isVisible(parent,parentData,network);
	       //    if(!flag){
        //         this.visibleMap[id] = false;
	       //    	return false;
	       //    }
        //   }
        // }
        // this.visibleMap[id] = true;
        return true;
    }
});

it.SpaceVisibleFilter = $SpaceVisibleFilter;

var $SpaceMaterialFilter = function (sceneManager,spaceManager) {
	this.sceneManager = sceneManager;
  this.spaceManager = spaceManager;
	this.materialMap = {};
};

mono.extend($SpaceMaterialFilter,$MaterialFilter,{
    filterMaterial : function(originalMaterial,filterdMaterial,node){
      var sm = this.sceneManager;
      var vm = sm.viewManager3d;
      var sm2 = this.spaceManager;
      var focusNode = vm.getFocusNode();
      var map = this.materialMap;

      if(sm.getNodeData(node)){
         return filterdMaterial;
      }
      if(sm2.isSpaceNode(node)){
         if(focusNode){
            if(node.isDescendantOf(focusNode)){
               return filterdMaterial;
            }else{
              var id = originalMaterial.getUniqueCode();
              var m = this.materialMap[id];
              if(!m){
                 m = originalMaterial.clone();
                 this.materialMap[id] = m;
                 m.transparent = true;
                 m.opacity = 0.05;
              }
              return m;
            }
         }
      }

	},

});

it.SpaceMaterialFilter = $SpaceMaterialFilter;
/**
 * create by Kevin
 * 
 *  LinkaddDataManagement
 *  :
 *  1.(it.Linkit.Data);
 *  2.linkdatamanagerlink(link);
 *  3.linkfromNodetoNode
 *
 * //fromNodetoNode()parent.
 * //nodenode,3D
 *
 * linklink
 *
 * @constructor
 */

var $GCSManager = function(obj) {
    var obj = obj || {};
    this.sceneManager = obj.sceneManager;
    this.viewManager3d = this.sceneManager.viewManager3d;
    this.box3D = this.sceneManager.network3d.getDataBox();
    this.defaultMaterialFilter = this.viewManager3d.getDefaultVirtualMaterialFilter();
    this.defaultEventHandler = this.viewManager3d.getDefaultEventHandler();
    this._flagLink = null; // Linklinklink
    this.animates = {};
    this.linkBillboard = {};
    this.linkManager = new $LinkManager(this.sceneManager);
    this.defaultSetFocusNode = this.viewManager3d.setFocusNode;
    this.undoSetFocusNode = function(node) {};
    this.mdfMap = {};
    this.lightBillboardMap = {};
    this.init();
};

mono.extend($GCSManager, $EventHandler, {

    init: function() {
        this.viewManager3d.addEventHandler(this);
        var self = this;
        this.gcsManagerInterval = setInterval(function() {
            var billboards = self.linkBillboard;
            if (billboards) {
                for (var id in billboards) {
                    var link = self.sceneManager.dataManager.getLinkById(id);
                    if (!link) {
                        continue;
                    }
                    var billboard = billboards[id];
                    var bg = '#5B8505';
                    var value = link._userDataMap['flow'] || 1;
                    var canvas = billboard.getStyle('m.texture.image');
                    if (!(canvas instanceof HTMLCanvasElement)) {
                        canvas = null;
                    }
                    billboard.setStyle('m.texture.image', it.Util.getSpecialTextBillboard(value.toFixed(2), it.util.i18n("LinkSearch_Flow") +':', 'M/s', bg, false, canvas));
                    billboard.invalidateTexture();
                }
            }
        }, 10000);

        this.sceneManager.addSceneChangeListener(function(eve){
            self.clearAllLink();
        });
    },

    /**
     * link
    */
    clearAllLink: function(withoutAfterClearCall, lookAtData) {
        for (var linkId in this.sceneManager.linkMap) {
            this.clearLinkById(linkId, lookAtData);
        }
        this.unlock();
        if(this.gcsManagerInterval){
            clearInterval(this.gcsManagerInterval);
        }
        if (!withoutAfterClearCall) {
            this.afterClearAllLinkFunction && this.afterClearAllLinkFunction();
        }
    },

    /**
     *
     * LookAtlookAt
     * 
     */
    lock: function() {
        this.sceneManager.doubleClickBackgroundGotoUpLevelScene = false;
        this.viewManager3d.setFocusNode = this.undoSetFocusNode;
        this.viewManager3d.setCameraDistanceForAfterPlayCamere(this.sceneManager.getCurrentRootNode());//rootNode
    },

    /**
     * LookAtlookAt
     */
    unlock: function() {
        this.sceneManager.doubleClickBackgroundGotoUpLevelScene = true;
        this.viewManager3d.setFocusNode = this.defaultSetFocusNode;
    },

    stopAllAnimates: function() {
        if (!this.animates) {
            return;
        }
        for (var id in this.animates) {
            var animate = this.animates[id];
            if (animate instanceof Array) {
                for (var i = 0; i < animate.length; i++) {
                    animate[i] && animate[i].stop();
                }
            } else {
                this.animates[id].stop();
            }
            delete this.animates[id];
        }
    },

    clearAllAnimateBillboard: function() {
        if (!this.lightBillboardMap) {
            return;
        }
        for (var id in this.lightBillboardMap) {
            if (this.lightBillboardMap[id]) {
                this.box3D.remove(this.lightBillboardMap[id]);
            }
        }
    },

    /**
     * Link
     * linkfromNodetoNodefromtofromtoboxremovefromtoparent
     *
     * @param linkOrId
     * @param lookAtData lookAt()lookAt
     */
    clearLinkById: function(linkOrId, lookAtData) {
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var sm = this.sceneManager;
        var link = sm.dataManager.getLinkById(id);
        if (!link) return;
        var linkNode = sm.linkMap[id];
        if (!linkNode) { //
            return;
        }
        if (this.animates && this.animates[id]) {
            var animate = this.animates[id];
            if (animate instanceof Array) {
                for (var i = 0; i < animate.length; i++) {
                    animate[i] && animate[i].stop();
                }
            } else {
                this.animates[id].stop();
            }
            delete this.animates[id];
        }
        if (this.lightBillboardMap && this.lightBillboardMap[id]) {
            this.box3D.remove(this.lightBillboardMap[id]);
        }
        ///linkbox,
        if (linkNode && linkNode.isVisible() && this.box3D.getDataById(linkNode.getId())) {
            var fromId = link.getFromId();
            var toId = link.getToId();
            var fromData = sm.dataManager.getDataById(fromId);
            var toData = sm.dataManager.getDataById(toId);
            if (fromData && toData) {
                var fromSceneAndRoot = sm.getSceneAndRootByData(fromData);
                var toSceneAndRoot = sm.getSceneAndRootByData(toData);
                var isSameScene = true;
                var targetSceneAndRoot = sm.getSceneAndRootByData(lookAtData);
                if (fromSceneAndRoot && !toSceneAndRoot) {
                    isSameScene = false;
                } else if (!fromSceneAndRoot && toSceneAndRoot) {
                    isSameScene = false;
                } else if (fromSceneAndRoot && toSceneAndRoot && (fromSceneAndRoot.scene != toSceneAndRoot.scene || fromSceneAndRoot.rootData != toSceneAndRoot.rootData)) {
                    isSameScene = false;
                } else if (fromSceneAndRoot && targetSceneAndRoot && (fromSceneAndRoot.scene != targetSceneAndRoot.scene || fromSceneAndRoot.rootData != targetSceneAndRoot.rootData)) {
                    isSameScene = false;
                }
                if (!isSameScene) {
                    var fromRootNode = sm.getNodeByDataOrId(fromSceneAndRoot.rootData);
                    var toRootNode = sm.getNodeByDataOrId(toSceneAndRoot.rootData);
                    if (lookAtData && (lookAtData == fromData || lookAtData == toData)) {
                        if (lookAtData == fromData) {
                            this.box3D.removeByDescendant(toRootNode);
                            if (sm._currentScene != fromSceneAndRoot.scene || sm._currentRootNode != fromRootNode) {
                                sm._currentScene = fromSceneAndRoot.scene;
                                sm._currentRootNode = fromRootNode;
                                //sceneChange
                                sm._sceneChangeDispather.fire({
                                    kind: 'changeScene',
                                    data: fromSceneAndRoot.scene
                                });
                                this.defaultEventHandler.lookAt(sm.getNodeByDataOrId(lookAtData));
                            }
                        } else { //if(lookAtData == toData){
                            this.box3D.removeByDescendant(fromRootNode);
                            if (sm._currentScene != toSceneAndRoot.scene || sm._currentRootNode != toRootNode) {
                                sm._currentScene = toSceneAndRoot.scene;
                                sm._currentRootNode = toRootNode;
                                //sceneChange
                                sm._sceneChangeDispather.fire({
                                    kind: 'changeScene',
                                    data: toSceneAndRoot.scene
                                });
                                this.defaultEventHandler.lookAt(sm.getNodeByDataOrId(lookAtData));
                            }
                        }
                    } else {
                        if (fromSceneAndRoot && fromSceneAndRoot.rootData) {
                            if (fromRootNode != sm.getCurrentRootNode()) {
                                this.box3D.removeByDescendant(fromRootNode);
                            }
                        }
                        if (toSceneAndRoot && toSceneAndRoot.rootData) {
                            if (toRootNode != sm.getCurrentRootNode()) {
                                this.box3D.removeByDescendant(toRootNode);
                            }
                        }
                    }
                }
            }
            // 
            var fromRackNode = this.getRackNodeByNode(this.sceneManager.getNodeByDataOrId(fromId));
            var fromRackData = this.sceneManager.getNodeData(fromRackNode);
            var fromMdfNode = this.mdfMap[fromRackData.getId()];
            if (fromMdfNode) {
                fromMdfNode.setParent(null);
                this.sceneManager.network3d.dataBox.remove(fromMdfNode);
            }
            var toRackNode = this.getRackNodeByNode(this.sceneManager.getNodeByDataOrId(toId));
            var toRackData = this.sceneManager.getNodeData(toRackNode);
            var toMdfNode = this.mdfMap[toRackData.getId()];
            if (toMdfNode) {
                toMdfNode.setParent(null);
                this.sceneManager.network3d.dataBox.remove(toMdfNode);
            }
        }
        linkNode.setVisible(false);
        var billboard = this.linkBillboard[id];
        if (billboard) {
            billboard.setVisible(false);
        }
    },

    /**
     * datadataIdlink
     * @param dataOrId
     */
    clearLinksByData: function(dataOrId, lookAtData) {
        var data = null;
        var sm = this.sceneManager;
        if (dataOrId instanceof it.Data) {
            data = dataOrId;
        } else {
            data = this.sceneManager.dataManager.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        var rackNode = this.getRackNodeByNode(this.sceneManager.getNodeByDataOrId(data));
        var rackData = this.sceneManager.getNodeData(rackNode);
        var mdfNode = this.mdfMap[rackData.getId()];
        if (mdfNode) {
            mdfNode.setParent(null);
            this.sceneManager.network3d.dataBox.remove(mdfNode);
        }
        var links = data.getAllLinks();
        if (links) { //
            var linkCount = 0;
            for (var linkId in links) {
                this.clearLinkById(linkId);
                linkCount++;
            }
            if (linkCount < 1) {
                return;
            }
            if (lookAtData) {
                var lookAtSceneAndRoot = this.sceneManager.getSceneAndRootByData(lookAtData);
                var isSameScene = true;
                var lookAtNode = sm.getNodeByDataOrId(lookAtData);
                var lookAtRootNode = null;
                if (lookAtSceneAndRoot && lookAtSceneAndRoot.rootData) {
                    lookAtRootNode = sm.getNodeByDataOrId(lookAtSceneAndRoot.rootData);
                }
                if (lookAtSceneAndRoot && !sm._currentScene) {
                    isSameScene = false;
                } else if (!lookAtSceneAndRoot && sm._currentScene) {
                    isSameScene = false;
                } else if (lookAtSceneAndRoot.scene != sm._currentScene || sm._currentRootNode != lookAtRootNode) {
                    isSameScene = false;
                }
                if (!isSameScene) {
                    this.box3D.removeByDescendant(sm._currentRootNode);
                    this.box3D.addByDescendant(lookAtRootNode);
                    this.box3D.addByDescendant(lookAtNode); //lookAtlookAtRoot(filter)
                    sm._currentScene = lookAtSceneAndRoot.scene;
                    sm._currentRootNode = lookAtRootNode;
                    //sceneChange
                    sm._sceneChangeDispather.fire({
                        kind: 'changeScene',
                        data: lookAtSceneAndRoot.scene
                    });
                    this.defaultEventHandler.lookAt(lookAtNode);
                }
            }
        }

    },

    /**
     * datalink
     * link1
     * 
     *  Nodeboundboxx
     * @param dataOrId

     **  
     */
    showLinksByData: function(dataOrId, resetControls) {
        var data = null;
        this.clearAllLink();
        if (dataOrId instanceof it.Data) {
            data = dataOrId;
        } else {
            data = this.sceneManager.dataManager.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        var links = data.getAllLinks();
        var maxLink = null;
        var nodes = [];
        if (links) {
            var linkNodes = [];
            for (var linkId in links) {
                this._createLinkByLinkId(linkId, resetControls, false);
                var linkNode = this.sceneManager.linkMap[linkId];
                linkNodes.push(linkNode);
                var link = links[linkId];
                if (link) {
                    var fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                    var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                    nodes.push(fromNode);
                    nodes.push(toNode);
                }
            }
            if (linkNodes.length === 1) {
                this.defaultEventHandler.lookAt(linkNodes[0]);
                return;
            } else {
                this.defaultEventHandler.lookAtElements(nodes);
            }
            this.lock();
        } else {
            var dataNode = this.sceneManager.getNodeByDataOrId(data);
            if (dataNode) {
                this.defaultEventHandler.lookAt(dataNode);
            }
        }
    },

    afterShowLink: function(link) {

    },

    /**
     * node
     */
    afterShowNetLinks: function(objects) {
        // if (!links || links.length > 0) {
        //     for (var i = 0; i < links.length; i++) {
        //         var link = links[i];
        //         this.afterShowLink(link);
        //     }
        // }
    },
    
    /**
     * dataOrIddata
     */
    showMulLinkByData: function(dataOrId, resetControls) {
        var data = null;
        this.clearAllLink();
        if (dataOrId instanceof it.Data) {
            data = dataOrId;
        } else {
            data = this.sceneManager.dataManager.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        if (!this.linkManager.linkMap) {
            this.linkManager.computeLinkTree();
        }
        var objects = this.linkManager.getMulLinksByDataId(dataOrId);
        var nodes = [];
        if (objects && objects.length > 0) {
            this.lock();
            var linkNodes = [];
            this.viewManager3d.defaultMaterialFilter.addAll(); //
            // linkfloorlinkfloor 
            this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager._currentRootData);
            for (var j = 0; j < objects.length; j++) {
                var links = objects[j];
                if (!links || links.length < 1) {
                    console.log("link's length is 0 ,please to check!!!");
                    continue;
                }
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    if (link) {
                        this._createLinkByLinkId(link.getId(), resetControls, false);
                        var linkNode = this.sceneManager.linkMap[link.getId()];
                        linkNodes.push(linkNode);
                        var fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                        var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                        nodes.push(fromNode);
                        nodes.push(toNode);
                        this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager.getNodeData(fromNode)); //
                        this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager.getNodeData(toNode)); //
                    }
                }
            }
            if (nodes && nodes.length > 0) {
                for(var i = 0 ; i < nodes.length ; i++){
                    if (!this.sceneManager.isCurrentSceneInstance(this.sceneManager.getNodeData(nodes[i]))) {
                        this.viewManager3d.defaultMaterialFilter.add(this.sceneManager._currentRootData);
                        break;
                    }
                }
            }
            if (linkNodes.length === 1) {
                this.defaultEventHandler.lookAt(linkNodes[0]);
            } else {
                this.defaultEventHandler.lookAtElements(nodes);
            }
            this.afterShowNetLinks(objects);
            this.playAnimateByLinks(objects[0]);
        } else {
            var dataNode = this.sceneManager.getNodeByDataOrId(data);
            if (dataNode) {
                this.defaultEventHandler.lookAt(dataNode);
            }
        }
        // 2017-10-30 lookAtLinksetFoucefocusFloor
        //  link
        this.sceneManager.viewManager3d._focusNode = this.sceneManager.getCurrentRootNode();
    },

    /**
     * lookAt
     */
    lookAtLinks: function(links) {
        if (!links) {
            return;
        }
        if (!(links instanceof Array)) {
            var linkNode = this.sceneManager.linkMap[links.getId()];
            this.defaultEventHandler.lookAt(linkNode);
            return;
        }
        if (links.length == 1) {
            var linkNode = this.sceneManager.linkMap[links[0].getId()];
            this.defaultEventHandler.lookAt(linkNode);
            return;
        }
        var nodes = [];
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            if (link) {
                var fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                nodes.push(fromNode);
                nodes.push(toNode);
            }
        }
        this.defaultEventHandler.lookAtElements(nodes);
    },

    /**
     * link
     * linkfromNodetoNodeLink
     * @param resetControls
     */
    showAllLinks: function(resetControls) {
        var linkMap = this.sceneManager.dataManager.getLinkMap();
        if (!linkMap) return;
        for (var id in linkMap) {
            this.showLinkByLinkId(id, resetControls, false);
        }
    },

    showBillboard: function(link) {
        return true;
    },

     // -- add by azhuang 2018-1-10 

        /*
        * 
        * node
        * node
        * nodecallback
        * nodeloadlazydata
        * from->to->link->Link
        */
    _createLinkByLinkId: function(linkOrId, resetControls, removeOthers, withOutHeight, callback, scop) {
        var id = linkOrId;
        var isClear = true;
        if (removeOthers != undefined && removeOthers != null) {
            isClear = removeOthers;
        }
        if (isClear) {
            this.clearAllLink();
        }
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        if (id) {
            this.originLinkId = id;
            var contralPoints = null;
            var linkRes = this.createlinkRelationById(id);
            var link = linkRes.link;
            var fromId = linkRes.fromId;
            var toId = linkRes.toId;
            var fromPortId = linkRes.fromPortId;
            var toPortId = linkRes.toPortId;
            var fromSide = linkRes.fromSide;
            var toSide = linkRes.toSide;
            var fromNode = linkRes.fromNode;
            var toNode = linkRes.toNode;
            var linkNode = linkRes.linkNode;

            // -- add by azhuang 2018-1-10 
            //linkNodefromNodetoNodenode
            //1node
            // if (!linkNode) { // fromtoload
            //     if (this.reloadLink(id)) {
            //         linkNode = this.sceneManager.linkMap[id];
            //         fromNode = this.sceneManager.dataNodeMap[fromId];
            //         toNode = this.sceneManager.dataNodeMap[toId];
            //     }
            // }
            
            if (fromNode && toNode) {
                this.showFromAndToNode(fromNode,toNode);
                if(!linkNode){
                    this.sceneManager.loadLink(link);
                }
                this.afterLoadLinkNode(id, resetControls, withOutHeight, callback, scop);
            }else{
                var self = this;
                var afterLoadFromNode = function(fromNode){
                    var afterLoadToNode = function(toNode){
                        var link = self.createlinkRelationById(id).link;
                        var fromNode = self.createlinkRelationById(id).fromNode;
                        var toNode = self.createlinkRelationById(id).toNode;
                        self.showFromAndToNode(fromNode,toNode);
                        self.sceneManager.loadLink(link);
                        self.afterLoadLinkNode(id, resetControls, withOutHeight, callback, scop);
                        //
                    };
                    self.sceneManager.loadLazyData(toId,afterLoadToNode);
                }
                this.sceneManager.loadLazyData(fromId,afterLoadFromNode);
            }
        }
    },
    createlinkRelationById: function(id){
        var link = this.sceneManager.dataManager.getLinkById(id);
        var fromId = link.getFromId();
        var toId = link.getToId();
        var fromPortId = link.getFromPortId();
        var toPortId = link.getToPortId();
        var fromSide = link.getFromSide();
        var toSide = link.getToSide();
        //fromNodetoNodenullreload
        var fromNode = this.sceneManager.dataNodeMap[fromId];
        var toNode = this.sceneManager.dataNodeMap[toId];
        var linkNode = this.sceneManager.linkMap[id];
        return {
            link: link,
            fromId: fromId,
            toId: toId,
            fromPortId: fromPortId,
            toPortId: toPortId,
            fromSide: fromSide,
            toSide: toSide,
            fromNode: fromNode,
            toNode: toNode,
            linkNode: linkNode
        }
    },
    showLinkNode: function(id,resetControls,withOutHeight){
        var linkRes = this.createlinkRelationById(id);
        var link = linkRes.link;
        var fromId = linkRes.fromId;
        var toId = linkRes.toId;
        var fromPortId = linkRes.fromPortId;
        var toPortId = linkRes.toPortId;
        var fromSide = linkRes.fromSide;
        var toSide = linkRes.toSide;
        var fromNode = linkRes.fromNode;
        var toNode = linkRes.toNode;
        var linkNode = linkRes.linkNode;
        // mono.LinkfromNodetoNodeboxlinkfromtonull
        if (!linkNode.getFromNode()) {
            var linkFromNode = fromNode;
            if (fromPortId) { // add by 2016-12-06 
                var fromPortNode = this.sceneManager.postManager.loadPortByPortId(fromId, fromPortId, fromSide);
                if (fromPortNode) {
                    linkFromNode = fromPortNode;
                }
            }
            linkNode.setFromNode(linkFromNode);
        }
        if (!linkNode.getToNode()) {
            var linkToNode = toNode;
            if (toPortId) { // add by 2016-12-06 
                var toPortNode = this.sceneManager.postManager.loadPortByPortId(toId, toPortId, toSide);
                if (toPortNode) {
                    linkToNode = toPortNode;
                }
            }
            linkNode.setToNode(toNode);
        }
        linkNode.setVisible(true);
        if (!this.box3D.getDataById(linkNode.getId())) { // fromtolink
            this.box3D.add(linkNode);
        }
        if (resetControls) {
            contralPoints = this.resetPathByLink(id, withOutHeight);
        }
    },
    showFromAndToNode: function(fromNode,toNode){
        //
        this.defaultMaterialFilter.removeByDescendant(fromNode);
        this.defaultMaterialFilter.removeByDescendant(toNode);

        //box
        if (!this.box3D.getDataById(fromNode.getId())) {
            this.box3D.addByDescendant(fromNode);
        }
        if (!this.box3D.getDataById(toNode.getId())) {
            this.box3D.addByDescendant(toNode);
        }
        var fromRootNode = this.getNodeRootNodeByNode(fromNode);
        var fromRootData = this.sceneManager.getNodeData(fromRootNode);
        var self = this;
        if (fromRootNode && !this.box3D.getDataById(fromRootNode.getId())) {
            this.box3D.addByDescendant(fromRootNode, function(childNode) {
                var childNodeData = self.sceneManager.getNodeData(childNode);
                if (childNodeData && childNodeData == fromRootData) {
                    return true;
                } else {
                    return false;
                }
            });
        }
        var toRootNode = this.getNodeRootNodeByNode(toNode);
        var toRootData = this.sceneManager.getNodeData(toRootNode);
        if (toRootNode && !this.box3D.getDataById(toRootNode.getId())) {
            this.box3D.addByDescendant(toRootNode, function(childNode) {
                var childNodeData = self.sceneManager.getNodeData(childNode);
                if (childNodeData && childNodeData == toRootData) {
                    return true;
                } else {
                    return false;
                }
            });
        }
    },
    afterLoadLinkNode: function(id, resetControls, withOutHeight, callback, scop){
        var link = this.createlinkRelationById(id).link;
        this.lock();
        var fromId = link.getFromId();
        var toId = link.getToId();
        if (!this.sceneManager.isCurrentSceneInstance(fromId) 
            || !this.sceneManager.isCurrentSceneInstance(toId)) {
            this.viewManager3d.defaultMaterialFilter.add(this.sceneManager._currentRootData);
        }
        this.showLinkNode(id,resetControls,withOutHeight);
        if (this.showBillboard(link)) {
            var billboard = this.createBillboard(link);
        }
        this.afterShowLink(link);
        callback && callback(scop);
    },
    /**
     * linkIdlink
     * billboardafteer
     * @param linkOrId
     * @param resetControls
     * @param removeOthers
     *
     */
    showLinkByLinkId: function(linkOrId, resetControls, removeOthers, withOutHeight ,callback, scop) {
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var link = this.sceneManager.dataManager.getLinkById(id);
        if (!link) {
            return ;
        }
        this.viewManager3d.defaultMaterialFilter.addAll(); //2017-10-20  _createLinkByLinkIdlinknode
        // linkfloorlinkfloor 
        this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager._currentRootData);
        this._createLinkByLinkId(link, resetControls, removeOthers, withOutHeight ,callback, scop);
    },

    /**
     * node
     * @param node
     * @returns {*}
     */
    getNodeRootNodeByNode: function(node) {
        if (!node) {
            return null;
        }
        var data = this.sceneManager.getNodeData(node);
        var sceneAndRoot = this.sceneManager.getSceneAndRootByData(data);
        if (sceneAndRoot && sceneAndRoot.rootData) {
            return this.sceneManager.getNodeByDataOrId(sceneAndRoot.rootData);
        }
        return null;
    },

    createBillboard: function(link) {
        if (!link) {
            return;
        }
        var linkNode = this.sceneManager.linkMap[link.getId()];
        if (!linkNode) {
            return;
        }
        var contralPoints = linkNode.getControls();
        var px, py, pz;
        if (contralPoints && contralPoints.length > 4) {
            var p4 = contralPoints[3];
            px = p4.x;
            py = p4.y + 60;
            pz = p4.z;
        }
        var billboard = this.linkBillboard[link.getId()];
        if (!billboard) {
            var billboard = it.Util.createSpecailTextBillboard("text");
            billboard.setPosition(px || 0, py || 0, pz || 0);
            var bg = '#5B8505';
            var value = link._userDataMap['flow'] || 0;
            billboard.setStyle('m.texture.image', it.Util.getSpecialTextBillboard(value.toFixed(2), it.util.i18n("LinkSearch_Flow") +':', 'M/s', bg));
            billboard.invalidateTexture();
            billboard.s({
            	'm.fixedSize': 5000,
            })
            this.box3D.add(billboard);
            this.linkBillboard[link.getId()] = billboard;
        } else {
            billboard.setVisible(true);
            if (!this.box3D.getDataById(billboard.getId())) {
                this.box3D.add(billboard);
            }
        }
    },

    /**
     * Link
     * @param linkOrId
     * @returns {boolean} true
     */
    reloadLink: function(linkOrId) {
        if (!linkOrId) {
            return false;
        }
        var link = null;
        if (linkOrId instanceof it.Link) {
            link = linkOrId;
        } else {
            link = this.sceneManager.dataManager.getLinkById(linkOrId);
        }
        if (!link) {
            return false;
        }
        var linkNode = this.sceneManager.linkMap[link.getId()];
        if (linkNode) {
            return false;
        }
        var fromId = link.getFromId();
        var toId = link.getToId();
        //fromtolookAtfromto
        var fromNode = this.sceneManager.dataNodeMap[fromId];
        if (!fromNode) {
            if (!this.sceneManager.dataManager.getDataById(fromId)) {
                return false;
            }
            this.sceneManager.loadLazyData(fromId);
        }
        var toNode = this.sceneManager.dataNodeMap[toId];
        if (!toNode) {
            if (!this.sceneManager.dataManager.getDataById(toId)) {
                return false;
            }
            this.sceneManager.loadLazyData(toId);
        }
        this.sceneManager.loadLink(link);
        return true;
    },

    resetPathByLink: function(linkOrId, withOutHeight) {
        if (!linkOrId) {
            return null;
        }
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var linkNode = this.sceneManager.linkMap[id];
        if (!linkNode) return null;
        var controls = null;
        if (withOutHeight) {
            controls = this.generateControlsWithOutHeight(linkNode);
        } else {
            // controls = this.generateControls(linkNode,200);
            controls = this.generateControlsWithMDF(linkNode);
        }
        if (controls) {
            linkNode.setControls(controls);
        }
        return controls;
    },

    resetPathByData: function(dataOrId) {

    },

    /**
     * worldPositionrootNode
     */
    getRelatePosition: function(worldPosition) {
        var rootNode = this.sceneManager.getCurrentRootNode();
        if (!rootNode || !worldPosition) {
            return null;
        }
        var wm = new mono.Mat4(); //new
        wm.setPosition(worldPosition);
        var m1, m2;
        m1 = new mono.Mat4().getInverse(rootNode.worldMatrix.clone());
        m2 = new mono.Mat4().multiplyMatrices(m1, wm);
        var position = new mono.Vec3().getPositionFromMatrix(m2);
        return position;
    },

    /**
     * fromNodetoNoderack
     */
    getRackNodeByNode: function(node) {
        if (!node) {
            return null;
        }
        var data = this.sceneManager.getNodeData(node);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId() == 'rack') {
            return node;
        } else if (category && category.getId() == 'equipment') {
            var parentNode = this.sceneManager.getNodeByDataOrId(data.getParentId());
            var resuleNode = this.getRackNodeByNode.call(this, parentNode);
            return resuleNode || node;
        }
        if (node.getClient('parentId')) {
            var equipmentNode = this.sceneManager.getNodeByDataOrId(node.getClient('parentId'));
            var resultNode = this.getRackNodeByNode.call(this, equipmentNode);
            return resultNode || equipmentNode || node;
        }
        return node;
    },

    /**
     * 
     * floor 
     *
     */
    /*
    generateControls : function(linkNode,height){
        if(!linkNode){
            return null;
        }
        var fromNode = linkNode.getFromNode();
        var toNode = linkNode.getToNode();
        if(!fromNode || !toNode){
            return null;
        }
        var bb1 = fromNode.getBoundingBox(),bb2 = toNode.getBoundingBox();
        var w_from = fromNode.getWorldPosition();
        var w_to = toNode.getWorldPosition();
        var w_r_from = null,w_r_to = null; // 
        var frNode = this.getRackNodeByNode(fromNode);
        var trNode = this.getRackNodeByNode(toNode);
        if (frNode && frNode.getBoundingBox) {
            bb1 = frNode.getBoundingBox();
            w_r_from = frNode.getWorldPosition();
        }
        if (trNode && trNode.getBoundingBox) {
            bb2 = trNode.getBoundingBox();
            w_r_to = trNode.getWorldPosition();
        }
        var maxZ = 20, maxY = Math.max(bb1.max.y,bb2.max.y) + 20 ;
        if (maxY < 50) {
            maxY = 50;
        }
        var pos1 = fromNode.frontWorldPosition(bb1.max.z + maxZ),pos2 = toNode.frontWorldPosition(bb2.max.z + maxZ);

        // if(frNode){
        //      w_from = frNode.getWorldPosition();
        // }
        // if (trNode){
        //      w_to = trNode.getWorldPosition();
        // }
        var controls = [];
        controls.push(pos1);
        var f_pos = pos1.clone().add(new mono.Vec3(0,maxY,0));
        if (w_r_from) {
            f_pos.setY(w_r_from.y + maxY);
        }
        controls.push(f_pos);
        f_pos = w_from.clone().add(new mono.Vec3(0,maxY,0));
        if (w_r_from) {
            // f_pos.setX(w_r_from.x);
            f_pos.setY(w_r_from.y + maxY);
        }
        controls.push(f_pos); //

        var w_max_y = Math.max(w_from.y,w_to.y);
        if (w_r_from) {
            w_max_y = Math.max(w_max_y,w_r_from.y);
        }
        if (w_r_to) {
            w_max_y = Math.max(w_max_y,w_r_to.y);
        }
        controls.push(new mono.Vec3(w_from.x, w_max_y + height, w_from.z));
        controls.push(new mono.Vec3(w_from.x, w_max_y + height, w_to.z));
        controls.push(new mono.Vec3(w_to.x, w_max_y + height, w_to.z));

        var t_pos = pos2.clone().add(new mono.Vec3(0,maxY,0));
        if (w_r_to) {
            // t_pos.setX(w_r_to.x);
            t_pos.setY(w_r_to.y + maxY);
             var toTop = w_to.clone().add(new mono.Vec3(0,maxY,0));
             toTop.setY(w_r_to.y + maxY)
             controls.push(toTop); //
        }else{
            controls.push(w_to.clone().add(new mono.Vec3(0,maxY,0))); //
        }
        controls.push(t_pos);
        controls.push(pos2);
        return controls;
    },
    */

    /**
     *
     *    
     * 
     * ()
     *
     */
    generateControlsWithMDF: function(linkNode, height) {
        if (!linkNode) {
            return null;
        }
        var fromNode = linkNode.getFromNode();
        var toNode = linkNode.getToNode();
        if (!fromNode || !toNode) {
            return null;
        }
        var controls = [];
        var f2MdfPoints = this.getNodeToMDFControls(fromNode);
        var t2MdfPoints = this.getNodeToMDFControls(toNode);
        if (f2MdfPoints && t2MdfPoints && f2MdfPoints.length > 0 && t2MdfPoints.length > 0) {
            for (var i = 0; i < f2MdfPoints.length; i++) {
                controls.push(f2MdfPoints[i]);
            }
            var fp = f2MdfPoints[f2MdfPoints.length - 1];
            var tp = t2MdfPoints[t2MdfPoints.length - 1];
            var fMdf2TMdfPoints = this.getInflectionPoints(fp, tp);
            if (fMdf2TMdfPoints && fMdf2TMdfPoints.length > 0) {
                for (var i = 0; i < fMdf2TMdfPoints.length; i++) {
                    controls.push(fMdf2TMdfPoints[i]);
                }
            }
            for (var i = t2MdfPoints.length - 1; i >= 0; i--) {
                controls.push(t2MdfPoints[i]);
            }
        }
        return controls;
    },

    /**
     * 
     * 
     * 
     */
    getMdfByRack: function(node) {
        if (!node) {
            return null;
        }
        var nodeData = this.sceneManager.getNodeData(node);
        if (!nodeData) {
            return null;
        }
        var mdfNode = this.mdfMap[nodeData.getId()];
        if (!mdfNode) {
            var bb = node.getBoundingBox();
            var size = bb.size() || {
                x: 60
            };
            var width = 55;
            var z = 0;
            var y = 0
            var mdfNode = new mono.Cube(width, 20, 3);
            if (bb) {
                width = bb.size().x;
                z = bb.max.z - 5;
                z = z + 5 //
                    // y = bb.max.y + 40; //
                y = bb.max.y - 12; //
            }
            mdfNode.setPosition(0, y, z);
            mdfNode.setClient(it.SceneManager.CLIENT_EXT_VITUAL, true);
            // mdfNode.setStyle('m.type', 'phong');
            // mdfNode.setStyle('m.color', '#3D3D3D');
            // mdfNode.setStyle('m.ambient', '#3D3D3D');
            mdfNode.setStyle('front.m.texture.image', './images/mdf_front.jpg');
            mdfNode.setStyle('back.m.texture.image', './images/mdf_front.jpg');
            mdfNode.setClient('itv_mdf', true);
            mdfNode.setClient('itv_mdf_rack_data', nodeData);
            this.mdfMap[nodeData.getId()] = mdfNode;
        }
        mdfNode.setParent(node);
        this.sceneManager.network3d.dataBox.add(mdfNode);
        return mdfNode;
    },

    /**
     * 
     * 
     * pos1pos2
     * 
     * 
     * controls
     */
    getInflectionPoints: function(pos1, pos2) {
        if (!pos1 || !pos2) {
            return null;
        }
        var p1 = pos1.clone();
        var p2 = pos2.clone();
        var differentCount = 0;
        var points = [];
        if (p1.x != p2.x) {
            differentCount++;
            // points.push(new mono.Vec3(p2.x,p1.y,p1.z));
        }
        if (p1.y != p2.y) {
            differentCount++;
            // points.push(new mono.Vec3(p2.x,p2.y,p1.z));
        }
        if (p1.z != p2.z) {
            differentCount++;
        }
        if (differentCount <= 1) {
            return null;
        }
        if (p1.x != p2.x && differentCount > 1) {
            differentCount--;
            points.push(new mono.Vec3(p2.x, p1.y, p1.z));
        }
        if (p1.y != p2.y && differentCount > 1) {
            differentCount--;
            points.push(new mono.Vec3(p2.x, p2.y, p1.z));
        }
        // z
        return points;
    },

    getNodeToMDFControls: function(node) {
        if (!node) {
            return null;
        }
        var controls = [];
        var rackNode = this.getRackNodeByNode(node);
        var nodeBb = node.getBoundingBox();
        var nodeWorldPosition = node.getWorldPosition();
        var frontDistance = 20;
        var backDistance = 10;
        var aboveRackDistance = 50;
        var belowRackDistance = -23;
        if (rackNode && rackNode != node) {
            var mdfNode = this.getMdfByRack(rackNode);
            var rackbb = rackNode.getBoundingBox();
            var w_r_from = rackNode.getWorldPosition();
            var pos1 = node.frontWorldPosition(nodeBb.max.z + frontDistance);
            var nodePos = node.getWorldPosition();
            controls.push(pos1); //
            var f_pos = pos1.clone();
            // f_pos.setY(w_r_from.y + rackbb.max.y + topDistance);// 
            f_pos.setY(w_r_from.y + rackbb.max.y + belowRackDistance); // topDistance
            controls.push(f_pos);
            var topOffset = new mono.Vec3(0, rackbb.max.y + belowRackDistance, 0);
            if (pos1.x != nodePos.x) {
                if (pos1.x > nodePos.x) {
                    topOffset.x = -backDistance - 10;
                } else {
                    topOffset.x = backDistance + 10;
                }
            }
            if (pos1.z != nodePos.z) {
                if (pos1.z > nodePos.z) {
                    topOffset.z = -backDistance - 10;
                } else {
                    topOffset.z = backDistance + 10;
                }
            }
            f_pos = nodeWorldPosition.clone().add(topOffset);
            f_pos.setY(w_r_from.y + rackbb.max.y + belowRackDistance);

            controls.push(f_pos); //
            // 
            if (mdfNode) {
                var mdfAbsoluteRotationY = mdfNode.getParent().getRotationY() * 180 / Math.PI;
                var offX = 20 * Math.random(),
                    offZ = 0;
                if (mdfAbsoluteRotationY % 90 == 0) {
                    offZ = 20 * Math.random();
                    offX = 0;
                }
                var mdfOffsetPos = new mono.Vec3(offX, 5, offZ); // 
                var mdfPos = mdfNode.getWorldPosition().clone().add(mdfOffsetPos);
                var mdfFrontPos = mdfNode.frontWorldPosition(frontDistance); //
                var backPos = f_pos.clone();
                if (mdfFrontPos.x != mdfPos.x && mdfPos.z != backPos.z) {
                    backPos.setZ(mdfPos.z);
                    controls.push(backPos);
                } else if (mdfFrontPos.z != mdfPos.z && mdfPos.x != backPos.x) {
                    backPos.setX(mdfPos.x);
                    controls.push(backPos);
                }
                var backTopPos = backPos.clone();
                backTopPos.setY(mdfPos.y);
                controls.push(backTopPos); //

                mdfFrontPos = mdfFrontPos.clone().add(mdfOffsetPos);

                var top2MdfPoints = this.getInflectionPoints(backTopPos, mdfPos);
                if (top2MdfPoints && top2MdfPoints.length > 0) {
                    for (var i = 0; i < top2MdfPoints.length; i++) {
                        controls.push(top2MdfPoints[i]);
                    }
                }
                controls.push(mdfFrontPos);
                mdfFrontPos = mdfFrontPos.clone().add(new mono.Vec3(0, aboveRackDistance, 0)); //
                controls.push(mdfFrontPos);
            } else {
                f_pos = f_pos.clone().add(new mono.Vec3(0, 43, 0)); //100
                controls.push(f_pos);
            }
        } else {
            var tPos = rackNode.getWorldPosition().clone().add(new mono.Vec3(0, nodeBb.max.y + 43, 0)); //100
            controls.push(tPos);
        }
        return controls;
    },


    /**
     * 
     * floor 
     *
     */
    generateControlsWithOutHeight: function(linkNode, height) {
        if (!linkNode) {
            return null;
        }
        var fromNode = linkNode.getFromNode();
        var toNode = linkNode.getToNode();
        if (!fromNode || !toNode) {
            return null;
        }
        var bb1 = fromNode.getBoundingBox(),
            bb2 = toNode.getBoundingBox();
        var w_from = fromNode.getWorldPosition();
        var w_to = toNode.getWorldPosition();
        var w_r_from = null,
            w_r_to = null; // 
        var frNode = this.getRackNodeByNode(fromNode);
        var trNode = this.getRackNodeByNode(toNode);
        if (frNode && frNode.getBoundingBox) {
            bb1 = frNode.getBoundingBox();
            w_r_from = frNode.getWorldPosition();
        }
        if (trNode && trNode.getBoundingBox) {
            bb2 = trNode.getBoundingBox();
            w_r_to = trNode.getWorldPosition();
        }
        var maxZ = 20,
            maxY = Math.max(bb1.max.y, bb2.max.y) + 20;
        if (maxY < 50) {
            maxY = 50;
        }
        // var pos1 = fromNode.frontWorldPosition(bb1.max.z + maxZ);
        var pos1 = fromNode.worldPosition(new mono.Vec3(0, 0, -1), bb1.max.z + maxZ); //
        var pos2 = toNode.frontWorldPosition(bb2.max.z + maxZ); //
        // var pos2 = toNode.worldPosition(new mono.Vec3(0,0,-1),bb2.max.z + maxZ);

        var controls = [];
        controls.push(pos1);
        // var f_pos = pos1.clone().add(new mono.Vec3(0,maxY,0));
        // if (w_r_from) {
        //     f_pos.setY(w_r_from.y + maxY);
        // }
        // controls.push(f_pos);
        // f_pos = w_from.clone().add(new mono.Vec3(0,maxY,0)); 
        // if (w_r_from) {
        // f_pos.setX(w_r_from.x);
        // f_pos.setY(w_r_from.y + maxY);
        // }
        // controls.push(f_pos); //

        var w_max_y = Math.max(w_from.y, w_to.y);
        if (w_r_from) {
            w_max_y = Math.max(w_max_y, w_r_from.y);
        }
        if (w_r_to) {
            w_max_y = Math.max(w_max_y, w_r_to.y);
        }
        if (w_max_y != pos1.y) {
            controls.push(new mono.Vec3(pos1.x, w_max_y, pos1.z));
        }
        controls.push(new mono.Vec3(pos1.x, w_max_y, pos2.z));
        if (w_max_y != pos2.y) {
            controls.push(new mono.Vec3(pos2.x, w_max_y, pos2.z));
        }

        // var t_pos = pos2.clone().add(new mono.Vec3(0,maxY,0));
        // if (w_r_to) {
        //     // t_pos.setX(w_r_to.x);
        //     t_pos.setY(w_r_to.y + maxY);
        //      var toTop = w_to.clone().add(new mono.Vec3(0,maxY,0));
        //      toTop.setY(w_r_to.y + maxY)
        //      controls.push(toTop); //
        // }else{
        //     controls.push(w_to.clone().add(new mono.Vec3(0,maxY,0))); //
        // }
        // controls.push(t_pos);
        controls.push(pos2);
        return controls;
    },

    /**
     * Link()
     * @param node
     * @param network
     * @param data
     * @param element
     * @param event
     */
    handleMouseMoveElement: function(node, network, data, element, event) {
        var link = this.sceneManager.getLinkData(node);
        if (!link) {
            return;
        }
        if (!node.org_radius && node.setRadius) { // 
            var radius = node.getRadius() || 1;
            node.org_radius = node.getRadius();
            node.setRadius(radius + 1);
        }
        this._flagLink = node;
    },

    handleMouseMoveBackground: function(network, event) {
        if (this._flagLink && this._flagLink.org_radius) {
            this._flagLink.setRadius(this._flagLink.org_radius);
            delete this._flagLink.org_radius;
            this._flagLink = null;
        }
    },

    /**
     * link
     * @param link link3Didit.Link
     * @param neg 
     */
    doFlow: function(link, neg) {
        if (!link) {
            return;
        }
        var linkNode = null;
        var id = link;
        if (link instanceof mono.Element) {
            linkNode = link;
            var linkData = this.sceneManager.getLinkData(linkNode);
            id = linkData.getId();
        } else {
            if (link instanceof it.Link) {
                id = link.getId();
            }
            linkNode = this.sceneManager.linkMap[id];
        }
        if (linkNode) {
            var flipx = true;
            if (neg == false) {
                flipx = false;
            }
            // linkNode.setStyle('m.texture.image','./images/link_flow.jpg');
            // linkNode.setStyle('m.texture.repeat',new mono.Vec2(100, 1));
            if (!linkNode.styleMap['m.texture.image']) {
                return;
            }
            linkNode.setStyle('m.texture.flipX', flipx);
            var animate = this.animates[id];
            if (!animate) {
                animate = new mono.Animate({
                    from: 0,
                    to: 1,
                    type: 'number',
                    dur: 500,
                    repeat: Number.POSITIVE_INFINITY,
                    reverse: false,
                    onUpdate: function(value) {
                        linkNode.setStyle('m.texture.offset', new mono.Vec2(value, 0));
                    }
                });
                this.animates[id] = animate;
            }
            animate.play();
        }
    },

    /**
     * 
     * @param linkOrId
     */
    clearFlow: function(linkOrId) {
        if (!linkOrId) {
            return;
        }
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var animate = this.animates[id];
        if (animate) {
            if (animate instanceof Array) {

            } else {
                animate.stop();
            }
            delete this.animates[id];
        }
    },

    /**
     * 
     */
    clearAllFlow: function() {
        // if (!this.animates) {
        //     return;
        // }
        // for (var id in this.animates) {
        //     var animate = this.animates[id];
        //     if (animate) {
        //         if (animate instanceof Array) {
        //         } else {
        //             animate.stop();
        //         }
        //         delete this.animates[id];
        //     }
        // }
        this.stopAllAnimates();
    },
    // animate, 

    /**
     * billboard
     */
    getImage: function() {
        return 'data:image/png;base64,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';
    },

    /**
     * billboard
     */
    createLightBillboard: function() {
        var billboard = new mono.Billboard();
        billboard.s({
            // 'm.texture.image': '../theme/models/light.png',
            'm.texture.image': this.getImage(),
            'm.transparent': true,
            'm.opacity': 1.0,
        });
        billboard.setScale(35, 35, 35);
        return billboard;
    },

    getAnimateDur: function() {
        return 2500;
    },

    /**
     * 
     */
    createLinkAnimate: function(lightBillboard, linkNode) {
        if (!lightBillboard || !linkNode) {
            return null;
        }
        if (!(linkNode instanceof mono.PathLink)) {
            return null;
        }
        var self = this;
        var animate = new mono.Animate({
            from: 0,
            to: 1,
            type: 'number',
            dur: self.getAnimateDur(),
            // repeat:Number.POSITIVE_INFINITY,
            // reverse: false,
            onUpdate: function(value) {
                // linkNode.setStyle('m.texture.offset', new mono.Vec2(value, 0));
                var position = linkNode.getPointAt(value);
                lightBillboard.p(position.x, position.y, position.z);
            }
        });
        return animate;
    },

    /**
     * 
     *  @links link
     *  links
     */
    playAnimateByLinks: function(links) {
        if (!links) {
            return;
        }
        if (!(links instanceof Array)) {
            return this.playAnimate(links);
        }
        if (links.length < 1) {
            return;
        }
        var bid = links[0].getId(); //idlightBillboard
        var lightBillboard = this.lightBillboardMap[bid];
        if (!lightBillboard) {
            lightBillboard = this.createLightBillboard();
            this.lightBillboardMap[bid] = lightBillboard;
        }
        var startAnimate = null,
            preAnimate = null,
            animates = [];
        for (var i = links.length - 1; i >= 0; i--) {
            var linkNode = this.sceneManager.linkMap[links[i].getId()];
            var animate = this.createLinkAnimate(lightBillboard, linkNode);
            if (!animate) {
                continue;
            }
            if (!startAnimate) {
                startAnimate = animate;
            }
            if (!preAnimate) {
                preAnimate = animate;
            } else {
                preAnimate.chain(animate);
                preAnimate = animate;
            }
            animates.push(animate);
        }
        if (preAnimate != startAnimate) {
            preAnimate.chain(startAnimate);
        }else{ // 
            if(!startAnimate){
                return;
            }
            startAnimate.repeat = Number.POSITIVE_INFINITY;
            startAnimate.reverse = false;
        }
        if (startAnimate) {
            this.box3D.add(lightBillboard);
            this.animates[bid] = animates;
            startAnimate.play();
        }
    },

    /**
     * 
     */
    playAnimate: function(link) {
        if (!link) {
            return;
        }
        if (link instanceof Array) {
            return this.playAnimateByLinks(link);
        }
        var bid = link.getId();
        var lightBillboard = this.lightBillboardMap[bid];
        if (!lightBillboard) {
            lightBillboard = this.createLightBillboard();
            this.lightBillboardMap[bid] = lightBillboard;
        }
        var self = this;
        var linkNode = this.sceneManager.linkMap[bid];
        if (!linkNode || !(linkNode instanceof mono.PathLink)) {
            return;
        }
        this.box3D.add(lightBillboard);
        var animate = new mono.Animate({
            from: 0,
            to: 1,
            type: 'number',
            dur: self.getAnimateDur(),
            repeat: Number.POSITIVE_INFINITY,
            reverse: false,
            onUpdate: function(value) {
                // linkNode.setStyle('m.texture.offset', new mono.Vec2(value, 0));
                var position = linkNode.getPointAt(value);
                lightBillboard.p(position.x, position.y, position.z);
            }
        });
        animate.play();
        this.animates[bid] = animate;
    }

});

it.GCSManager = $GCSManager;

/**
 *
 * 
 *   
 *
 */
var $LNode = function(dataId) {
    this.id = dataId || ''; // ID
    this.parent = null; //LNode
    this.parents = [];
    this.children = new mono.List(); // 
    this.toParentLink = null;
    this.toParentLinks = [];
};

mono.extend($LNode, Object, {

    setParent: function(parent) {
        this.parent = parent;
    },

    addChildren: function(datas) {
        if (!datas || datas.length < 1) {
            return;
        }
        for (var i = 0; i < datas.length; i++) {
            var data = datas[i];
            this.addChild(data);
        }
    },

    addChildren: function(child) {
        if (child && !this.children.contains(child)) {
            this.children.add(data); //list
        }
    },

});

var $LinkManager = function(sceneManager) {
    this.sceneManager = sceneManager;
    this.linkMap = null;
};

mono.extend($LinkManager, Object, {

    /**
     *
     * linklinksnn=
     *
     */
    computeLinkTree: function() {
        this.linkMap = {}; //
        var links = this.sceneManager.dataManager.getLinks();
        if (!links || links.length < 1) {
            return;
        }
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            if (!link) {
                continue;
            }
            var fId = link.getFromId();
            var tId = link.getToId();
            var fTreeData = this.linkMap[fId];
            var tTreeData = this.linkMap[tId];
            if (!fTreeData) {
                fTreeData = new $LNode(fId);
                fTreeData.parent = null;
                this.linkMap[fId] = fTreeData;
            }
            if (!tTreeData) {
                tTreeData = new $LNode(tId);
                tTreeData.toParentLink = link;
                tTreeData.parent = fTreeData;
                this.linkMap[tId] = tTreeData;
            }
             // fromto
            if (!tTreeData.parents.includes(fTreeData)) {
                tTreeData.parents.push(fTreeData);
            }
            tTreeData.toParentLinks.push(link);
        }
    },

    /**
     * 
     */
    setParentAndChildren: function(lNode) {
        if (!lNode) {
            return null;
        }
        var parentId = lNode.parent && lNode.parent.id;
        if (parentId) {
            var parentLNode = this.linkMap[parentId];
            if (parentLNode) {
                parentLNode.addChild(lNode);
            }
        }
        var children = this.getChildren(lNode.id);
        data.addChildren(children);
    },

    getChildren: function(pId) {
        var childArray = [];
        if (!pId) {
            return childArray;
        }
        for (var id in this.linkMap) {
            var lNode = this.linkMap[id];
            if (lNode.parent && lNode.parent.id === pId) {
                childArray.push(lNode);
            }
        }
        return childArray;
    },

    cloneArray : function(array){
        if (!array) {
            return [];
        }
        var newArray = [];
        for(var i = 0 ; i < array.length ; i++){
            newArray.push(array[i]);
        }
        return newArray;
    },

    /**
     * dataId
     * 1
     *      2
     */
    getMulLinksByDataId: function(dataOrId, objs, childLink, scope) {
        scope = scope || this;
        if (!dataOrId || !this.linkMap) {
            return null;
        }
        var dataId = dataOrId;
        if (dataOrId instanceof it.Data) {
            dataId = dataId.getId();
        }
        var lNode = this.linkMap[dataId];
        if (!lNode) {
            return null;
        }
        objs = objs || [];
        if (!childLink) {
           childLink = [];
           objs.push(childLink);
        }
        if (!lNode.toParentLinks || lNode.toParentLinks.length < 1) {
            return null;
        }
        if (lNode.toParentLinks.length > 1) {
            for (var i = 1; i < lNode.toParentLinks.length; i++) { //1
                var newChildLink = scope.cloneArray(childLink);
                var cLink = lNode.toParentLinks[i];
                if(newChildLink.includes(cLink)){ // 
                    continue;
                }
                objs.push(newChildLink);
                newChildLink.push(cLink);
                scope.getMulLinksByDataId(cLink.getFromId(), objs, newChildLink, scope);
            }
        }
        var cLink0 = lNode.toParentLinks[0];
        if(childLink.includes(cLink0)){ // 
            return objs;
        }
        // 0copylinks[0]
        childLink.push(cLink0);
        var parentId = cLink0.getFromId();
        if (parentId) {
            scope.getMulLinksByDataId(parentId, objs, childLink,scope);
        }
        return objs;
    },

    /**
     * dataId
     * 1
     */
    getLinksByDataId: function(dataOrId, scope) {
        scope = scope || this;
        if (!dataOrId || !this.linkMap) {
            return null;
        }
        var dataId = dataOrId;
        if (dataOrId instanceof it.Data) {
            dataId = dataId.getId();
        }
        var lNode = this.linkMap[dataId];
        if (!lNode) {
            return null;
        }
        var result = [];
        if (lNode.toParentLink) {
            result.push(lNode.toParentLink);
        }
        var ancestorLinks = scope.getLinksByDataId(lNode.parent && lNode.parent.id);
        if (ancestorLinks && ancestorLinks.length > 0) {
            for (var i = 0; i < ancestorLinks.length; i++) {
                result.push(ancestorLinks[i]);
            }
        }
        return result;
    },

});
/**
 * DataTooltip
 * sceneId 
 */
it.TooltipRule = function(parameters){
	parameters = parameters || {};
	this._id = parameters.id || this.randomId();
    this._customerId = parameters.customerId || ""; //
	this._categoryId = parameters.categoryId || "";
	this._dataTypeId = parameters.dataTypeId || "";
    this._sceneId = parameters.sceneId || ""; 
	this._propertiesDesc = parameters.propertiesDesc || "";
	this._extInfo = parameters.extInfo || {};
    this._mul = parameters.mul||false;
    this._withCloseDiv = parameters.withCloseDiv||false;//
};

mono.extend(it.TooltipRule,it.Base,{
    ___accessor:['customerId','categoryId','mul',"dataTypeId","sceneId","propertiesDesc",'extInfo','withCloseDiv'],
    getId : function(){
    	return this._id;
    },

    randomId : function(){
    	return mono.id("tooltipRule");
    },
});
it.TooltipManager = function (sceneManager) {
    this.sceneManager = sceneManager;
    this.dataManager = sceneManager.dataManager;
    this._tooltipRules = [];
    this._tooltipRuleMap = {};
    this._lastData = null;
    this._tooltipDivCreator = new it.TooltipDivCreator();
    this.tooltipContentFunction = null;
    this.toolTipMap = {}; //(tooltip)
    this.network3d = this.sceneManager.network3d;
    this.box3D = this.network3d.getDataBox();
    this.enableMulforTooltip = false; //(floors)tooltipflase
    this.textNodeMap = {};
    this.init();
};

mono.extend(it.TooltipManager, it.EventHandler, {

    init: function () {
        var self = this;

        //textNode
        this.sceneManager.addSceneManagerChangeListener(function (eve) {
            if (eve.kind == 'add' && (eve.data instanceof mono.Element)) {
                if (self.enableMulforTooltip) {
                    self.createToolTipForNode(eve.data);
                } else {
                    self.createTextNodeForFloor(eve.data);
                }
            }
        });

        //TestNode
        // this.sceneManager.addSceneChangeListener(function (ele) {
        //     self.sceneChangeListener();
        // });
        this.sceneManager.cameraManager.addAfterPlayCameraListener(function (ele) {
            self.sceneChangeListener();
        });

    },
    /**
     * TooltipDivCreator.js
     * 
     */
    _createTooltipDiv: function (id) {
        var tooltipDiv = this._tooltipDivCreator.createTooltipDiv(id);
        tooltipDiv.style.position = "absolute";
        tooltipDiv.style.display = "none";
        return tooltipDiv;
    },

    setTooltipDivCreator: function (value) {
        if (value == null) {
            return;
        }
        if (this._tooltipDivCreator !== value) {
            this._tooltipDivCreator = value;
            this.destoryTooltipDiv();
        }
    },

    getTooltipDivCreator: function () {
        return this._tooltipDivCreator;
    },

    destoryTooltipDiv: function () {
        this._tooltipDiv = null;
    },

    getTooltipDiv: function () {
        if (this._tooltipDiv == null) {
            this._tooltipDiv = this._createTooltipDiv();
            var network = this.sceneManager.network3d;
            this._tooltipDivCreator.addToNetwork(network, this._tooltipDiv);
        }
        return this._tooltipDiv;
    },

    hideToolTipDiv: function () {
        var tooltip = this.getTooltipDiv();
        tooltip.style.display = "none";
    },

    showTooltipDiv: function (content, data, node) {
        // this.hideToolTipDiv(); //add by Kevin 2017-06-14
        var tooltip = this.getTooltipDiv();
        tooltip.style.display = "";
        var withCloseDiv = false;
        if (content.tooltipRule && content.tooltipRule.getWithCloseDiv()) {
            withCloseDiv = content.tooltipRule.getWithCloseDiv();
        }
        this._tooltipDivCreator.setTooltipData(content, tooltip);
        if (withCloseDiv) {
            this.addCloseDivForTooltip(tooltip);
        }
        this.computeTooltipDivPosition(data,null, node);
    },

    addCloseDivForTooltip: function(tooltipDiv) {
        if (!tooltipDiv) {
            return;
        }
        var closeDiv = document.createElement('DIV');
        closeDiv.className = 'close';
        closeDiv.style = "float: right;";//position: static;
        var self = this;
        closeDiv.onclick = function(e) {
            tooltipDiv.style.display = "none";
            self._lastData = null;
        }
        tooltipDiv.appendChild(closeDiv);
        return closeDiv;
    },

    onRenderCallback: function (network) {
        this.computeTooltipDivPosition();
        if (this.enableMulforTooltip) {
            this.cameraChangeListener();
        }
    },

    /**
     * nodebillboardbillboard
     * @param node
     * @param x
     * @param y
     * @param z
     * @returns {TGL.Vec3}
     */
    generateTooltipPosition: function (node, x, y, z) {
        if (!node) {
            return new mono.Vec3(x, y, z);
        }
        var data = this.sceneManager.getNodeData(node);
        if (!data) {
            return new mono.Vec3(x, y, z);
        }
        var type = this.dataManager.getDataTypeForData(data);
        var category = this.dataManager.getCategoryForDataType(type);
        var position = node.getPosition();
        if (category && category.getId().indexOf('floor') >= 0) { //
            if (!data.getPosition()) return new mono.Vec3(x, y, z);
            var dataHeight = data.getPosition().y;
            var parent = this.dataManager.getDataById(data.getParentId());
            if (parent) {
                var children = parent.getChildren();
                if (children && children.size() > 0) {
                    var minY = 0, maxY = 0;
                    children.forEach(function (child) {
                        var y = child.getPosition().y;
                        if (y < minY) {
                            minY = y;
                        }
                        if (y > maxY) {
                            maxY = y;
                        }
                    });
                    if (minY != maxY) {
                        var x1, y1, z1;
                        var bb = node.getBoundingBox();
                        var dz = (bb.max.z - bb.min.z) / 2; //floorbillboard
                        z1 = position.z + dz;
                        var width = bb.max.x - bb.min.x;
                        var dw = width / (children.size() + 1);
                        x1 = parseInt((dataHeight - minY) / ((maxY - minY) / children.size())) * dw + dw / 2 - width / 2;
                        // y1 = position.y - 250;
                        y1 = position.y + (bb.max.y + bb.min.y) / 2 + bb.size().y / 2;
                        return new mono.Vec3(x1, y1, z1);
                    }
                }
            }
        }
        return new mono.Vec3(x, y, z);
    },

    computeTooltipDivPosition: function (data, tooltipDiv, targetNode) {
        var tooltip = tooltipDiv || this.getTooltipDiv();
        data = data || this._lastData;
        targetNode = targetNode || this._lastNode;
        if (!tooltip || !data) {
            return;
        }
        var sm = this.sceneManager;
        var node = sm.getNodeForDataOrId(data);
        node = this.getTooltipDivPositionNode(data, node, targetNode);
        var boundingBox = node.getBoundingBox?node.getBoundingBox():null;
        var position = node.getWorldPosition();
        // var x = position.x + boundingBox.center().x, y = position.y + boundingBox.max.y, z = position.z + boundingBox.center().z;
        var x = position.x,y = position.y , z = position.z;
        if (boundingBox) {
            x = x +  boundingBox.center().x;
            y = y +  boundingBox.max.y;
            z = z + boundingBox.center().z;
        };
        var newPos = this.generateTooltipPosition(node, x, y, z);
        if (newPos) {
            x = newPos.x || x;
            y = newPos.y || y;
            z = newPos.z || z;
        }
        var position2d = this.sceneManager.network3d.getViewPosition(new mono.Vec3(x, y, z)),
            offsetLeft = position2d.x,
            offsetTop = position2d.y;
        var style = $Util.getComputedStyle(tooltip);
        // Networkdivtopleft
        offsetLeft = offsetLeft - parseInt(style.width) / 2;
        offsetTop = offsetTop - parseInt(style.height) - 10;

        //tooltip
        //tip300,
        //
        var scrollBarWidth = getScrollBarWidth();
        var tooltipInnerWrapper = tooltip.children[0];
        if(parseInt(style.height) > 300){
            tooltipInnerWrapper.style.overflowY = 'auto';
            tooltipInnerWrapper.style.height = 300+'px';
            tooltip.style.top = position2d.y - 330 + "px";
            tooltip.style.left = offsetLeft - scrollBarWidth/2 + "px";
        }else{
            tooltip.style.top = offsetTop + "px";
            tooltip.style.left = offsetLeft + "px";
        }
        
        //
        function getScrollBarWidth(){
            var oP = document.createElement('p'),
            styles = {
                width: '100px',
                height: '100px',
            },
            cWidth1,cWidth2,sWidth;
            for(var i in styles){
                oP.style[i] = styles[i]
            };
            document.body.appendChild(oP);
            cWidth1 = oP.clientWidth;
            oP.style.overflowY = 'scroll';
            cWidth2 = oP.clientWidth;
            sWidth = cWidth1 - cWidth2;
            oP.remove();
            return sWidth;
        }

    },

    /**
     *  tooltip  node 
     * @param data  data
     * @param node  data  node
     * @param targetNode  node
     * @returns {*}
     */
    getTooltipDivPositionNode:function(data, node, targetNode){
        // return node||targetNode;
        // update by Kevin 2017-06-14 targetNodebillboardnodedc
        return targetNode || node;
    },

    getCustomerIdByNode: function (node) { //
        return '';
    },

    /**
     * nodetooltip
     * @param node
     * @param isMul ""div
     * @returns {*}
     *
     * nodetooltip
     *    tooltipContentFunction
     *    datagetDataFromNode"categoryId"(categoryId)
     *    id
     */
    getTooltipContent: function (node, isMul) {
        if (this.tooltipContentFunction) {
            return this.tooltipContentFunction(node);
        }
        if (!node) {
            return;
        }
        if (node instanceof mono.Billboard && node.getStyle('m.opacity') && node.getStyle('m.opacity') < 0.3) {
            return;
        }
        var customerId = '', categoryId = '', dataTypeId = '';
        if (this.getCustomerIdByNode) {
            customerId = this.getCustomerIdByNode(node);
        }
        var currentScene = this.sceneManager._currentScene;
        var sm = this.sceneManager;
        var dm = this.dataManager;
        var data = sm.getNodeData(node);
        if (data) {
            var category = dm.getCategoryForData(data);
            var dataType = dm.getDataTypeForData(data);
            if (dataType) {
                categoryId = category ? category.getId() : "";
                dataTypeId = dataType.getId();
            }
        }
        var matchCustomer, matchDataType, matchCategory, matchAll, i = 0, tooltipRule;
        for (; i < this._tooltipRules.length; i++) {
            tooltipRule = this._tooltipRules[i];
            if (isMul && !tooltipRule.getMul()) {
                continue;
            }
            if (!isMul && tooltipRule.getMul()) {
                continue;
            }
            if (currentScene 
                && tooltipRule.getSceneId() 
                && currentScene.getId() != tooltipRule.getSceneId()) { // rulesceneId
                continue;
            }
            if (tooltipRule.getCustomerId()
                && tooltipRule.getCustomerId() === customerId && !matchCustomer) {
                matchCustomer = tooltipRule;
            }
            if (tooltipRule.getDataTypeId()
                && tooltipRule.getDataTypeId() === dataTypeId && !matchDataType) {
                matchDataType = tooltipRule;
            }
            if (tooltipRule.getCategoryId()
                && tooltipRule.getCategoryId() === categoryId
                && !matchCategory) {
                matchCategory = tooltipRule;
            }
            if (!tooltipRule.getDataTypeId()
                && !tooltipRule.getCategoryId()
                && !tooltipRule.getCustomerId()) {
                matchAll = tooltipRule;
            }
        }
        if (matchCustomer) {
            return this._getTooltipContent(node, data, matchCustomer);
        } else if (matchDataType) {
            return this._getTooltipContent(node, data, matchDataType);
        } else if (matchCategory) {
            return this._getTooltipContent(node, data, matchCategory);
        } else if (matchAll) {
            return this._getTooltipContent(node, data, matchAll);
        }
    },

    _getDataFieldValue: function (node, data, field) {
        if (!data) {
            return "";
        }
        return data.getValue(field);
    },

    _getTooltipContent: function (node, data, tooltipRule) {
        var result = {};
        var propertiesDesc = tooltipRule.getPropertiesDesc();
        var propertiesDescArray = propertiesDesc.split("@@");
        if (propertiesDescArray.length) {
            for (var i = 0; i < propertiesDescArray.length; i++) {
                var propertyDesc = propertiesDescArray[i];
                var propertyDescArray = propertyDesc.split(":");
                if (propertyDescArray.length === 2) {
                    var label = propertyDescArray[0];
                    var field = propertyDescArray[1];
                    var value = this._getDataFieldValue(node, data, field);
                    result[label] = value || '';
                }
            }
        }
        var extInfo = tooltipRule.getExtInfo();
        if (typeof(extInfo) == 'function') {
            extInfo = extInfo(node, data);
        } else {
            extInfo = $Util.translateJson(extInfo);
        }
        if (extInfo instanceof Array) {
            // arraycolfunction
            extInfo.tooltipRule = tooltipRule;
            return extInfo;
        }else{
            if (extInfo) {
            for (var p in extInfo) {
                var info = extInfo[p];
                if (typeof(info) == 'function') {
                    result[p] = info(node, data);
                } else {
                    result[p] = info;
                }
            }
           }
           result.tooltipRule = tooltipRule;
           return result;
        }
    },

    addTooltipRule: function (tooltipRule) {
        var id = tooltipRule.getId();
        if (!this._tooltipRuleMap[id]) {
            this._tooltipRules.push(tooltipRule);
            this._tooltipRuleMap[id] = tooltipRule;
        }
    },

    removeTooltipRule: function (tooltipRule) {
        var id = tooltipRule.getId();
        if (this._tooltipRuleMap[id]) {
            var index = this._tooltipRules.indexOf(tooltipRule);
            if (index) {
                this._tooltipRules.splice(index, 1);
            }
            delete this._tooltipRuleMap[id];
        }
    },

    handleMouseMoveElement: function (node, network, data, element, event) {
        if (event._mousedown) {
            return;
        }
        var content = this.getTooltipContent(node);
        if (content == null) {
            this._lastData = null;
            this._lastNode = node;
            this.hideToolTipDiv();
            return;
        }
        var self = this;
        if (this._lastNode == node) {
            return;
        } else {
            clearTimeout(this._tooltipTimer);
            self._lastData = data;
            self._lastNode = node;
            this._tooltipTimer = setTimeout(function () {
               // self._lastData = data;
                self.showTooltipDiv(content, data, node);
            }, 200); //TODO 500 
        }
    },

    handleMouseMoveBackground: function (network, event) {
        this.hideToolTipDiv();
        this._lastData = null;
    },

    /**
     * tooltip
     */
    clearToolTipMap: function () {
        if (!this.toolTipMap) {
            return;
        }
        for (var id in this.toolTipMap) {
            var toolObj = this.toolTipMap[id];
            if (!toolObj) {
                continue;
            }
            $('#' + toolObj.id).remove();
        }
    },

    /**
     * ElementTooltiptooltipelement
     * tipElementelementtip
     * @param element
     */
    createToolTipForNode: function (element) {
        if (!element) {
            return;
        }
        var data = null;
        if (element instanceof it.Data) {
            data = element;
        } else {
            data = this.sceneManager.getNodeData(element);
        }
        if (!data) {
            return;
        }
        var content = this.getTooltipContent(element, true);
        if (!content) {
            return;
        }
        var id = "tooltip" + data.getId();
        var tipPane = null;
        if (this.toolTipMap[data.getId()]) {
            tipPane = document.getElementById(id);
        }else{
            this.toolTipMap[data.getId()] = {id: id, rule: content.tooltipRule,element:element};
            tipPane = this._createTooltipDiv(id);
            this._tooltipDivCreator.addToNetwork(this.sceneManager.network3d, tipPane);
        }
        if (tipPane) {
            tipPane.style.display = "block";
            var withCloseDiv = false;
            if (content.tooltipRule) { //setTooltipData contentrule
                withCloseDiv = content.tooltipRule.getWithCloseDiv();
            }
            this._tooltipDivCreator.setTooltipData(content, tipPane);
            if (withCloseDiv) {
                this.addCloseDivForTooltip(tooltip);
            }
            this.computeTooltipDivPosition(data, tipPane);
        }
    },

    //divtooltip
    cameraChangeListener: function () {
        if (!this.toolTipMap) {
            return;
        }
        for (var id in this.toolTipMap) {
            var toolObj = this.toolTipMap[id];
            var element = toolObj.element;
            if (!toolObj) {
                continue;
            }
            var tooltipId = toolObj.id;
            var rule = toolObj.rule;
            if (tooltipId.startsWith('tooltip')) {
                var id = tooltipId.substring(7, tooltipId.length);
                var data = this.dataManager.getDataById(id);
                var node = this.sceneManager.getNodeByDataOrId(data);
                if (!data || !node) {
                    continue;
                }
                var tipPane = document.getElementById(tooltipId);
                if (!tipPane) {
                    continue;
                }
                var currentScene = this.sceneManager.getCurrentScene();
                if (rule.getSceneId()
                    && currentScene
                    && rule.getSceneId() != currentScene.getId()) {
                    tipPane.style.display = "none";
                    continue;
                }
                // (node.isVisible())visibleFiltervisibleFilter,
                // viewManager
                if (!node
//                    || !node.isVisible()
                    || !this.sceneManager.viewManager3d.isVisible(node)
                    || !this.box3D.getDataById(node.getId())) { //nodetooltip
                    tipPane.style.display = "none";
                    continue;
                }
                tipPane.style.display = "";
                if (element) {
                    var content = this.getTooltipContent(element, true);
                    if (content) {
                        var withCloseDiv = rule.getWithCloseDiv();
                        this._tooltipDivCreator.setTooltipData(content, tipPane);
                        if (withCloseDiv) {
                            this.addCloseDivForTooltip(tooltip);
                        }
                    }
                }
                this.computeTooltipDivPosition(data, tipPane);
            }
        }
    },

    getRuleByData : function(dataOrId,isMul){
        if (!dataOrId) {
            return;
        }
        var sm = this.sceneManager;
        var dm = this.dataManager;
        var data = null;
        if(dataOrId instanceof it.Data){
            data = dataOrId
        }else if(dataOrId instanceof it.Link){
            data = dataOrId
        }else {
            data = dm.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        var category = dm.getCategoryForData(data);
        var dataType = dm.getDataTypeForData(data);
        if (dataType == null) {
            return;
        }
        var categoryId = category ? category.getId() : "";
        var dataTypeId = dataType.getId();
        var matchDataType, matchCategory, matchAll, i = 0, tooltipRule;
        for (; i < this._tooltipRules.length; i++) {
            tooltipRule = this._tooltipRules[i];
            if (isMul && !tooltipRule.getMul()) {
                continue;
            }
            if (!isMul && tooltipRule.getMul()) {
                continue;
            }
            if (tooltipRule.getDataTypeId() === dataTypeId && !matchDataType) {
                matchDataType = tooltipRule
            }
            if (categoryId && tooltipRule.getCategoryId() === categoryId && !matchCategory) {
                matchCategory = tooltipRule;
            }
            if (!tooltipRule.getDataTypeId() && !tooltipRule.getCategoryId()) {
                matchAll = tooltipRule;
            }
        }
        if (matchDataType) {
            return matchDataType;
        } else if (matchCategory) {
            return matchCategory;
        } else if (matchAll) {
            return matchAll;
        }
        return null;
    },

    computeTextNodePosition : function(node,fontLength){
        if(!node){
            return null;
        }
        var data = this.sceneManager.getNodeData(node);
        this.sceneManager.setParentRelationShip(data); // _sceneManagerChangeDispatcher
        this.sceneManager.translatePosition(data);
        var fontLength = fontLength || 0;
        var boundingBox = node.getBoundingBox();
        var nodeWorldPos = it.Util.getNodeCenterPosition(node);
        var x = nodeWorldPos.x;
        var y = nodeWorldPos.y;
        var z = nodeWorldPos.z;

        if(boundingBox){
            x = x + (boundingBox.max.x-boundingBox.min.x)/2 - fontLength;
            z = z + (boundingBox.max.z -boundingBox.min.z)/2+5;
        }
        var height = boundingBox.max.y - boundingBox.min.y;
        y = height/2;

        var pz = z+50; //50z
        //x,y,z()
        var obj = this.getElementsByPosition(x,y,pz);
        if(obj && obj.length > 0){
            var minDis = null;
            for (var i = 0; i < obj.length; i++) {
                var ele = obj[i];
                if (ele
//                    && this.sceneManager.getNodeData(ele) == data //nodedata==eledata
                    && ele.distance) {
                    if (!minDis || minDis > ele.distance) {
                        minDis = ele.distance;
                    }
                }
            }
            if (minDis) {
                z = pz - minDis;
            }
        }
        return {x: x, y: y, z: z};

    },

    // (1),direction.sub(origin)
    getElementsByPosition: function (x, y, z) {
        var origin = new mono.Vec3(x, y, z);
        var up = new mono.Vec3(0, 1, 0);
        var direction = new mono.Vec3(x, y, -1);
        var camera = this.network3d.getCamera();
//            var picking = new mono.Picking(origin,direction.normalize(), up);// 1.it is ok if origin is (0,0,0)
        var picking = new mono.Picking(origin, direction.sub(origin).normalize(), up, camera.getNear(), camera.getFar(), this.network3d);
        var intersects = new mono.List();
        intersects.addAll(this.box3D.getNodes());
//        intersects.addAll(network3d.getDataBox().getBillboards());
        var elements = picking.intersectObjects(intersects.toArray(), true, false);
        return elements;
    },


    /**
     * textNode
     * @param node
     * @returns {null}
     */
    getTextNodeOffset: function (node) {
        return null;
    },

    /**
     * label
     * @param element
     */
    createTextNodeForFloor: function (element) {
        if (!element) {
            return;
        }
        var data = null;
        if (element instanceof it.Data) {
            data = element;
        } else {
            data = this.sceneManager.getNodeData(element);
        }
        if (!data) {
            return;
        }
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (!category || category.getId().toLowerCase().indexOf('floor') < 0) {
            return;
        }
        var rule = this.getRuleByData(data, true);
        if (!rule) {
            return;
        }
        var label = data.getId();
        var textNode = this.textNodeMap[label];
        if (!textNode) {
            if (label) {
                var textNode = new mono.TextNode(label, null, 100, 'helvetiker', 'bold');
                textNode.setStyle('m.texture.image', '../images/yellow.png');
                textNode.setStyle('m.type', 'phong');
                var scale = 1;
                textNode.setScale(scale, scale, scale * 0.1);
                textNode.setSelectable(false);
                textNode.setParent(element);
                var boundingBox = element.getBoundingBox();
                var x = element.getPositionX();
                var z = element.getPositionZ();
                var y = element.getPositionY();
                var fontLength = 0;
                var fontHeight = 0;
                var tnBoundingBox = textNode.getBoundingBox();
                if (tnBoundingBox) {
                    fontLength = tnBoundingBox.max.x - tnBoundingBox.min.x;
                    fontHeight = tnBoundingBox.max.y - tnBoundingBox.min.y;
                }
//                var txtPos = this.computeTextNodePosition(element,fontLength);
                if (boundingBox) {
                    x = boundingBox.max.x - fontLength;
//                    z = boundingBox.max.z+10;
                    z = boundingBox.max.z + 5;
                }
                var height = boundingBox.max.y - boundingBox.min.y;
//                if(fontHeight){
//                    y = height+fontHeight-30;
//                }
                y = height / 2;

                var offset = this.getTextNodeOffset(data);
                if (offset) {
                    if (offset.x) {
                        x = x + offset.x;
                    }
                    if (offset.y) {
                        y = y + offset.y;
                    }
                }

                var pz = z + 50; //50z
                //x,y,z()
                var obj = this.getElementsByPosition(x, y, pz);
                if (obj && obj.length > 0) {
                    var minDis = null;
                    for (var i = 0; i < obj.length; i++) {
                        var ele = obj[i];
                        if (ele && ele.distance) {
                            if (!minDis || minDis > ele.distance) {
                                minDis = ele.distance;
                            }
                        }
                    }
                    if (minDis) {
                        z = pz - minDis;
                    }
                }

                if (offset && offset.z) {
                    if (offset.z) {
                        z = z + offset.z;
                    }
                }

                textNode.setPosition(x, y, z);
                this.textNodeMap[label] = textNode;
                textNode.setVisible(false);
                this.box3D.add(textNode);
                textNode.rule = rule;
            }
        }
    },

    sceneChangeListener: function () {
        if (this.textNodeMap) {
            for (var id in this.textNodeMap) {
                var textNode = this.textNodeMap[id];
                //rule
                var rule = textNode.rule;
                var currentScene = this.sceneManager.getCurrentScene();
                if (rule.getSceneId()
                    && currentScene
                    && rule.getSceneId() != currentScene.getId()) {
                    textNode.setVisible(false);
                    continue;
                }
                var node = this.sceneManager.getNodeByDataOrId(id);
                if (!node
//                    || !node.isVisible()
                    || !this.sceneManager.viewManager3d.isVisible(node)
                    || !this.box3D.getDataById(node.getId())) { //nodetooltip
                    textNode.setVisible(false);
                    continue;
                }
                if (!this.box3D.getDataById(textNode.getId())) {
                    this.box3D.add(textNode);
                }
                textNode.setVisible(true);
            }
        }

        //tooltiptooltipsceneChangetooltip
        if (this._tooltipTimer) {
            clearTimeout(this._tooltipTimer);
        }
        this.hideToolTipDiv();
    }


});
/**
 * TooltipDiv,tooltip.css.
 */
it.TooltipDivCreator = function (argument) {
};

mono.extend(it.TooltipDivCreator, Object, {
    createTooltipDiv: function (id) {
        var tooltipDiv = document.createElement('DIV');
        tooltipDiv.className = "tooltip-panel";
        if (id) {
            tooltipDiv.id = id;
        }
        return tooltipDiv
    },

    addToNetwork: function (network, tooltipDiv) {
        network.getRootView().appendChild(tooltipDiv);
    },

    setTooltipData: function(content, tooltipDiv) {

        //tootipstyle
        tooltipDiv.style = '';

        this._removeAllChildren(tooltipDiv);
        if (!content) return;
        delete content.tooltipRule;

        //tableWrapperdiv
        var tableWrapper = document.createElement('div');
        tooltipDiv.appendChild(tableWrapper);

        var table = document.createElement('table');
        var tbody = document.createElement('tbody');
        tableWrapper.appendChild(table);
        table.appendChild(tbody);
        if (content instanceof Array) { //
            var headerList = content.header;
            if (headerList) {
                var headerRow = this._createTableRow(headerList,true);
                tbody.appendChild(headerRow);
            }
            for(var i = 0 ; i < content.length ; i++){
                var rowData = content[i];
                var row = this._createTableRow(rowData);
                tbody.appendChild(row);
            }
        } else {
            for (var p in content) {
                if (typeof content[p] == 'object') {
                    var v = content[p].value;
                    var onclick = content[p].onclick;
                    var row = this._createRow(p, v, onclick);
                    tbody.appendChild(row);
                } else {
                    var row = this._createRow(p, content[p]);
                    tbody.appendChild(row);
                }
            }
        }
    },

    _createTableRow : function(rowData,isHeader){
        var row = document.createElement('tr');
        if (rowData instanceof Array) {
            for(var i = 0 ; i < rowData.length ; i++){
                var data = rowData[i];
                var col = this._createColumn(data,isHeader);
                row.appendChild(col);
            }
        }else {
            for(var p in rowData){
                var data = rowData[p];
                var col = this._createColumn(data,isHeader);
                row.appendChild(col);
            }
        }
        return row;
    },

    _createColumn : function(data,isHeader){
        var column = document.createElement('td');
        if (isHeader) {
            // column.className = "tooltip-key";
            column.style = "width: 60px;text-align:center;";
        }else{
            column.className = "tooltip-value";
            column.style = "text-align:center;";
        }
        if (data.className) {
            column.className = data.className;
        }
        if (data.style) {
            column.style = data.style;
        }
        var text = data;
        if (data.hasOwnProperty('value')) {
            text = data.value;
        }else if(data.hasOwnProperty('text')){
            text = data.text;
        }
        if (data.onclick) {
            column.onclick = data.onclick;
        }
        column.innerHTML = text;
        return column;
    },

    _createRow: function (key, value, onclick) {
        var row = document.createElement('tr');
        var columnKey = document.createElement('td');
        columnKey.className = "tooltip-key";
        columnKey.innerHTML = key + ":";
        var columnValue = document.createElement('td');
        var cn = "tooltip-value";
        if(onclick){
            cn += ' tooltip-value-btn'
        }
        columnValue.className = cn;
        columnValue.innerHTML = value;
        row.appendChild(columnKey);
        row.appendChild(columnValue);
        columnValue.onclick = onclick;
        return row;
    },

    _removeAllChildren: function (node) {
        while (node.hasChildNodes()) {
            node.removeChild(node.lastChild);
        }
    },
});

(function(window){
    var Framebuffer, Heights, Node, Shader, Texture, WebGLHeatmap, fragmentShaderBlit, nukeVendorPrefix, textureFloatShims, vertexShaderBlit,
        __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    nukeVendorPrefix = function () {
        var getExtension, getSupportedExtensions, vendorRe, vendors;
        if (window.WebGLRenderingContext != null) {
            vendors = ['WEBKIT', 'MOZ', 'MS', 'O'];
            vendorRe = /^WEBKIT_(.*)|MOZ_(.*)|MS_(.*)|O_(.*)/;
            getExtension = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function (name) {
                var extobj, match, vendor, _i, _len;
                match = name.match(vendorRe);
                if (match !== null) {
                    name = match[1];
                }
                extobj = getExtension.call(this, name);
                if (extobj === null) {
                    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
                        vendor = vendors[_i];
                        extobj = getExtension.call(this, vendor + '_' + name);
                        if (extobj !== null) {
                            return extobj;
                        }
                    }
                    return null;
                } else {
                    return extobj;
                }
            };
            getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            return WebGLRenderingContext.prototype.getSupportedExtensions = function () {
                var extension, match, result, supported, _i, _len;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_i = 0, _len = supported.length; _i < _len; _i++) {
                    extension = supported[_i];
                    match = extension.match(vendorRe);
                    if (match !== null) {
                        extension = match[1];
                    }
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
        }
    };

    textureFloatShims = function () {
        var checkColorBuffer, checkFloatLinear, checkSupport, checkTexture, createSourceCanvas, getExtension, getSupportedExtensions, name, shimExtensions, shimLookup, unshimExtensions, unshimLookup, _i, _len;
        createSourceCanvas = function () {
            var canvas, ctx, imageData;
            canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;
            ctx = canvas.getContext('2d');
            imageData = ctx.getImageData(0, 0, 2, 2);
            imageData.data.set(new Uint8ClampedArray([0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]));
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };
        createSourceCanvas();
        checkFloatLinear = function (gl, sourceType) {
            var buffer, cleanup, fragmentShader, framebuffer, positionLoc, program, readBuffer, result, source, sourceCanvas, sourceLoc, target, vertexShader, vertices;
            program = gl.createProgram();
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.attachShader(program, vertexShader);
            gl.shaderSource(vertexShader, 'attribute vec2 position;\nvoid main(){\n    gl_Position = vec4(position, 0.0, 1.0);\n}');
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(vertexShader);
            }
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.attachShader(program, fragmentShader);
            gl.shaderSource(fragmentShader, 'uniform sampler2D source;\nvoid main(){\n    gl_FragColor = texture2D(source, vec2(1.0, 1.0));\n}');
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(fragmentShader);
            }
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw gl.getProgramInfoLog(program);
            }
            gl.useProgram(program);
            cleanup = function () {
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteProgram(program);
                gl.deleteBuffer(buffer);
                gl.deleteTexture(source);
                gl.deleteTexture(target);
                gl.deleteFramebuffer(framebuffer);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            };
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            sourceCanvas = createSourceCanvas();
            source = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, source);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, sourceType, sourceCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            positionLoc = gl.getAttribLocation(program, 'position');
            sourceLoc = gl.getUniformLocation(program, 'source');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform1i(sourceLoc, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            readBuffer = new Uint8Array(4 * 4);
            gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.UNSIGNED_BYTE, readBuffer);
            result = Math.abs(readBuffer[0] - 127) < 10;
            cleanup();
            return result;
        };
        checkTexture = function (gl, targetType) {
            var target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            if (gl.getError() === 0) {
                gl.deleteTexture(target);
                return true;
            } else {
                gl.deleteTexture(target);
                return false;
            }
        };
        checkColorBuffer = function (gl, targetType) {
            var check, framebuffer, target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.deleteTexture(target);
            gl.deleteFramebuffer(framebuffer);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (check === gl.FRAMEBUFFER_COMPLETE) {
                return true;
            } else {
                return false;
            }
        };
        shimExtensions = [];
        shimLookup = {};
        unshimExtensions = [];
        checkSupport = function () {
            var canvas, extobj, gl, halfFloatExt, halfFloatTexturing, singleFloatExt, singleFloatTexturing;
            canvas = document.createElement('canvas');
            gl = null;
            try {
                gl = canvas.getContext('experimental-webgl');
                if (gl === null) {
                    gl = canvas.getContext('webgl');
                }
            } catch (_error) {
            }
            if (gl != null) {
                singleFloatExt = gl.getExtension('OES_texture_float');
                if (singleFloatExt === null) {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                        shimLookup.OES_texture_float = {
                            shim: true
                        };
                    } else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                } else {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                    } else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                }
                if (singleFloatTexturing) {
                    extobj = gl.getExtension('WEBGL_color_buffer_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                            shimLookup.WEBGL_color_buffer_float = {
                                shim: true,
                                RGBA32F_EXT: 0x8814,
                                RGB32F_EXT: 0x8815,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        } else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    } else {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                        } else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                            shimLookup.OES_texture_float_linear = {
                                shim: true
                            };
                        } else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    } else {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                        } else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    }
                }
                halfFloatExt = gl.getExtension('OES_texture_half_float');
                if (halfFloatExt === null) {
                    if (checkTexture(gl, 0x8D61)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                        halfFloatExt = shimLookup.OES_texture_half_float = {
                            HALF_FLOAT_OES: 0x8D61,
                            shim: true
                        };
                    } else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                } else {
                    if (checkTexture(gl, halfFloatExt.HALF_FLOAT_OES)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                    } else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                }
                if (halfFloatTexturing) {
                    extobj = gl.getExtension('EXT_color_buffer_half_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                            shimLookup.EXT_color_buffer_half_float = {
                                shim: true,
                                RGBA16F_EXT: 0x881A,
                                RGB16F_EXT: 0x881B,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        } else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    } else {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                        } else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_half_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('OES_texture_half_float_linear');
                            return shimLookup.OES_texture_half_float_linear = {
                                shim: true
                            };
                        } else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    } else {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            return shimExtensions.push('OES_texture_half_float_linear');
                        } else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    }
                }
            }
        };
        if (window.WebGLRenderingContext != null) {
            checkSupport();
            unshimLookup = {};
            for (_i = 0, _len = unshimExtensions.length; _i < _len; _i++) {
                name = unshimExtensions[_i];
                unshimLookup[name] = true;
            }
            getExtension = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function (name) {
                var extobj;
                extobj = shimLookup[name];
                if (extobj === void 0) {
                    if (unshimLookup[name]) {
                        return null;
                    } else {
                        return getExtension.call(this, name);
                    }
                } else {
                    return extobj;
                }
            };
            getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            WebGLRenderingContext.prototype.getSupportedExtensions = function () {
                var extension, result, supported, _j, _k, _len1, _len2;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_j = 0, _len1 = supported.length; _j < _len1; _j++) {
                    extension = supported[_j];
                    if (unshimLookup[extension] === void 0) {
                        result.push(extension);
                    }
                }
                for (_k = 0, _len2 = shimExtensions.length; _k < _len2; _k++) {
                    extension = shimExtensions[_k];
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
            return WebGLRenderingContext.prototype.getFloatExtension = function (spec) {
                var candidate, candidates, half, halfFramebuffer, halfLinear, halfTexture, i, importance, preference, result, single, singleFramebuffer, singleLinear, singleTexture, use, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
                if (spec.prefer == null) {
                    spec.prefer = ['half'];
                }
                if (spec.require == null) {
                    spec.require = [];
                }
                if (spec.throws == null) {
                    spec.throws = true;
                }
                singleTexture = this.getExtension('OES_texture_float');
                halfTexture = this.getExtension('OES_texture_half_float');
                singleFramebuffer = this.getExtension('WEBGL_color_buffer_float');
                halfFramebuffer = this.getExtension('EXT_color_buffer_half_float');
                singleLinear = this.getExtension('OES_texture_float_linear');
                halfLinear = this.getExtension('OES_texture_half_float_linear');
                single = {
                    texture: singleTexture !== null,
                    filterable: singleLinear !== null,
                    renderable: singleFramebuffer !== null,
                    score: 0,
                    precision: 'single',
                    half: false,
                    single: true,
                    type: this.FLOAT
                };
                half = {
                    texture: halfTexture !== null,
                    filterable: halfLinear !== null,
                    renderable: halfFramebuffer !== null,
                    score: 0,
                    precision: 'half',
                    half: true,
                    single: false,
                    type: (_ref = halfTexture != null ? halfTexture.HALF_FLOAT_OES : void 0) != null ? _ref : null
                };
                candidates = [];
                if (single.texture) {
                    candidates.push(single);
                }
                if (half.texture) {
                    candidates.push(half);
                }
                result = [];
                for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                    candidate = candidates[_j];
                    use = true;
                    _ref1 = spec.require;
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                        name = _ref1[_k];
                        if (candidate[name] === false) {
                            use = false;
                        }
                    }
                    if (use) {
                        result.push(candidate);
                    }
                }
                for (_l = 0, _len3 = result.length; _l < _len3; _l++) {
                    candidate = result[_l];
                    _ref2 = spec.prefer;
                    for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
                        preference = _ref2[i];
                        importance = Math.pow(2, spec.prefer.length - i - 1);
                        if (candidate[preference]) {
                            candidate.score += importance;
                        }
                    }
                }
                result.sort(function (a, b) {
                    if (a.score === b.score) {
                        return 0;
                    } else if (a.score < b.score) {
                        return 1;
                    } else if (a.score > b.score) {
                        return -1;
                    }
                });
                if (result.length === 0) {
                    if (spec.throws) {
                        throw 'No floating point texture support that is ' + spec.require.join(', ');
                    } else {
                        return null;
                    }
                } else {
                    result = result[0];
                    return {
                        filterable: result.filterable,
                        renderable: result.renderable,
                        type: result.type,
                        precision: result.precision
                    };
                }
            };
        }
    };

    nukeVendorPrefix();

    textureFloatShims();

    Shader = (function () {
        function Shader(gl, _arg) {
            var fragment, vertex;
            this.gl = gl;
            vertex = _arg.vertex, fragment = _arg.fragment;
            this.program = this.gl.createProgram();
            this.vs = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
            this.gl.attachShader(this.program, this.vs);
            this.gl.attachShader(this.program, this.fs);
            this.compileShader(this.vs, vertex);
            this.compileShader(this.fs, fragment);
            this.link();
            this.value_cache = {};
            this.uniform_cache = {};
            this.attribCache = {};
        }

        Shader.prototype.attribLocation = function (name) {
            var location;
            location = this.attribCache[name];
            if (location === void 0) {
                location = this.attribCache[name] = this.gl.getAttribLocation(this.program, name);
            }
            return location;
        };

        Shader.prototype.compileShader = function (shader, source) {
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                throw "Shader Compile Error: " + (this.gl.getShaderInfoLog(shader));
            }
        };

        Shader.prototype.link = function () {
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                throw "Shader Link Error: " + (this.gl.getProgramInfoLog(this.program));
            }
        };

        Shader.prototype.use = function () {
            this.gl.useProgram(this.program);
            return this;
        };

        Shader.prototype.uniformLoc = function (name) {
            var location;
            location = this.uniform_cache[name];
            if (location === void 0) {
                location = this.uniform_cache[name] = this.gl.getUniformLocation(this.program, name);
            }
            return location;
        };

        Shader.prototype.int = function (name, value) {
            var cached, loc;
            cached = this.value_cache[name];
            if (cached !== value) {
                this.value_cache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1i(loc, value);
                }
            }
            return this;
        };

        Shader.prototype.vec2 = function (name, a, b) {
            var loc;
            loc = this.uniformLoc(name);
            if (loc) {
                this.gl.uniform2f(loc, a, b);
            }
            return this;
        };

        Shader.prototype.float = function (name, value) {
            var cached, loc;
            cached = this.value_cache[name];
            if (cached !== value) {
                this.value_cache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1f(loc, value);
                }
            }
            return this;
        };

        return Shader;

    })();

    Framebuffer = (function () {
        function Framebuffer(gl) {
            this.gl = gl;
            this.buffer = this.gl.createFramebuffer();
        }

        Framebuffer.prototype.destroy = function () {
            return this.gl.deleteFRamebuffer(this.buffer);
        };

        Framebuffer.prototype.bind = function () {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer);
            return this;
        };

        Framebuffer.prototype.unbind = function () {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            return this;
        };

        Framebuffer.prototype.check = function () {
            var result;
            result = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
            switch (result) {
                case this.gl.FRAMEBUFFER_UNSUPPORTED:
                    throw 'Framebuffer is unsupported';
                    break;
                case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    throw 'Framebuffer incomplete attachment';
                    break;
                case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    throw 'Framebuffer incomplete dimensions';
                    break;
                case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    throw 'Framebuffer incomplete missing attachment';
            }
            return this;
        };

        Framebuffer.prototype.color = function (texture) {
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, texture.target, texture.handle, 0);
            this.check();
            return this;
        };

        Framebuffer.prototype.depth = function (buffer) {
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, buffer.id);
            this.check();
            return this;
        };

        Framebuffer.prototype.destroy = function () {
            return this.gl.deleteFramebuffer(this.buffer);
        };

        return Framebuffer;

    })();

    Texture = (function () {
        function Texture(gl, params) {
            var _ref, _ref1;
            this.gl = gl;
            if (params == null) {
                params = {};
            }
            this.channels = this.gl[((_ref = params.channels) != null ? _ref : 'rgba').toUpperCase()];
            if (typeof params.type === 'number') {
                this.type = params.type;
            } else {
                this.type = this.gl[((_ref1 = params.type) != null ? _ref1 : 'unsigned_byte').toUpperCase()];
            }
            switch (this.channels) {
                case this.gl.RGBA:
                    this.chancount = 4;
                    break;
                case this.gl.RGB:
                    this.chancount = 3;
                    break;
                case this.gl.LUMINANCE_ALPHA:
                    this.chancount = 2;
                    break;
                default:
                    this.chancount = 1;
            }
            this.target = this.gl.TEXTURE_2D;
            this.handle = this.gl.createTexture();
        }

        Texture.prototype.destroy = function () {
            return this.gl.deleteTexture(this.handle);
        };

        Texture.prototype.bind = function (unit) {
            if (unit == null) {
                unit = 0;
            }
            if (unit > 15) {
                throw 'Texture unit too large: ' + unit;
            }
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
            this.gl.bindTexture(this.target, this.handle);
            return this;
        };

        Texture.prototype.setSize = function (width, height) {
            this.width = width;
            this.height = height;
            this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, null);
            return this;
        };

        Texture.prototype.upload = function (data) {
            this.width = data.width;
            this.height = data.height;
            this.gl.texImage2D(this.target, 0, this.channels, this.channels, this.type, data);
            return this;
        };

        Texture.prototype.linear = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            return this;
        };

        Texture.prototype.nearest = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            return this;
        };

        Texture.prototype.clampToEdge = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            return this;
        };

        Texture.prototype.repeat = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
            return this;
        };

        return Texture;

    })();

    Node = (function () {
        function Node(gl, width, height) {
            var floatExt;
            this.gl = gl;
            this.width = width;
            this.height = height;
            floatExt = this.gl.getFloatExtension({
                require: ['renderable']
            });
            this.texture = new Texture(this.gl, {
                type: floatExt.type
            }).bind(0).setSize(this.width, this.height).nearest().clampToEdge();
            this.fbo = new Framebuffer(this.gl).bind().color(this.texture).unbind();
        }

        Node.prototype.use = function () {
            return this.fbo.bind();
        };

        Node.prototype.bind = function (unit) {
            return this.texture.bind(unit);
        };

        Node.prototype.end = function () {
            return this.fbo.unbind();
        };

        Node.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
            return this.texture.bind(0).setSize(this.width, this.height);
        };

        return Node;

    })();

    vertexShaderBlit = 'attribute vec4 position;\n' +
        'varying vec2 texcoord;\n' +
        'void main(){\n' +
        '    texcoord = position.xy*0.5+0.5;\n' +
        '    gl_Position = position;\n' +
        '}';

    fragmentShaderBlit = '#ifdef GL_FRAGMENT_PRECISION_HIGH\n    ' +
        '  precision highp int;\n' +
        '    precision highp float;\n' +
        '#else\n' +
        '    precision mediump int;\n' +
        '    precision mediump float;\n' +
        '#endif\n' +
        'uniform sampler2D source;\n' +
        'varying vec2 texcoord;';

    Heights = (function () {
        function Heights(heatmap, gl, width, height) {
            var i, _i, _ref;
            this.heatmap = heatmap;
            this.gl = gl;
            this.width = width;
            this.height = height;
            this.shader = new Shader(this.gl, {
                vertex: 'attribute vec4 position, intensity;\nvarying vec2 off, dim;\nvarying float vIntensity;\nuniform vec2 viewport;\n\nvoid main(){\n    dim = abs(position.zw);\n' +
                    '    off = position.zw;\n    vec2 pos = position.xy + position.zw;\n   ' +
//                    ' off = vec2(-25,25);\n ' +
//                    'dim=vec2(20,50);\n ' +
                    ' vIntensity = intensity.x;\n    gl_Position = vec4((pos/viewport)*2.0-1.0, 0.0, 1.0);\n}',
                fragment: '#ifdef GL_FRAGMENT_PRECISION_HIGH\n   ' +
                    ' precision highp int;\n   ' +
                    ' precision highp float;\n#else\n   ' +
                    ' precision mediump int;\n   ' +
                    ' precision mediump float;\n#endif\n' +
                    ' varying vec2 off, dim;\n' +
                    ' varying float vIntensity;\nvoid main(){\n  ' +
                    '  float falloff = (1.0 - smoothstep(0.0, 1.0, length(off/dim)));\n  ' +
//                    '  falloff = 0.3; \n' +
                    '  float intensity = falloff*vIntensity;\n   ' +
//                    '  float intensity = vIntensity;\n   ' +
                    '  gl_FragColor = vec4(intensity,0.0,0,1.0);\n' +
                    ' }'
            });
            this.clampShader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + 'uniform float low, high;\nvoid main(){\n    gl_FragColor = vec4(clamp(texture2D(source, texcoord).rgb, low, high), 1.0);\n}'
            });
            this.multiplyShader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + 'uniform float value;\nvoid main(){\n    gl_FragColor = vec4(texture2D(source, texcoord).rgb*value, 1.0);\n}'
            });
            this.blurShader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + 'uniform vec2 viewport;\nvoid main(){\n    vec4 result = vec4(0.0);\n    for(int x=-1; x<=1; x++){\n        for(int y=-1; y<=1; y++){\n            vec2 off = vec2(x,y)/viewport;\n            //float factor = 1.0 - smoothstep(0.0, 1.5, length(off));\n            float factor = 1.0;\n            result += vec4(texture2D(source, texcoord+off).rgb*factor, factor);\n        }\n    }\n    gl_FragColor = vec4(result.rgb/result.w, 1.0);\n}'
            });
            this.nodeBack = new Node(this.gl, this.width, this.height);
            this.nodeFront = new Node(this.gl, this.width, this.height);
            this.vertexBuffer = this.gl.createBuffer();
            this.vertexSize = 8;
            this.maxPointCount = 1024 * 10;
            this.vertexBufferData = new Float32Array(this.maxPointCount * this.vertexSize * 6);
            this.vertexBufferViews = [];
            for (i = _i = 0, _ref = this.maxPointCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                this.vertexBufferViews.push(new Float32Array(this.vertexBufferData.buffer, 0, i * this.vertexSize * 6));
            }
            this.bufferIndex = 0;
            this.pointCount = 0;
        }

        Heights.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
            this.nodeBack.resize(this.width, this.height);
            return this.nodeFront.resize(this.width, this.height);
        };

        Heights.prototype.update = function () {
            var intensityLoc, positionLoc;
            if (this.pointCount > 0) {
                this.gl.enable(this.gl.BLEND);
                this.nodeFront.use();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertexBufferViews[this.pointCount], this.gl.STREAM_DRAW);
                positionLoc = this.shader.attribLocation('position');
                intensityLoc = this.shader.attribLocation('intensity');
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(positionLoc, 4, this.gl.FLOAT, false, 8 * 4, 0 * 4);
                this.gl.vertexAttribPointer(intensityLoc, 4, this.gl.FLOAT, false, 8 * 4, 4 * 4);
                this.shader.use().vec2('viewport', this.width, this.height);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, this.pointCount * 6);
                this.gl.disableVertexAttribArray(1);
                this.pointCount = 0;
                this.bufferIndex = 0;
                this.nodeFront.end();
                return this.gl.disable(this.gl.BLEND);
            }
        };

        Heights.prototype.clear = function () {
            this.nodeFront.use();
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            return this.nodeFront.end();
        };

        Heights.prototype.clamp = function (min, max) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.clampShader.use().int('source', 0).float('low', min).float('high', max);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        };

        Heights.prototype.multiply = function (value) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.multiplyShader.use().int('source', 0).float('value', value);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        };

        Heights.prototype.blur = function () {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.blurShader.use().int('source', 0).vec2('viewport', this.width, this.height);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        };

        Heights.prototype.swap = function () {
            var tmp;
            tmp = this.nodeFront;
            this.nodeFront = this.nodeBack;
            return this.nodeBack = tmp;
        };

        Heights.prototype.addVertex = function (x, y, xs, ys, intensity) {
            this.vertexBufferData[this.bufferIndex++] = x;
            this.vertexBufferData[this.bufferIndex++] = y;
            this.vertexBufferData[this.bufferIndex++] = xs;
            this.vertexBufferData[this.bufferIndex++] = ys;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            return this.vertexBufferData[this.bufferIndex++] = intensity;
        };

        Heights.prototype.addPoint = function (x, y, size, intensity) {
            var s1, s2;
            if (size == null) {
                size = 50;
            }
            if (intensity == null) {
                intensity = 0.2;
            }
            if (this.pointCount >= this.maxPointCount - 1) {
                this.update();
            }
            y = this.height - y;
            s1 = size / 2;
            s2 = size / 2;
//            s1 = 25;
            this.addVertex(x, y, -s1, -s2, intensity);
            this.addVertex(x, y, +s1, -s2, intensity);
            this.addVertex(x, y, -s1, +s2, intensity);
            this.addVertex(x, y, -s1, +s2, intensity);
            this.addVertex(x, y, +s1, -s2, intensity);
            this.addVertex(x, y, +s1, +s2, intensity);
            return this.pointCount += 1;
        };

        return Heights;

    })();

    WebGLHeatmap = (function () {
        function WebGLHeatmap(_arg) {
            var alphaEnd, alphaRange, alphaStart, error, getColorFun, gradientTexture, image, intensityToAlpha, output, quad, textureGradient, _ref, _ref1,bgColor;
            _ref = _arg != null ? _arg : {}, this.canvas = _ref.canvas, this.width = _ref.width, this.height = _ref.height, intensityToAlpha = _ref.intensityToAlpha, gradientTexture = _ref.gradientTexture, alphaRange = _ref.alphaRange;
            bgColor = _ref.bgColor;
            if (!this.canvas) {
                this.canvas = document.createElement('canvas');
            }
            try {
                this.gl = this.canvas.getContext('experimental-webgl', {
                    depth: false,
                    antialias: false,
                    preserveDrawingBuffer: true
                });
                if (this.gl === null) {
                    this.gl = this.canvas.getContext('webgl', {
                        depth: false,
                        antialias: false,
                        preserveDrawingBuffer: true
                    });
                    if (this.gl === null) {
                        throw 'WebGL not supported';
                    }
                }
            } catch (_error) {
                error = _error;
                throw 'WebGL not supported';
            }
            if (window.WebGLDebugUtils != null) {
                console.log('debugging mode');
                this.gl = WebGLDebugUtils.makeDebugContext(this.gl, function (err, funcName, args) {
                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                });
            }
            this.gl.enableVertexAttribArray(0);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
            if (gradientTexture) {
                textureGradient = this.gradientTexture = new Texture(this.gl, {
                    channels: 'rgba'
                }).bind(0).setSize(2, 2).nearest().clampToEdge();
                if (typeof gradientTexture === 'string') {
                    image = new Image();
                    image.onload = function () {
                        return textureGradient.bind().upload(image);
                    };
                    image.src = gradientTexture;
                } else {
                    if (gradientTexture.width > 0 && gradientTexture.height > 0) {
                        textureGradient.upload(gradientTexture);
                    } else {
                        gradientTexture.onload = function () {
                            return textureGradient.upload(gradientTexture);
                        };
                    }
                }
                getColorFun = 'uniform sampler2D gradientTexture;\nvec3 getColor(float intensity){\n    return texture2D(gradientTexture, vec2(intensity, 0.0)).rgb;\n}';
            } else {
                textureGradient = null;
//                getColorFun = 'vec3 getColor(float intensity){\n' +
//                    '    vec3 blue = vec3(0.0, 0.0, 1.0);\n' +
//                '    vec3 cyan = vec3(0.0, 1.0, 1.0);\n' +
                getColorFun = 'vec3 getColor(float intensity){\n';
                if(bgColor){
                    getColorFun += ' vec3 blue = vec3('+parseInt(bgColor.r || 0.0)+', '+parseInt(bgColor.g || 0.0)+', '+parseInt(bgColor.b || 0.0)+');\n';
                }else{
                    getColorFun +='    vec3 blue = vec3(0.0, 0.0, 1.0);\n';
                }
                getColorFun += '    vec3 cyan = vec3(0.0, 1.0, 1.0);\n' +
                    '    vec3 green = vec3(0.0, 1.0, 0.0);\n' +
                    '    vec3 yellow = vec3(1.0, 1.0, 0.0);\n' +
                    '    vec3 red = vec3(1.0, 0.0, 0.0);\n\n' +
                    '    vec3 color = (\n' +
                    '        fade(-0.25, 0.25, intensity)*blue +\n' +
                    '        fade(0.0, 0.5, intensity)*cyan +\n' +
                    '        fade(0.25, 0.75, intensity)*green +\n' +
                    '        fade(0.5, 1.0, intensity)*yellow +\n' +
                    '        smoothstep(0.75, 1.0, intensity)*red\n' +
                    '    );\n' +
                    '    return color;\n' +
                    '}';
            }
            if (intensityToAlpha == null) {
                intensityToAlpha = true;
            }
            if (intensityToAlpha) {
                _ref1 = alphaRange != null ? alphaRange : [0, 1], alphaStart = _ref1[0], alphaEnd = _ref1[1];
                output = "vec4 alphaFun(vec3 color, float intensity){\n  " +
                    "  float alpha = smoothstep(" + (alphaStart.toFixed(8)) + ", " + (alphaEnd.toFixed(8)) + ", intensity);\n  " +
                    "  return vec4(color*alpha, alpha);\n" +
                    " }";
            } else {
                output = 'vec4 alphaFun(vec3 color, float intensity){\n   ' +
                    ' return vec4(color, 1.0);\n' +
                    ' }';
            }
            this.shader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + ("float linstep(float low, float high, float value){\n   " +
                    " return clamp((value-low)/(high-low), 0.0, 1.0);\n}\n\n" +
                    " float fade(float low, float high, float value){\n   " +
                    " float mid = (low+high)*0.5;\n   " +
                    " float range = (high-low)*0.5;\n   " +
                    " float x = 1.0 - clamp(abs(mid-value)/range, 0.0, 1.0);\n   " +
                    " return smoothstep(0.0, 1.0, x);\n}\n\n" + getColorFun + "\n" + output + "\n\n" +
                    " void main(){\n   " +
                    "  float intensity = smoothstep(0.0, 1.0, texture2D(source, texcoord).r);\n  " +
                    "  vec3 color = getColor(intensity);\n   " +
                    "  gl_FragColor = alphaFun(color, intensity);\n" +
                    " }")
            });
            if (this.width == null) {
                this.width = this.canvas.offsetWidth || 2;
            }
            if (this.height == null) {
                this.height = this.canvas.offsetHeight || 2;
            }
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            this.gl.viewport(0, 0, this.width, this.height);
            this.quad = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            quad = new Float32Array([-1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, 0, 1, 1, -1, 0, 1, 1, 1, 0, 1]);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, quad, this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            this.heights = new Heights(this, this.gl, this.width, this.height);
        }

        WebGLHeatmap.prototype.adjustSize = function () {
            var canvasHeight, canvasWidth;
            canvasWidth = this.canvas.offsetWidth || 2;
            canvasHeight = this.canvas.offsetHeight || 2;
            if (this.width !== canvasWidth || this.height !== canvasHeight) {
                this.gl.viewport(0, 0, canvasWidth, canvasHeight);
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                this.width = canvasWidth;
                this.height = canvasHeight;
                return this.heights.resize(this.width, this.height);
            }
        };

        WebGLHeatmap.prototype.display = function () {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.heights.nodeFront.bind(0);
            if (this.gradientTexture) {
                this.gradientTexture.bind(1);
            }
            this.shader.use().int('source', 0).int('gradientTexture', 1);
            return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        };

        WebGLHeatmap.prototype.update = function () {
            return this.heights.update();
        };

        WebGLHeatmap.prototype.clear = function () {
            return this.heights.clear();
        };

        WebGLHeatmap.prototype.clamp = function (min, max) {
            if (min == null) {
                min = 0;
            }
            if (max == null) {
                max = 1;
            }
            return this.heights.clamp(min, max);
        };

        WebGLHeatmap.prototype.multiply = function (value) {
            if (value == null) {
                value = 0.95;
            }
            return this.heights.multiply(value);
        };

        WebGLHeatmap.prototype.blur = function () {
            return this.heights.blur();
        };

        WebGLHeatmap.prototype.addPoint = function (x, y, size, intensity) {
            return this.heights.addPoint(x, y, size, intensity);
        };

        WebGLHeatmap.prototype.addPoints = function (items) {
            var item, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                _results.push(this.addPoint(item.x, item.y, item.size, item.intensity));
            }
            return _results;
        };

        return WebGLHeatmap;

    })();

    window.createWebGLHeatmap = function (params) {
        return new WebGLHeatmap(params);
    };
})(window);

var $HeatMap = function(obj){
    if(!obj){
        obj = {};
    }
    this.radius = obj.radius || 10;
    this.maxValue = obj.maxValue||1;
    this.minValue = obj.minValue||0;
    this.width = obj.width || 100; // plane
    this.height = obj.height || 100;
    this.intensityToAlpha = obj.intensityToAlpha||false;
    this.alphaRange = obj.alphaRange || [0,1];
    this.gradientTexture = obj.gradientTexture;
    this.canvasHeight = 100;
    this.canvasWidth = parseInt(this.canvasHeight*this.width/this.height); // canvas
    this.positionX = obj.positionX == undefined?this.width/2:parseFloat(obj.positionX);  //palanaddPoint(x,y)3dcanvas
    this.positionY = obj.positionY == undefined?this.height/2:parseFloat(obj.positionY);
    this.heatmap = createWebGLHeatmap({canvas: null,
        width: this.canvasWidth,
        height: this.canvasHeight,
        intensityToAlpha: this.intensityToAlpha,//false,
        alphaRange: this.alphaRange,//[0, 1] //[0, 0.05]
        gradientTexture: this.gradientTexture,
        bgColor:obj.bgColor
    });

};

mono.extend($HeatMap,Object,{

    // ()FF0000() - FFFF00() - 00FF00 - 00FFFF() - 0000FF
    createHeatMap: function () {
//    var heatmap = createWebGLHeatmap({canvas: null, intensityToAlpha:true, alphaRange: [0, 0.05]});
    },

    /**
     * canvas3Dcanvas(0,0)
     * @private
     */
    _getOriginal: function () {
        var x = this.positionX - this.width / 2;
        var y = this.height / 2 + this.positionY;
        return {x: x, y: y};
    },

    _getOriginalX: function () {
        return this.positionX - this.width / 2;
    },

    _getOriginalY: function () {
//    return this.positionY - this.height/2;
        return this.height / 2 + this.positionY; // 3D(2D)y,x+h/2
    },

    _transPositionX: function (x) {
        return (parseFloat(x) - this._getOriginalX()) * (this.canvasWidth / this.width);
    },

    _transPositionY: function (y) {
//    return parseFloat(y) - this.positionY;
        return (this._getOriginalY() - parseFloat(y)) * (this.canvasHeight / this.height);// 3D(2D)y
    },

    /**
     * 3Dwcanvasw
     * @param w
     * @private
     */
    _transWidth: function (d) {
        var w = parseFloat(d);
        if (w <= 0) return 0;
        return w * this.canvasWidth / this.width;
    },

    _transHeight: function (l) {
        var h = parseFloat(l);
        if (h <= 0) {
            return 0;
        }
        return h * this.canvasHeight / this.height;
    },


    /**
     * 
     * 
     * 1
     * 2
     * 3
     * @param x
     * @param y
     * @param w
     * @param l
     * @param value
     * @private
     */
    _generateNearPointsForArea: function (x, y, w, l, value) {
        if (!w || !l) return;
        var count = parseInt(w * l) * 3; //
        var min_x = x - w / 2;
        var min_y = y - l / 2;
        if (min_x < 0 || min_y < 0) return;
        var index = 0;
        var near_area = 5;//this.radius/2;
        while (index < count) {
            var offset_x = (Math.random() * 2 - 1) * (near_area + w / 2); // -1~1
            var offset_y = (Math.random() * 2 - 1) * (near_area + l / 2);
            var p_x = 0, p_y = 0;
            p_x = x + offset_x;
            p_y = y + offset_y;
            if (p_x > min_x
                && p_x < (min_x + w)
                && p_y > min_y
                && p_y < (min_y + l)) { // 
                continue;
            }
            this.heatmap.addPoint(p_x, p_y, this.radius / 2, value / 30);
            index++;
        }
    },

// radiusradius,
// radiusradius?
// areaarearadius*2,

    /**
     * 
     * x,y,l,wcanvas
     * @param obj
     */
    addPointWithArea: function (obj) {
        if (!obj) return;
        if (obj instanceof Array && obj.length > 0) {
            for (var i = 0; i < obj.length; i++) {
                arguments.callee(obj[i]);
            }
        } else {
            if (obj.type && obj.type === 'circle') {
                this._createCircleCloud(obj);
            } else {
                this._createRectCloud(obj);
            }
        }
        //    this._generateNearPointsForArea(t_x,t_y, w,l,value); //
    },

    /**
     * 
     * @param obj
     * @private
     */
    _createCircleCloud: function (obj) {
        if (!obj) return;
        var x = parseFloat(obj.x) || 0;
        var y = parseFloat(obj.y) || 0;
        var radius = parseFloat(obj.radius) || 0;
        if (radius || radius <= 0)return;
    },

    /**
     * rect()
     * @param obj
     * @private
     */
    _createRectCloud: function (obj) {
        if (!obj) return;
        var x = parseFloat(obj.x) || 0;
        var y = parseFloat(obj.y) || 0;
        var w = parseFloat(obj.w) || 0;
        var l = parseFloat(obj.l) || 0;
        var value = parseFloat(obj.value) || 0;
        var axis = obj.axis; //
        w = this._transWidth(w);
        l = this._transHeight(l);
        if (axis && axis == 'z') {
            var v_l = l;
            l = w;
            w = v_l;
        }
        if (!w && !l) {
            this.addPoint(x, y, value);
            return;
        }
        if (!l) {
            l = w;
        }
        if (!w) {
            w = l;
        }
        var t_x = this._transPositionX(x);
        var t_y = this._transPositionY(y);
        this._generatePointsForArea(t_x, t_y, w, l, value);
    },

    /**
     * 
     * 
     * 1radius1/3;
     * 21/X
     * 3=
     * @param x
     * @param y
     * @param w
     * @param l
     * @param value
     * @private
     */
    _generatePointsForArea: function (x, y, w, l, value) {

//        this.heatmap.addPoint(x, y, 100, value);


         if(!w || !l) return;
         var min_x = x -  w/2;
         var min_y = y - l/2;
         var index = 0;
         var count = parseInt(w*l); //
         var offsetX = 1 , offsetY = 1;
         while(index < count){
         if(offsetX >= w){
         offsetX = 1;
         offsetY ++;
         }
         if(offsetX >= w && offsetY >= l){
         break;
         }
         var p_x = min_x + offsetX;
         var p_y = min_y + offsetY;
         this.heatmap.addPoint(p_x, p_y, this.radius, value/20);
         offsetX ++;
         index++;
         }

    },

    _generatePointsForArea_for_random: function (x, y, w, l, value) {
        if (!w || !l) return;
        w += 5;
        l += 5;
        var min_x = x - w / 2;
        var min_y = y - l / 2;
        var index = 0;
        var count = parseInt(w * l); //
        while (index < count) {
            var p_x = min_x + Math.random() * w;
            var p_y = min_y + Math.random() * l;
            this.heatmap.addPoint(p_x, p_y, this.radius, value / 30);
            index++;
        }
    },


    /**
     * (x,y)(x,y)
     * @param x
     * @param y
     * @param value
     * @private
     */
    _paintAtCoord: function (x, y, value) {
        var count = 0;
//    this.heatmap.addPoint(x, y, this.radius, value);
//    return;
//    var max = parseInt(Math.random()*50);
        while (count < this.radius * 2) {
            var xoff = Math.random() * 2 - 1;
            var yoff = Math.random() * 2 - 1;
            var l = xoff * xoff + yoff * yoff;
            if (l > 1) {
                continue;
            }
            var ls = Math.sqrt(l);
            xoff /= ls;
            yoff /= ls;
            xoff *= 1 - l;
            yoff *= 1 - l;
            count += 1;
            this.heatmap.addPoint(x + xoff * this.radius * 2, y + yoff * this.radius * 2, this.radius, value / 10);
//        this.heatmap.addPoint(x+xoff, y+yoff, this.radius, value/30); // canvas100*100
        }
    },

    addPoint: function (x, y, value, dic) {
        x = this._transPositionX(x);
        y = this._transPositionY(y);
//    if(value != null && value != undefined){
//        value = (parseFloat(value) - this.minValue)/(this.maxValue-this.minValue);
//        if(value < 0){
//            value = 0;
//        }
//    }
        var count = 0;
        while (count < 20) {
            var xoff = Math.random() * 2 - 1;
            var yoff = Math.random() * 2 - 1;
            var l = xoff * xoff + yoff * yoff;
            if (l > 1) {
                continue;
            }
            var ls = Math.sqrt(l);
            xoff /= ls;
            yoff /= ls;
            xoff *= 1 - l;
            yoff *= 1 - l;
            count += 1;
            this.heatmap.addPoint(x + xoff * 10, y + yoff * 5, this.radius, value / 20);
        }
    },

    addPoint1: function (x, y, value, radius) {
        x = this._transPositionX(x);
        y = this._transPositionY(y);
        if (value != null && value != undefined) {
            value = (parseFloat(value) - this.minValue) / (this.maxValue - this.minValue);
            if (value < 0) {
                value = 0;
            }
        }
        if (radius) {
            this.heatmap.addPoint(x, y, radius, value);
        } else {
            this._paintAtCoord(x, y, value);
        }
    },


    update: function () {
        this.heatmap.adjustSize(); // can be commented out for statically sized heatmaps, resize clears the map
        this.heatmap.update(); // adds the buffered points
        this.heatmap.display();
//    this.heatmap.multiply(0.9995);
//    this.heatmap.blur();
//    this.heatmap.clamp(0.0, 1.0); // depending on usecase you might want to clamp it
    },

    refresh: function (callback) {
        var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
        var self = this;
//        document.body.appendChild(this.heatmap.canvas); //requestAnimatefield
        raf(function () {
            document.body.appendChild(self.heatmap.canvas);
            self.update();
//            console.log(self.heatmap.canvas.toDataURL());
            if (callback) {
                callback();
            }
        });
    },

    clear: function () {
        this.heatmap.clear();
    },

    getCanvas: function () {
        return this.heatmap.canvas;
    },

    getImage: function () {
        if (this.heatmap.canvas) {
//        var ctx = this.heatmap.canvas.getContext('2d');
//        ctx.fillStyle = 'rgba(0,0,255,1.0)';
//        ctx.fillRect(0,0,500,500);
            return this.heatmap.canvas.toDataURL();
        } else {
            console.log('getImage error!');
        }
    },

    getTemperatureBoard: function () {
        var board = new mono.Plane(this.width, this.height);
        board.setStyle('m.texture.repeat', new mono.Vec2(1, 1))
            .setStyle('m.type', 'basic')
//        .setStyle('m.texture.image', this.getImage())
//        .setStyle('m.transparent', true)
            .setStyle('m.side', 'both');
//    board.setStyle('m.color','#0000FF');
//    if (this.direction == 'h') {
        board.setRotation(90 * Math.PI / 180, 0, 0)
//    }
        var self = this;
        this.refresh(function () {
            board.setStyle('m.texture.image', self.getImage());
            document.body.removeChild(self.heatmap.canvas);
        });
        board.setPositionX(this.positionX);
        board.setPositionZ(this.positionY);
        return board;
    }

});

it.HeatMap3D = $HeatMap;




var $HeatMap2D = function(opt){
    this.defaultOptions = {
//        gradientColors: ['#0066FF', 'cyan', 'lime', 'yellow', 'red'],
//        gradientColors: [{color:'#0066FF',}, 'cyan', 'lime', 'yellow', 'red'],
                gradientColors: ['rgba(0, 102, 255, 0.9)', 'cyan', 'lime', 'yellow', 'red'],
//        gradientColors: ['blue', 'red'],
        minAlpha: 0.05,
        valueScale: 1,
        opacity: 1,
        positionX : null, //
        positionY : null, //
        width : 500,
        height : 500,
        canvasHeight : 500,
//        canvasWidth : 1000,
        blurSize: 30,
        withBg : true, // truefalse
    };
    this.option = opt;
    if (opt) {
        for (var i in this.defaultOptions) {
            if (opt[i] !== undefined) {
                this.option[i] = opt[i];
            } else {
                this.option[i] = this.defaultOptions[i];
            }
        }
    } else {
        this.option = this.defaultOptions;
    }
    this.datas = [];
    this.heatMapCanvas = document.createElement('canvas');
    this.width = this.option.width;
    this.height = this.option.height;
    this.canvasHeight = this.option.canvasHeight;
    this.canvasWidth = this.option.canvasWidth = parseInt(this.canvasHeight*this.width/this.height); // canvas
    this.positionX = this.option.positionX == undefined?this.width/2:parseFloat(this.option.positionX);  //palanaddPoint(x,y)3dcanvas
    this.positionY = this.option.positionY == undefined?this.height/2:parseFloat(this.option.positionY);
    this.BRUSH_SIZE = 20*2*this.canvasHeight/this.height; // canvasWidth20*2
    this.GRADIENT_LEVELS = 256;
    this.withBg = this.option.withBg;

};

mono.extend($HeatMap2D,Object,{


    /**
     * 
     * @param x (x,y)3D(x,z)
     * @param y
     * @param value
     */
    addPoint : function(x,y,value){
        if(arguments.length === 1 && arguments[0] instanceof Array){
            var obj = arguments[0];
            x = obj[0];
            y = obj[1];
            value = obj[2];
        }
        x = this._transPositionX(x);
        y = this._transPositionY(y);
        this.datas.push([x,y,value]);
    },

    /**
     * 
     * x,y,l,wcanvas
     * @param obj
     */
    addPointWithArea: function (obj) {
        if (!obj) return;
        if (obj instanceof Array && obj.length > 0) {
            for (var i = 0; i < obj.length; i++) {
                arguments.callee(obj[i]);
            }
        } else {
//            if (obj.type && obj.type === 'circle') {
//                this._createCircleCloud(obj);
//            } else {
                this._createRectCloud(obj);
//            }
        }
    },

    /**
     * rect()
     * @param obj
     * @private
     */
    _createRectCloud: function (obj) {
        if (!obj) return;
        var x = parseFloat(obj.x) || 0;
        var y = parseFloat(obj.y) || 0;
        var w = parseFloat(obj.w) || 0;
        var l = parseFloat(obj.l) || 0;
        var value = parseFloat(obj.value) || 0;
        var axis = obj.axis; //
        w = this._transWidth(w);
        l = this._transHeight(l);
        if (axis && axis == 'z') {
            var v_l = l;
            l = w;
            w = v_l;
        }
        if (!w && !l) {
            this.addPoint(x, y, value);
            return;
        }
        if (!l) {
            l = w;
        }
        if (!w) {
            w = l;
        }
        var t_x = this._transPositionX(x);
        var t_y = this._transPositionY(y);
        this._generatePointsForArea(t_x, t_y, w, l, value);
    },


    /**
     * 
     * 
     * 1radius1/3;
     * 21/X
     * 3=
     * @param x
     * @param y
     * @param w
     * @param l
     * @param value
     * @private
     */
    _generatePointsForArea: function (x, y, w, l, value) {
        if(!w || !l) return;
//        value = 0.8;
        var min_x = x -  w/2;
        var min_y = y - l/2;
//        var index = 0;
//        var count = parseInt(w*l); //
//        var offsetX = 1 , offsetY = 1;
        var size = this.BRUSH_SIZE;//+2;
        var columns  = parseInt(w/size);
        var rows = parseInt(l/(size));

        if(columns%2 ===0){
            columns = columns+1; //
        }
        if(rows%2 ===0){
            rows = rows+1;//
        }

        var deltaC=0 ,deltaR=0;
        if(columns > 5){
            deltaC=1;
            columns = columns+deltaC;//
        }
        if(rows > 5){
            deltaR=1;
            rows = rows+deltaR;//
        }

        var vx = x,vy = y;
//        this.datas.push([vx,vy,value]);
        for(var r = 0 ; r < rows; r++){
            var dy = vy + Math.pow(-1,r) * r/2 * size;
//            if(r === 0 ){ // (x,y)
//                dy = vy;
//            }
            for(var c = 0 ; c < columns; c++ ){
                var dx = vx + Math.pow(-1,c) * c/2 * size;
                if(c===0){
                    dx = vx;
                }
                var deltaValue = 1;
                if( columns-c <= deltaC || rows -r < deltaR ){
//                    if(columns-c == 2 ||rows -r ==2 ){
//                        deltaValue = 0.5;
//                    }else{
                    deltaValue = 0.3;
//                    }
                }
                this.datas.push([dx,dy,value*deltaValue*Math.random()]);
            }
        }
        // 
//        for(var i = 0 ; i < rows ; i++){
//
//        }


//        for(var count = 0 ; count < rows*columns ; count++){
//            var x = min_x + Math.random() * w; //* this.BRUSH_SIZE;
//            var y = min_y + Math.random() * l;
//            this.datas.push([x,y,Math.random()]);
//        }

        // 
//        for(var i = 0 ; i < rows ; i++){
//            var x = min_x - 1.5*size;
//            var y = min_y + i*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            x = min_x - 2.5*size;
//            r_value = value*0.3*Math.random();
//            this.datas.push([x,y,r_value]);
//
//            x = min_x + (columns+1)*size; //* this.BRUSH_SIZE;
//            r_value = value*0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value*0.3*Math.random();
//            x = min_x + (columns+2)*size;
//            this.datas.push([x,y,r_value]);
//        }
//
//        // 
//        for(var i = 0 ; i < columns ; i++){
//            var x = min_x + i*size; //* this.BRUSH_SIZE;
//            var y = min_y - 1.5*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3 * Math.random();
//            y = min_y - 2.5*size;
//            this.datas.push([x,y,r_value]);
//
//            y = min_y + (rows +1)*size;
//            r_value = value * 0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3*Math.random();
//            y = min_y + (rows +2)*size;
//            this.datas.push([x,y,r_value]);
//        }

    },
//    _generatePointsForArea: function (x, y, w, l, value) {
//        if(!w || !l) return;
//        value = 0.8;
//        var min_x = x -  w/2;
//        var min_y = y - l/2;
//        var size = this.BRUSH_SIZE;//+2;
//        var columns  = parseInt(w/size);
//        var rows = parseInt(l/(size));
//
//        //minmax
//        var vx = x,vy = y;
//        this.datas.push([vx,vy,value*Math.random()]);
//        for(var r = 0 ; r < rows; r++){
//            var dy = vy + Math.pow(-1,r) * size;
//            for(var c = 0 ; c < columns; c++ ){
//                var dx = vx + Math.pow(-1,c) * size;
//                this.datas.push([dx,dy,value*Math.random()]);
//            }
//        }
//
////        for(var r = 0 ; r < rows; r++){
////            var y = min_y + r * size;
////            for(var c = 0 ; c < columns; c++ ){
////                var x = min_x + c * size;
////                this.datas.push([x,y,value*Math.random()]);
////            }
////        }
//
//        // 
//        for(var i = 0 ; i < rows ; i++){
//            var x = min_x - 1.5*size;
//            var y = min_y + i*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            x = min_x - 2.5*size;
//            r_value = value*0.3*Math.random();
//            this.datas.push([x,y,r_value]);
//
//            x = min_x + (columns+1)*size; //* this.BRUSH_SIZE;
//            r_value = value*0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value*0.3*Math.random();
//            x = min_x + (columns+2)*size;
//            this.datas.push([x,y,r_value]);
//        }
//
//        // 
//        for(var i = 0 ; i < columns ; i++){
//            var x = min_x + i*size; //* this.BRUSH_SIZE;
//            var y = min_y - 1.5*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3 * Math.random();
//            y = min_y - 2.5*size;
//            this.datas.push([x,y,r_value]);
//
//            y = min_y + (rows +1)*size;
//            r_value = value * 0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3*Math.random();
//            y = min_y + (rows +2)*size;
//            this.datas.push([x,y,r_value]);
//        }
//
//    },

    /**
     * heatMapCanvas
     * @returns {HTMLElement|*|$HeatMap2D.heatMapCanvas}
     */
    getCanvas: function (){
        var data = this.datas;
        var width = this.canvasWidth;
        var height = this.canvasHeight;
        var brush = this._createBrush();
        var gradient = this._createGradient();
        var r = this.BRUSH_SIZE + this.option.blurSize;

        var canvas = this.heatMapCanvas ;//= document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');

        var len = data.length;
        for (var i = 0; i < len; ++i) {
            var p = data[i];
            var x = p[0];
            var y = p[1];
            var value = p[2];
            // calculate alpha using value
            var alpha = Math.min(1, Math.max(value * this.option.valueScale
                || this.option.minAlpha, this.option.minAlpha));
            // draw with the circle brush with alpha
            ctx.globalAlpha = alpha;
            ctx.drawImage(brush, x - r, y - r);
        }

        // colorize the canvas using alpha value and set with gradient
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var pixels = imageData.data;
        var len = pixels.length / 4;
        while (len--) {
            var id = len * 4 + 3;
            var alpha = pixels[id] / 256;
            var colorOffset = Math.floor(alpha * (this.GRADIENT_LEVELS - 1));
            pixels[id - 3] = gradient[colorOffset * 4];     // red
            pixels[id - 2] = gradient[colorOffset * 4 + 1]; // green
            pixels[id - 1] = gradient[colorOffset * 4 + 2]; // blue
            if (this.withBg) {
                //            if(!pixels[id] || pixels[id] < 10){
                pixels[id] = 190; //205 
                //            }else{
                //                pixels[id] = 205;
                //            }
            } else {
                pixels[id] *= this.option.opacity; // alpha
            }  
        }
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    },

    /**
     * 
     * @private
     * @returns
     */
    _createBrush: function () {
        if (!this._brushCanvas) {
            this._brushCanvas = document.createElement('canvas');

            // set brush size
            var r = this.BRUSH_SIZE + this.option.blurSize;
            var d = r * 2;
            this._brushCanvas.width = d;
            this._brushCanvas.height = d;

            var ctx = this._brushCanvas.getContext('2d');

            // in order to render shadow without the distinct circle,
            // draw the distinct circle in an invisible place,
            // and use shadowOffset to draw shadow in the center of the canvas
            ctx.shadowOffsetX = d;
            ctx.shadowBlur = this.option.blurSize;
            // draw the shadow in black, and use alpha and shadow blur to generate
            // color in color map
            ctx.shadowColor = 'black';

            // draw circle in the left to the canvas
            ctx.beginPath();
            ctx.arc(-r, r, this.BRUSH_SIZE, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
        }
        return this._brushCanvas;
    },

    /**
     * value
     * @returns {array}
     */
    _createGradient: function () {
        if (!this._gradientPixels) {
            var levels = this.GRADIENT_LEVELS;
            var canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = levels;
            var ctx = canvas.getContext('2d');
            var gradient = ctx.createLinearGradient(0, 0, 0, levels);
            var len = this.option.gradientColors.length;
            for (var i = 0; i < len; ++i) {
                if (typeof this.option.gradientColors[i] === 'string') {
                    gradient.addColorStop((i + 1) / len,
                        this.option.gradientColors[i]);
                } else {
                    gradient.addColorStop(this.option.gradientColors[i].offset,
                        this.option.gradientColors[i].color);
                }
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, levels);
            this._gradientPixels = ctx.getImageData(0, 0, 1, levels).data;
        }
        return this._gradientPixels;
    },

    /**
     * canvas3Dcanvas(0,0)
     * @private
     */
    _getOriginal: function () {
        var x = this.positionX - this.width / 2;
        var y = this.height / 2 + this.positionY;
        return {x: x, y: y};
    },

    _getOriginalX: function () {
        return this.positionX - this.width / 2;
    },

    _getOriginalY: function () {
//    return this.positionY - this.height/2;
        return this.height / 2 + this.positionY; // 3D(2D)y,x+h/2
    },

    _transPositionX: function (x) {
        return (parseFloat(x) - this._getOriginalX()) * (this.canvasWidth / this.width);
    },

    _transPositionY: function (y) {
//    return parseFloat(y) - this.positionY;
        return (this._getOriginalY() - parseFloat(y)) * (this.canvasHeight / this.height);// 3D(2D)y
    },

    /**
     * 3Dwcanvasw
     * @param w
     * @private
     */
    _transWidth: function (d) {
        var w = parseFloat(d);
        if (w <= 0) return 0;
        return w * this.canvasWidth / this.width;
    },

    _transHeight: function (l) {
        var h = parseFloat(l);
        if (h <= 0) {
            return 0;
        }
        return h * this.canvasHeight / this.height;
    },

    clear : function(){
        this.datas = [];
    },

    /**
     * WebGLcanvasdocument
     * webgldocumentdocumentremove
     * @param callback
     */
    refresh: function (callback) {
        var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
        var self = this;
        raf(function () {
            document.body.appendChild(self.getCanvas());
            if (callback) {
                callback();
            }
        });
    },

    getImage: function () {
        if (this.heatMapCanvas) {
//        var ctx = this.heatmap.canvas.getContext('2d');
//        ctx.fillStyle = 'rgba(0,0,255,1.0)';
//        ctx.fillRect(0,0,500,500);
            return this.heatMapCanvas.toDataURL();
        } else {
            console.log('getImage error!');
        }
    },

    getTemperatureBoard: function () {
        var board = new mono.Plane(this.width, this.height);
        board.setStyle('m.texture.repeat', new mono.Vec2(1, 1))
              .setStyle('m.type', 'basic')
//        .setStyle('m.texture.image', this.getImage())
           // .setStyle('m.transparent', true)
           // .setStyle('m.type', 'phong')
           .setStyle('m.side', 'both');
           if(!this.withBg){
              board.setStyle('m.transparent', true);
              board.setStyle('m.type', 'phong');
           }
        board.setRotation(90 * Math.PI / 180, 0, 0);
        var self = this;
        this.refresh(function () {
            board.setStyle('m.texture.image', self.heatMapCanvas); //canvasimage
            // board.setStyle('m.texture.image', self.getImage());
            document.body.removeChild(self.heatMapCanvas);
        });
        // (this.positionX,this.positionY)
        // parent
        board.setPositionX(this.positionX);
        board.setPositionZ(this.positionY);
        return board;
    }

});

it.HeatMap = $HeatMap2D;


/**
 * 
 * 
 * user-asset-power
 * userpowerMapuseruser
 *
 * 01233D()
 *         0
 *
 * parent
 * 
 **/
var $DRMManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	// this.userMap = {};
	this.dataPowerMap = {}; //Map
	this.virtualLevel = new it.VirtualManager(this.sceneManager); // level1
	this.visibleLevel = new it.VisibleManager(this.sceneManager); // level2
	this.initDrmListener();
	this._dRMManagerChangeDispatcher = new mono.EventDispatcher();
	this.registerDRM();
};

mono.extend($DRMManager,Object,{

	 registerDRM : function(){
	 	// if (this.drmListener) {
	 	this.addDRMChangeListener(this.drmListener);
	 	// }
	 	this.sceneManager.viewManager3d.addVisibleFilter(this.visibleLevel);
	 	this.sceneManager.viewManager3d.addMaterialFilter(this.virtualLevel);
	 },

	 unRegister : function(){
	 	this.removeDRMChangeListener(this.drmListener);
	 	this.sceneManager.viewManager3d.removeVisibleFilter(this.visibleLevel);
	 	this.sceneManager.viewManager3d.removeMaterialFilter(this.virtualLevel);
	 },

	initDrmListener: function() {
		var self = this;
		this.drmListener = function(e) {
			var kind = e.kind;
			var dataId = e.dataId;
			var oldLevel = e.oldLevel;
			var newLevel = e.newLevel;
			if (!kind) {
				return;
			} else if (kind == 'add') { //addupdateoldLevel
				self._addOrUpdateAction(dataId,oldLevel,newLevel);
			} else if (kind == 'remove') {
				self._removeAction(dataId,oldLevel,newLevel);
			} else if (kind == 'clear') {
				self._clearAction();
			}
		};
	},

    /**
     * dataId
     * filtermapcheckparentmap
     * 
     */
	_addOrUpdateAction: function(dataId, oldLevel, newLevel) {
		if (!dataId) {
			return;
		}
		var data = this.dataManager.getDataById(dataId);
		// if (oldLevel != undefined) { // update
		// update
		var parentLevel = this.getParentLevel(data)||0; //level
		if (parentLevel <= newLevel) {
			if (newLevel == 1) {
				this.setLevel1ForData(data);
			} else if (newLevel == 2) {
				this.setLevel2ForData(data);
			} else if (newLevel == 3) {
				this.setLevel3ForData(data);
			} else { //newLevel == 0
				this.setLevel0ForData(data);
			}
			this.sceneManager.viewManager3d.clearVisibleMap(); //visibleFiltervisibleMap()
		}

	},
    
    /**
     * Level
     * 
     */
	getParentLevel : function(dataOrId){
		if (!dataOrId) {
			return 0;
		}
		var data = null;
		if (dataOrId instanceof it.Data) {
			data = dataOrId;
		}else {
			data = this.dataManager.getDataById(dataOrId);
		}
		if (!data) {
			return 0;
		}
		var parent = this.dataManager.getDataById(data.getParentId());
		if (!parent) {
			return 0;
		}
		if (this.dataPowerMap[parent.getId()] != undefined) {
			var level = this.dataPowerMap[parent.getId()];
			if (level == 3 ) { // 3
				return 3;
			}
			var ancLevel = this.getParentLevel(parent,this);
			if (ancLevel > level) {
				return ancLevel;
			}else{
				return level;
			}
		}else {
			return this.getParentLevel(parent,this);
		}
		
	},

    /**
     * datalevel1
     */
	setLevel1ForData : function(data){
		if (!data) {
			return;
		}
		this._removeFromLevel3(data); //level3
		this._removeFromLevel2(data); //level2
		this.virtualLevel.add(data); // level1level
		var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childLevel = this.dataPowerMap[child.getId()];
                if(child && (!childLevel || childLevel <= 1)){//levellevel1parent
                    this.setLevel1ForData(child,this);
                }else if (childLevel == 2) {
                	this.setLevel2ForData(child,this);
                }else if (childLevel == 3){
                	this.setLevel3ForData(child,this);
                }
            }
        }
	},

    /**
     * datalevel2
     */
	setLevel2ForData : function(data){
		if (!data) {
			return ;
		}
		this._removeFromLevel3(data); //level3
		this.visibleLevel.setVisible(data,false);
		var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childLevel = this.dataPowerMap[child.getId()];
                if(child && (!childLevel || childLevel <= 2)){//levellevel1parent
                    this.setLevel2ForData(child,this);
                }else if(childLevel == 3){
                	this.setLevel3ForData(child,this);
                }
            }
        }
	},
    
    /**
     * datalevel33D
     * 1
                          2
                          3box
     * 
     */
	setLevel3ForData : function(data){
		if (!data) {
			return ;
		}
	},

    /**
     * datalevel00
     */
	setLevel0ForData : function(data){
		if (!data) {
			return ;
		}
		this._removeFromLevel3(data);
		this._removeFromLevel2(data);
		this._removeFromLevel1(data);
		var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childLevel = this.dataPowerMap[child.getId()];
                if(child && !childLevel){//0parent()
                    this.setLevel0ForData(child,this);
                }else if (childLevel == 1) {
                	this.setLevel1ForData(child,this);
                }else if (childLevel == 2){
                	this.setLevel2ForData(child,this);
                }else if (childLevel == 3){
                	this.setLevel3ForData(child,this);
                }
            }
        }
	},

	_removeFromLevel3 : function(data){

	},

	_removeFromLevel2 : function(data){
		this.visibleLevel.setVisible(data,true); 
	},

	_removeFromLevel1 : function(data){
		this.virtualLevel.remove(data);
	},
    
    /**
     * level0level0do nothing
     */
	_removeFromLevel0 : function(data){

	},

	_clearLevel3 : function(){

	},

	_clearLevel2 : function(){
		this.visibleLevel.clear();
	},

	_clearLevel1 : function(){
		this.virtualLevel.clearAll();
	},

	_clearLevel0 : function(){
		// do nothing......
	},

    /** 
     * 
     */
	_removeAction : function(dataId,oldLevel){
		if (!dataId) {
			return;
		}
		var data = this.dataManager.getDataById(dataId);
		var parentLevel = this.getParentLevel(data) || 0; //level
		if (parentLevel < oldLevel) {
			if (parentLevel == 1) {
				this.setLevel1ForData(data);
			} else if (parentLevel == 2) {
				this.setLevel2ForData(data);
			} else if (parentLevel == 3) {
				this.setLevel3ForData(data);
			} else { //newLevel == 0 //
				this.setLevel0ForData(data);
			}
			this.sceneManager.viewManager3d.clearVisibleMap(); 
		}
	},

	_clearAction : function(){
		this._clearLevel0();
		this._clearLevel1();
		this._clearLevel2();
		this._clearLevel3();
		this.sceneManager.viewManager3d.clearVisibleMap(); 
	},

    /**
     * 
     * datalevel
     * 
     */
	initDefaultLevel : function(level){
		var dataMap = this.dataManager._dataMap;
		for(var id in dataMap){
			this._addOrUpdateAction(id,null,level);
		}
	},

     // /**
     //  * userdataOrId
     //  */
     // add : function(dataOrId,powerLevel){
     // 	this.update(dataOrId,powerLevel);
     // },

     /**
      * userdataOrId
      */
	 update : function(dataOrId,powerLevel){
	 	if (!dataOrId) {
	 		return ;
	 	}
	 	if (powerLevel == null || powerLevel == undefined) {
	 		console.log('please input right powerLevel, like 0,1,2,3');
	 	}
	 	var dataId = dataOrId;
	 	if (dataOrId instanceof it.Data) {
	 		dataId = dataOrId.getId();
	 	}
	 	var oldLevel = this.dataPowerMap[dataId];
	 	this.dataPowerMap[dataId] = powerLevel;
		this._dRMManagerChangeDispatcher.fire({
			kind: 'add', //addupdate
			dataId : dataId,
			oldLevel: oldLevel,
			newLevel: powerLevel
		});
	 },
     
     /**
      * 
      */
	 remove : function(dataOrId){
	 	if (!dataOrId) {
	 		return;
	 	}
	 	var dataId = dataOrId;
	 	if (dataOrId instanceof it.Data) {
	 		dataId = dataOrId.getId();
	 	}
	 	if (this.dataPowerMap[dataId] == undefined) {
	 		return ;
	 	}
	 	var oldLevel = this.dataPowerMap[dataId];
	 	delete this.dataPowerMap[dataId];
	 	this._dRMManagerChangeDispatcher.fire({
			kind: 'remove',
			dataId: dataId,
			oldLevel: oldLevel
		});
	 },

     /**
      * 0
      */
	 clear : function(){
	 	this.dataPowerMap = {};
	 	this._dRMManagerChangeDispatcher.fire({
			kind: 'clear'
		});
	 },

	 addDRMChangeListener : function(listener, scope, ahead){
	 	this._dRMManagerChangeDispatcher.add(listener, scope, ahead);
	 },

	 removeDRMChangeListener : function(listener, scope, ahead){
	 	this._dRMManagerChangeDispatcher.remove(listener, scope);
	 },


});

it.DRMManager = $DRMManager;



it.PopMenuManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.getMenuItemsFunction = null;
    this._initPopMenu();
};

mono.extend(it.PopMenuManager,Object,{
     _initPopMenu : function(){
     	var self = this,network = this.sceneManager.network3d;
        var popupMenu = this._popupMenu = new twaver.controls.PopupMenu(network.getRootView());
        popupMenu.setBackground('#90C3D4');
        popupMenu.setBorder("2px solid #90C3D4");
        var oShow = popupMenu.show;
        popupMenu.show = function(e){// 
           oShow.call(this,e);
           var view = this._view;
           var style = view.style;
            style.left = (parseInt(style.left) + 1) + 'px';
            style.top = (parseInt(style.top) + 1)+ 'px';
        };
        initPopupMenu();
        function initPopupMenu(){
            var lastData, box = network.getDataBox(), event;
            popupMenu.onMenuShowing = function(e){
               event = e;
                var first = network.getFirstElementByMouseEvent(e, false, function (data) {
                    var flag = data.getClient('mainVisible');
                    var mainObj = Utils.isNotNull(flag);
                    return !mainObj;
                });
                var items = [];
                if(first){
                   lastData = first.element;
                   var data = main.sceneManager.getNodeData(lastData);
                   items = self.getMenuItems(lastData,data,event,first);
                }else{
                	items = self.getMenuItems(null,null,event,null);
                }
                if(items && items.length > 0){
                	popupMenu.setMenuItems(items);
                	return true;
                }
                return false;
            };
        };


     },

     getPopupMenu : function(){
     	return this._popupMenu;
     },
     // [{label : ,action : function(menuItem){},group:none}]
     getMenuItems : function(element,data,event,eventObject){
        if(this.getMenuItemsFunction){
        	return this.getMenuItemsFunction(element,data,event,eventObject);
        }
        return [];
     },
});
})(window);